<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Verovio — random key by signature count</title>

  <!-- Verovio CDN (replace with local copies if you prefer) -->
  <script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js"></script>
  <script src="https://www.verovio.org/javascript/latest/verovio-toolkit-hum.js"></script>

  <style>
    :root{
      --bg:#f7f7f9; --card:#fff; --border:#e6e6ea; --ink:#111; --muted:#666;
      --gold:#FFCD00; --gold-ink:#2b2000; --butter:#FFEFAD; --grey:#e4e4e7;
    }
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:12px;background:var(--bg);color:var(--ink)}
    .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px}
    header{display:flex;align-items:center;gap:12px;flex-wrap:wrap}

    #viewer{min-height:180px;padding:10px}
    #svg{display:block;width:100%}
    #humPanel{white-space:pre-wrap;font-family:monospace;background:#0e1620;color:#e6eef8;padding:10px;border-radius:8px;margin-top:10px;max-height:260px;overflow:auto}
    .small{font-size:.9rem;color:var(--muted)}
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .chip-row{display:flex;gap:8px;flex-wrap:wrap}
    .spacer{flex:1}

    /* Filter chips */
    .btn{padding:6px 10px;border-radius:999px;border:1px solid var(--grey);background:var(--grey);color:#222;cursor:pointer}
    .btn.selected{background:var(--butter);border-color:var(--gold)}

    /* New Bass Line button (prominent) */
    .new-bass-btn{
      padding:8px 14px;
      border-radius:999px;
      border:1px solid #e6b800;
      background:var(--gold);
      color:var(--gold-ink);
      font-weight:600;
      box-shadow:0 1px 0 rgba(0,0,0,0.06), inset 0 0 0 1px rgba(255,255,255,0.35);
      cursor:pointer;
    }
    .new-bass-btn:hover{ filter:brightness(0.97); }
    .new-bass-btn:active{ transform:translateY(1px); }

    /* Pills */
    .pill-row { display:flex; gap:8px; align-items:center; margin-left:4px; }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      background: #fff;
      border:1px solid var(--border);
      box-shadow: 0 1px 0 rgba(0,0,0,0.04);
      font-size:0.95rem;
      color:var(--ink);
      white-space:nowrap;
    }
    .pill .muted { color:var(--muted); font-size:.85rem; margin-left:6px; }
    .pill.key { background:#fff; border-color:var(--border); color:var(--ink); font-weight:600; }

    /* Key-range chips */
    .key-chip{ padding:6px 10px; border-radius:999px; border:1px solid #e6b800; background:var(--gold); color:var(--gold-ink); cursor:pointer; }
    .key-chip.off{ background:var(--grey); border-color:var(--grey); color:#222; }
    .key-range-commands .cmd{ padding:6px 10px; border-radius:999px; border:1px solid #e6b800; background:var(--butter); color:#222; cursor:pointer; }
  </style>
</head>
<body>

<div class="card">
  <header>
    <button id="randomFiltered" class="new-bass-btn" type="button">New Bass Line</button>

    <div class="pill-row" id="titlePills" aria-hidden="false" style="margin-left:6px">
      <div class="pill" id="titlePill">No title <span class="muted" id="titleDiff"></span></div>
      <div class="pill key" id="keyPill"><span id="keyPillValue">original</span></div>
    </div>

    <div class="spacer"></div>
  </header>

  <!-- Filters -->
  <div class="card" style="margin-top:10px">
    <div class="row">
      <span class="small">Filters:</span>

      <div class="chip-row" id="dirRow">
        <button class="btn" data-filter="dir" data-value="ascending">Ascending</button>
        <button class="btn" data-filter="dir" data-value="descending">Descending</button>
      </div>

      <div class="chip-row" id="modeRow">
        <button class="btn" data-filter="mode" data-value="major">Major</button>
        <button class="btn" data-filter="mode" data-value="minor">Minor</button>
      </div>

      <div class="chip-row" id="diffRow"></div>

      <div class="spacer"></div>
      <button id="clearFilters">Clear filters</button>
    </div>

    <div class="small" style="margin-top:6px">
      Matching files: <span id="matchCount">0</span> / <span id="totalCount">0</span>
    </div>
  </div>

  <!-- Key range -->
  <div class="card" style="margin-top:10px">
    <div class="row" style="align-items:flex-start">
      <div style="min-width:80px"><strong class="small">Key range</strong></div>
      <div class="chip-row" id="keyRangeRow" style="gap:8px;max-width:520px"></div>
      <div class="key-range-commands" style="display:flex;gap:8px;margin-left:auto">
        <button class="cmd" id="keySelectAll">select all</button>
        <button class="cmd" id="keySelectNone">select none</button>
      </div>
    </div>
  </div>

  <div id="viewer" class="card" style="margin-top:10px">
    <div id="svg">Waiting for Verovio…</div>
    <div style="margin-top:8px" class="small">created for the University of Iowa Organ Studio</div>
  </div>

  <label class="small" style="margin-top:8px;display:block">Displayed humdrum / .krn (prepared shown below):</label>
  <div id="humPanel">(no file loaded)</div>

  <div class="small" id="status" style="margin-top:8px">Status: initializing…</div>
</div>

<script>
(async function () {
  // ---------- DOM refs ----------
  const svgHost     = document.getElementById('svg');
  const humPanel    = document.getElementById('humPanel');
  const status      = document.getElementById('status');
  const dirRow      = document.getElementById('dirRow');
  const modeRow     = document.getElementById('modeRow');
  const diffRow     = document.getElementById('diffRow');
  const matchCount  = document.getElementById('matchCount');
  const totalCount  = document.getElementById('totalCount');
  const randomBtn   = document.getElementById('randomFiltered');
  const clearBtn    = document.getElementById('clearFilters');

  const keyRangeRow = document.getElementById('keyRangeRow');
  const keySelectAllBtn = document.getElementById('keySelectAll');
  const keySelectNoneBtn = document.getElementById('keySelectNone');

  // Pill elements
  const titlePill = document.getElementById('titlePill');
  const titleDiff = document.getElementById('titleDiff');
  const keyPillValue = document.getElementById('keyPillValue');

  function setStatus(txt, isErr){
    status.textContent = 'Status: ' + txt;
    status.style.color = isErr ? 'crimson' : '';
  }

  // ---------- Verovio init ----------
  function waitForVerovio(timeout=10000){
    return new Promise((resolve,reject) => {
      const start = performance.now();
      (function poll(){
        if (window.verovio && window.verovio.module) return resolve();
        if (performance.now() - start > timeout) return reject(new Error('verovio global/module not found'));
        setTimeout(poll,40);
      })();
    });
  }

  try {
    setStatus('waiting for verovio module...');
    await waitForVerovio();
  } catch (err) {
    setStatus('verovio module not found — check script paths', true);
    svgHost.textContent = 'Verovio module not found';
    return;
  }

  let vrv = null;
  async function createToolkit(){
    return new Promise((resolve,reject) => {
      try {
        if (typeof verovio.toolkit === 'function') {
          vrv = new verovio.toolkit();
          return resolve(vrv);
        }
      } catch(e){}
      const mod = window.verovio && window.verovio.module;
      if (mod && typeof mod.onRuntimeInitialized === 'function') {
        mod.onRuntimeInitialized = () => {
          try { vrv = new verovio.toolkit(); resolve(vrv); } catch(err){ reject(err); }
        };
      } else {
        setTimeout(() => {
          try { vrv = new verovio.toolkit(); resolve(vrv); } catch(err){ reject(err); }
        }, 500);
      }
    });
  }

  try {
    setStatus('initializing toolkit...');
    await createToolkit();
  } catch (err) {
    console.error(err);
    setStatus('Error creating toolkit: ' + (err.message||err), true);
    svgHost.textContent = 'Toolkit creation failed; see console';
    return;
  }

  const baseOptions = { scale:50, pageWidth:900, adjustPageHeight:true, spacingLinear:0.32, spacingNonLinear:0.46 };
  vrv.setOptions(baseOptions);
  setStatus('toolkit ready');

  // ---------- Helpers ----------
  function hasKeyDesignationKRn(krn){ return /^\*([A-Ga-g])([#b-]?)\s*:/m.test(krn); }
  function hasKeySigKRn(krn){ return /^\*k\s*\[[^\]]*\]/m.test(krn); }

  // Mode from *X: — uppercase = Major, lowercase = minor
  function modeFromKern(krn){
    const m = krn.match(/^\*([A-Ga-g])([#b-]?)\s*:/m);
    if (!m) return null;
    const isMajor = (m[1] === m[1].toUpperCase());
    return isMajor ? 'major' : 'minor';
  }

  // STRICT metadata extractor (no generic !! fallback)
  function metaFromHeader(krn){
    const lines = krn.split(/\r?\n/).slice(0, 80);
    let dir = null, diff = null, title = null, mode = null;

    for (const ln of lines){
      const s = ln.trim();
      if (!s || !s.startsWith('!!')) continue;

      const titleMatch = s.match(/^!!\s*(?:Title|T)\s+(.*)$/i);
      if (titleMatch && titleMatch[1] && !title){
        title = titleMatch[1].trim();
        continue;
      }

      const numMatch = s.match(/^!!\s*Number\s+(\d+)\s*$/i);
      if (numMatch && numMatch[1]){
        diff = parseInt(numMatch[1], 10);
        continue;
      }

      const dirLine = s.match(/^!!\s*Dir\b(.*)$/i);
      if (dirLine){
        const rest = dirLine[1];
        if (/ascending/i.test(rest)) dir = 'ascending';
        if (/descending/i.test(rest)) dir = 'descending';
        if (/major/i.test(rest)) mode = 'major';
        if (/minor/i.test(rest)) mode = 'minor';
        continue;
      }
    }

    if (!mode) mode = modeFromKern(krn);
    return { dir, mode, diff, title };
  }

  function escapeHtml(str){
    return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }
  function capitalize(s){
    return String(s || '').replace(/^\w/, c => c.toUpperCase());
  }

  // ---------- GENERALIZED SUPPRESSION ----------
  // Replace spines 3 & 4 with '.' starting AFTER the first key declaration *X:
  // Keep '*-' intact. Dot EVERYTHING else (data, barlines, interpretations).
  function suppressThirdFourthSpinesAfterKey(krnText){
    const lines = krnText.split(/\r?\n/);
    let suppress = false;

    // Regex matches *X: where X is a letter A–G/a–g with optional accidentals (#, bb, b, n, -)
    // Examples: *C: *a: *f#: *Eb: *c##:
    const KEY_TOKEN_RE = /^\*[A-Ga-g](?:#{1,2}|b{1,2}|n|-)?\s*:\s*$/;

    return lines.map(line => {
      // Quick path for non-tab lines
      if (!line.includes('\t')) {
        // If any single-spine line contains a key token, start suppression from NEXT line
        if (!suppress && KEY_TOKEN_RE.test(line.trim())) suppress = true;
        return line;
      }

      const fields = line.split('\t');

      // If the line contains any key token in any spine, begin suppression from NEXT line
      if (!suppress) {
        const hasKeyHere = fields.some(f => KEY_TOKEN_RE.test(f.trim()));
        if (hasKeyHere) {
          suppress = true;
          return line; // don't alter the key-declaration line itself
        }
        return line; // still before the key: no changes
      }

      // We are after the key: dot out spines 3 and 4 if present
      for (let i = 2; i <= 3 && i < fields.length; i++){
        const tok = fields[i].trim();
        if (tok !== '*-') fields[i] = '.';
      }
      return fields.join('\t');
    }).join('\n');
  }

  // ---------- Title pill [Dir Mode] [Title] {Number}
  function updatePillsFromCatalogEntry(entry){
    const dirWord  = entry?.dir ? capitalize(entry.dir) : '';
    const modeWord = entry?.mode ? capitalize(entry.mode) : '';
    const dirMode  = [dirWord, modeWord].filter(Boolean).join(' ');

    // Only explicit Title (or fallback to filename), never generic '!! ...'
    let titleText = entry?.title || '';
    if (!titleText && entry?.path) {
      const fname = entry.path.split('/').pop() || entry.path;
      const parts = fname.split('.');
      if (parts.length > 1) parts.pop();
      titleText = parts.join('.') || fname;
    }

    const leading = dirMode ? (dirMode + ' ') : '';
    const mainText = leading + (titleText || 'No title');
    const diffText = (entry && entry.diff != null) ? String(entry.diff) : '';

    titlePill.innerHTML = escapeHtml(mainText) + (diffText ? ` <span class="muted">${escapeHtml(diffText)}</span>` : '');
  }

  // Key pill helpers
  function formatKeyName(tonic, mode){
    if (!tonic) return 'original';
    const m = String(tonic).trim().match(/^([A-Ga-g])(.+)?$/);
    if (!m) return tonic + ' ' + (mode === 'minor' ? 'minor' : 'major');
    let letter = m[1];
    let acc = m[2] || '';
    acc = acc.replace(/bb/g, '♭♭').replace(/b/g, '♭').replace(/#/g, '♯');
    const root = (mode === 'minor') ? letter.toLowerCase() : letter.toUpperCase();
    return root + acc + ' ' + (mode === 'minor' ? 'minor' : 'major');
  }
  function updateKeyPill(tonic, mode){
    keyPillValue.textContent = formatKeyName(tonic, mode);
  }

  function renderWithTonic(tonic, mode) {
    const opt = { ...baseOptions };
    if (tonic) opt.transpose = String(tonic);
    vrv.setOptions(opt);
    try {
      const svg = vrv.renderData(currentKrn || '', {});
      svgHost.innerHTML = svg;
      humPanel.textContent = currentKrn || '(empty)';
      setStatus(tonic ? `Rendered with tonic "${tonic}"` : 'Rendered original');
      updateKeyPill(tonic || '', mode || (modeFromKern(currentKrn) || (currentEntry?.mode || 'major')));
    } catch (e) {
      console.error(e);
      svgHost.textContent = 'Render error: ' + (e?.message || e);
      setStatus('Render failed — see console', true);
    }
  }

  // ---------- Major/minor target sets per key-signature count ----------
  const MAJOR_BY_COUNT = {
    0: ['C'],
    1: ['G','F'],
    2: ['D','Bb'],
    3: ['A','Eb'],
    4: ['E','Ab'],
    5: ['B','Db'],
    6: ['F#','Gb'],
    7: ['C#','Cb']
  };
  const MINOR_BY_COUNT = {
    0: ['a'],
    1: ['e','d'],
    2: ['b','g'],
    3: ['f#','c'],
    4: ['c#','f'],
    5: ['g#','bb'],
    6: ['d#','eb'],
    7: ['a#','ab']
  };

  // ---------- Catalog indexing (from tunes.json) ----------
  let catalog = [];  // { path, text, dir, mode, diff, title }
  let currentKrn = '';
  let currentEntry = null;

  async function fetchList(){
    try {
      const r = await fetch('tunes.json?_=' + Date.now(), { cache:'no-cache' });
      if (!r.ok) return [];
      const arr = await r.json();
      const list = Array.isArray(arr) ? arr : (Array.isArray(arr.files) ? arr.files : []);
      return (list || []).map(x => String(x).replace(/^\/+/, ''));
    } catch(e){ return []; }
  }

  async function fetchText(path){
    const p = path.startsWith('tunes/') ? path : 'tunes/' + path;
    const r = await fetch(p + '?_=' + Date.now(), { cache:'no-cache' });
    if (!r.ok) throw new Error('fetch failed: ' + p);
    const t = await r.text();
    return { path: p, text: t };
  }

  async function buildCatalog(paths, concurrency=4){
    catalog = [];
    let i = 0;
    const results = [];
    async function worker(){
      while (i < paths.length){
        const idx = i++;
        const raw = paths[idx];
        if (!/\.(krn|hum|txt)$/i.test(raw)) continue;
        try {
          const { path, text } = await fetchText(raw);
          const meta = metaFromHeader(text);
          results.push({ path, dir: meta.dir, mode: meta.mode, diff: meta.diff, title: meta.title, text });
        } catch(e){
          // skip on error
        }
      }
    }
    const workers = Array.from({length:concurrency}, worker);
    await Promise.all(workers);
    catalog = results;
    totalCount.textContent = String(catalog.length);

    buildDifficultyButtons();
    updateMatchCount();
  }

  function buildDifficultyButtons(){
    diffRow.innerHTML = '';
    const uniq = Array.from(new Set(catalog.map(x => x.diff).filter(n => Number.isFinite(n)))).sort((a,b)=>a-b);
    (uniq.length ? uniq : [1,2,3,4,5]).forEach(n => addDiffBtn(n));
  }

  function addDiffBtn(n){
    const b = document.createElement('button');
    b.className = 'btn';
    b.dataset.filter = 'diff';
    b.dataset.value  = String(n);
    b.textContent = 'Lvl ' + n;
    diffRow.appendChild(b);
  }

  // ---------- Selected filters state ----------
  const selected = {
    dir: new Set(),   // 'ascending' | 'descending'
    mode: new Set(),  // 'major' | 'minor'
    diff: new Set()   // '1','2',...
  };

  function toggleBtn(btn){
    const group = btn?.dataset?.filter;
    const val   = btn?.dataset?.value;
    const set   = group ? selected[group] : undefined;
    if (!set || !val) return;

    if (set.has(val)) {
      set.delete(val);
      btn.classList.remove('selected');
    } else {
      set.add(val);
      btn.classList.add('selected');
    }
    updateMatchCount();
  }

  [dirRow, modeRow, diffRow].forEach(row => {
    row.addEventListener('click', (e) => {
      const btn = e.target.closest('button.btn');
      if (!btn || !row.contains(btn)) return;
      if (!btn.dataset.filter || !btn.dataset.value) return;
      toggleBtn(btn);
    });
  });

  function matchesFilters(item){
    if (selected.dir.size){
      if (!item.dir || !selected.dir.has(item.dir)) return false;
    }
    if (selected.mode.size){
      if (!item.mode || !selected.mode.has(item.mode)) return false;
    }
    if (selected.diff.size){
      const d = String(item.diff ?? '');
      if (!selected.diff.has(d)) return false;
    }
    return true;
  }

  function currentMatches(){ return catalog.filter(matchesFilters); }
  function updateMatchCount(){ matchCount.textContent = String(currentMatches().length); }

  clearBtn.addEventListener('click', () => {
    selected.dir.clear(); selected.mode.clear(); selected.diff.clear();
    document.querySelectorAll('.btn.selected').forEach(b => b.classList.remove('selected'));
    updateMatchCount();
  });

  // ---------- Key-range UI ----------
  const keyButtons = [];
  const selectedKeyCounts = new Set(); // integers 0..7

  function buildKeyRangeChips(){
    keyRangeRow.innerHTML = '';
    keyButtons.length = 0;
    selectedKeyCounts.clear();
    for (let n = 0; n <= 7; n++){
      const b = document.createElement('button');
      b.className = 'key-chip';
      b.dataset.count = String(n);
      b.textContent = `${n}#/${n}b`;
      keyRangeRow.appendChild(b);
      keyButtons.push(b);
      selectedKeyCounts.add(n);
    }
  }

  keyRangeRow.addEventListener('click', (e) => {
    const b = e.target.closest('.key-chip');
    if (!b || !keyRangeRow.contains(b)) return;
    const n = parseInt(b.dataset.count, 10);
    if (Number.isNaN(n)) return;
    if (selectedKeyCounts.has(n)){
      selectedKeyCounts.delete(n);
      b.classList.add('off');
    } else {
      selectedKeyCounts.add(n);
      b.classList.remove('off');
    }
  });

  keySelectAllBtn.addEventListener('click', () => {
    keyButtons.forEach(b => b.classList.remove('off'));
    selectedKeyCounts.clear();
    for (let n=0;n<=7;n++) selectedKeyCounts.add(n);
  });

  keySelectNoneBtn.addEventListener('click', () => {
    keyButtons.forEach(b => b.classList.add('off'));
    selectedKeyCounts.clear();
  });

  buildKeyRangeChips();

  // ---------- Random selection & render ----------
  function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }
  function pickRandomTonicForMode(mode){
    const counts = Array.from(selectedKeyCounts.values()).sort((a,b)=>a-b);
    if (!counts.length) return '';
    const count = pickRandom(counts);
    const pool = (mode === 'minor' ? MINOR_BY_COUNT[count] : MAJOR_BY_COUNT[count]) || [];
    return pool.length ? pickRandom(pool) : '';
  }

  randomBtn.addEventListener('click', async () => {
    const pool = currentMatches();
    if (!pool.length){
      setStatus('No matching files. Adjust filters or clear them.', true);
      return;
    }
    const pick = pool[Math.floor(Math.random() * pool.length)];

    // Prepare (GENERALIZED suppression after first *X:)
    const prepared = suppressThirdFourthSpinesAfterKey(pick.text);

    currentKrn = prepared;
    currentEntry = pick;

    const m = pick.mode || modeFromKern(currentKrn) || 'major';
    const tonic = pickRandomTonicForMode(m);

    // Title & key pills
    updatePillsFromCatalogEntry(pick);
    updateKeyPill(tonic || '', m);

    if (tonic && !hasKeyDesignationKRn(currentKrn) && !hasKeySigKRn(currentKrn)) {
      setStatus('File lacks *k[]/*X: — tonic-based transpose may be ignored', true);
    } else {
      setStatus(`Loaded: ${pick.path} — mode=${m}${tonic?`, target=${tonic}`:''}`);
    }
    renderWithTonic(tonic || '', m);
  });

  // ---------- Initial load + indexing ----------
  const paths = await fetchList();
  if (paths.length){
    setStatus('Indexing tunes.json…');
    await buildCatalog(paths, 4);
    setStatus('Index complete — choose filters & key range, then click “New Bass Line”.');
  } else {
    setStatus('No tunes.json found.');
  }

  // If nothing loaded yet, show a tiny sample
  if (!currentKrn) {
    const rawSample = `**kern\t**fb\t**text\t**text
!!\t\tactual acc.\tforce diatonic accidental
!! Dir\tAscending Minor
!! Title\tRule of the Octave
!! Number\t6
*clefF4\t*\t*\t*
*k[]\t*k[]\t*k[]\t*k[]
*a:\t*a:\t*a:\t*a:
=1\t=1\t=1\t=1
4AA\t5\t.\t.
.\t6\\ 5-\t6# 5-\t..
4BB\t6\t.\t.
4C\t6 5\t.\t.
4D\t8 #\t.\t.
.\t7 #\t.\t.
4E\t9\\\t9#\t.
.\t8\t.\t.
4F#\t7\t.\t.
.\t6\\\t6#\t.
4G#\t5-\t5n\t.
4A\t.\t.\t.
=|\t=|\t=|\t=|
*-\t*-\t*-\t*-
`;
    const meta = metaFromHeader(rawSample);
    currentEntry = { path: 'sample', text: rawSample, dir: meta.dir, mode: meta.mode, diff: meta.diff, title: meta.title };

    // Apply generalized suppression to sample, too
    currentKrn = suppressThirdFourthSpinesAfterKey(rawSample);

    updatePillsFromCatalogEntry(currentEntry);
    humPanel.textContent = currentKrn;
    renderWithTonic('', meta.mode || 'major');
  }
})();
</script>
</body>
</html>
