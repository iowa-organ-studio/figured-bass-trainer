


<!doctype html>
<html lang="en">
<head>
  <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"/>'>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CPE Bach Rule of the Octave Randomizer</title>
<script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js"></script>
<script src="https://www.verovio.org/javascript/latest/verovio-toolkit-hum.js"></script>
<style>
:root{

  /* Backgrounds — parchment grey with cool undertone */
  --bg: #f3f2ed;         /* cool aged parchment */
  --card: #ffffff;       /* clean, quiet neutral */
  --border: #d6d3cf;     /* silver parchment edge */

  /* Text & ink */
  --ink: #1b1b1f;        /* iron-gall / printing ink */
  --muted: #4b4d53;      /* cool faded ink */

  /* Silver & pewter tones */
  --silver: #d6d3cf;     /* light brocade silver */
  --pewter: #b7b4b0;     /* mid-tone pewter */

  /* Selected/toggled state — cool, readable, noticeable */
  --selected-bg:     #c4ccd9;  /* muted silver-blue highlight */
  --selected-border: #808899;  /* blue-grey outline */
  --selected-ink:    #1b1b1f;  /* ink-black text */

  /* Neutral grey for unselected chips */
  --grey: #e2e0da;    /* soft warm-grey for chip bases */

  /* Compatibility for old rules */
  --butter:   var(--selected-bg);
  --gold:     var(--selected-border);
  --gold-ink: var(--selected-ink);
}

html,body{height:100%}
body{
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
  margin:12px;background:var(--bg);color:var(--ink)
}
.card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px}
header{display:flex;align-items:center;gap:10px;flex-wrap:wrap}

.small{font-size:.9rem;color:var(--muted)}
.row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.spacer{flex:1}

/* ======= Title pills ======= */
.title-badges{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.title-pill{
  padding:6px 10px;border-radius:10px;background:#fff;border:1px solid var(--border);
  font-size:.92rem;font-weight:600;white-space:nowrap
}
#keyPill{ display:inline-block; }
.title-pill small{ color:var(--muted); font-weight:500; margin-left:6px}

/* Make header a flex row and vertically center items */
header {
  display: flex;
  align-items: center;
  gap: 8px;              /* optional spacing between items */
  padding: 8px 12px;     /* adjust to match your layout */
}

/* Right-align the studio credit pill in the header */
.studio-credit-pill {
  margin-left: auto;       /* pushes this pill to the far right in the header flex row */
  white-space: nowrap;     /* keep it on one line if possible */
  font-weight: 600;        /* same visual weight as the other pills */
  display: inline-flex;    /* keeps vertical centering consistent */
  align-items: center;
}

/* Push the studio credit to the far right */
.studio-credit {
  margin-left: auto;     /* the magic that forces it to the right */
  font-weight: 700;      /* keep your bold weight */
  white-space: nowrap;   /* prevent awkward wrapping on wide screens */
  font-size: 0.95rem;    /* tweak to taste */
}

/* Responsive: on narrow screens, wrap and make the credit full width and right aligned */
@media (max-width: 640px) {
  header {
    flex-wrap: wrap;      /* allow items to break to next line */
    gap: 6px;
  }
  .studio-credit {
    margin-left: 0;       /* remove auto so it no longer tries to occupy flex gap */
    order: 3;             /* put it after other header items (adjust if needed) */
    width: 100%;          /* full width line */
    text-align: right;    /* keep the text visually right-justified on its own line */
    padding-top: 6px;     /* tiny spacing from row above */
  }
}


/* ======= Buttons ======= */
.btn{
  padding:4px 8px;border-radius:999px;border:1px solid var(--grey);
  background:var(--grey);color:#222;cursor:pointer;font-size:.82rem;line-height:1
}
/* Selected / toggled states across the app (chips, radios, etc.) */
.btn.selected,
.level-btn.toggled,
.level-btn.selected,
.include-btn.toggled,
.radio-inline label.selected,
[data-role="show"] .level-btn.toggled {
  background: var(--selected-bg);
  border-color: var(--selected-border);
  color: var(--selected-ink);
}

/* Make the select all/none buttons black (not grey) */
#selectAllKeys, #selectNoneKeys, #includeSelectAll, #includeSelectNone { color: var(--ink); background: #fff; border-color: var(--border); font-weight:600; }

/* ======= Chips container line ======= */
.line{
  display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px
}
.group{
  display:flex;align-items:center;gap:8px;
  background:#fff;border:1px solid var(--border);border-radius:10px;padding:6px 8px
}
.group .small{font-size:.82rem;font-weight:700;color:#333}

/* ======= Row 1 ======= */
.new-bass-btn{
  padding:8px 14px;
  border-radius:999px;

  background: linear-gradient(
    to bottom,
    #2e3137,
    #1b1b1f
  ); /* charcoal → ink-black */
  color:#ffffff;

  border:1px solid #0f1012; 
  font-weight:600;
  cursor:pointer;

  box-shadow:
    0 1px 0 rgba(0,0,0,0.4),
    0 6px 12px rgba(0,0,0,0.25);

  transition:0.15s ease;
}

.new-bass-btn:hover{
  background: linear-gradient(to bottom, #353941, #1b1b1f);
  transform: translateY(-1px);
}

.new-bass-btn:active{
  background: linear-gradient(to bottom, #1b1b1f, #141417);
  transform: translateY(1px);
}

#keyPill .key-label {
  font-weight: 700;      /* bold label */
  margin-right: 4px;
}

#keyPill #keyPillValue {
  font-weight: 400;      /* normal-weight key name */
}

/* ======= Viewer ======= */
#viewer{ margin-top:8px; }

/* Tagline image under the viewer */
#modeTagline img.tagline-img {
  max-height: 66px;     /* adjust if you want larger/smaller */
  height: auto;
  display: block;
  margin: 2px 0 0 0;   /* left-justified (no auto-centering) */
}

/* Tighter vertical padding inside the music viewer card */
#viewer.card {
  padding-top: 6px;    /* was 10px via .card */
  padding-bottom: 6px; /* was 10px via .card */
}

/* Slightly smaller gap above the viewer card */
#viewer { margin-top: 4px; }  /* was 8px */

/* Verovio fit-to-viewer helpers */
#viewer {
  overflow-x: hidden;  /* avoid horizontal scroll bars */
  overflow-y: hidden;  /* avoid vertical scroll bars inside the viewer */
}
#svg { display: block; }
#svg svg {
  display: block;      /* measure width/height cleanly */
  width: auto;
  height: auto;
  margin: 0;
}

/* Keep historical text in DOM (for JS to touch) but invisible */
.visually-hidden {
  position: absolute !important;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(1px, 1px, 1px, 1px);
}
/* ======= Row 3: Key Range + Scale + Spacing (no outer big card) ======= */
.key-grid{
  display:flex;flex-wrap:nowrap;gap:6px;
}
.key-btn{
  background:var(--grey);border:1px solid var(--border);color:#222;
  padding:6px 8px;border-radius:10px;font-weight:500;cursor:pointer;
  min-width:36px;min-height:28px;box-shadow:0 1px 0 rgba(0,0,0,0.05) inset;
  font-size:.75rem;line-height:1.0
}
.key-btn.selected{background:var(--butter);border-color:var(--gold);color:var(--gold-ink)}
.small-pill{
  background:#fff;border:1px solid var(--border);padding:4px 7px;border-radius:8px;
  font-weight:600;font-size:.82rem;line-height:1
}
/* Hide the sliders visually (keep in DOM for existing JS) */
.slider{ display:none !important; }

/* ======= Row 4: Filters (no big outer card) ======= */
/* Hide labels “Dir:”, “Mode:”, “Lvl:” per request */
.group[data-role="dir"] .small,
.group[data-role="mode"] .small,
.group[data-role="level"] .small{ display:none }

/* Accidentals radios styled to look like chips, mutually exclusive by native radio */
.radio-inline{display:flex;align-items:center;gap:6px}
.radio-inline input[type="radio"]{position:absolute;opacity:0;width:0;height:0}
.radio-inline label{
  padding:4px 8px;border-radius:999px;border:1px solid var(--grey);
  background:var(--grey);color:#222;font-size:.82rem;line-height:1;cursor:pointer;
  display:inline-flex;align-items:center;gap:6px;
}
.radio-inline label.selected{
  background:var(--butter);border-color:var(--gold);color:var(--gold-ink)
}

/* NEW: Keep the FB placement card tidy and chip-highlight the selected label */
.group[data-role="fig-place"] { /* already top-aligned via inline; keep here for clarity */ }
#figPlaceInline label.selected {
  background: var(--butter);
  border-color: var(--gold);
  color: var(--gold-ink);
}
/* If you ever show native radios, this accent helps. Your radios are hidden, so optional. */
input[type="radio"] { accent-color: var(--gold); }

/* ======= Include spelled-tonics grid (replaces previous pc-grid) ======= */
.include-grid{display:flex;flex-wrap:wrap;gap:6px;max-width:720px}
.include-btn{
  padding:6px 8px;border-radius:8px;border:1px solid var(--border);
  background:#fff;color:var(--ink);cursor:pointer;font-size:.82rem;font-weight:600;
}
.include-btn.toggled{ background:var(--butter); border-color:var(--gold); color:var(--gold-ink) }

/* ======= Transpose/Octave/Enharmonic — keep in DOM, hide visually ======= */
.controls-row{ display:none !important; }

/* ======= Humdrum collapse helper ======= */
.humdrum-toggle {
  display:inline-flex;align-items:center;gap:8px;background:#fff;border:1px solid var(--border);
  color:#333;border-radius:10px;padding:6px 10px;font-size:.92rem;font-weight:600;cursor:pointer;margin-top:8px
}
.humdrum-toggle:hover{ background:#fdfdfd }
.humdrum-chevron{ font-weight:800;color:#555 }
.humdrum-original-label{ display:none !important }

/* ======= Logo ======= */
#logoAfterFilters img {
  max-width: 66%;
  height: auto;
  display: block;
  margin-left: auto;
  margin-right: auto;
}

/* Unified selected state for all chips/buttons */
.key-btn.selected,
.include-btn.toggled,
.btn.selected,
.level-btn.toggled,
.radio-inline label.selected,
[data-role="show"] .level-btn.toggled {
  background: var(--selected-bg) !important;
  border-color: var(--selected-border) !important;
  color: var(--selected-ink) !important;
}

/* Base state: soft silver-grey, not white */
.key-btn,
.include-btn,
.level-btn,
.btn,
.radio-inline label {
  background: var(--grey);
  border-color: var(--border);
  color: var(--ink);
}


</style>
</head>
<body>


  <!-- ===== Row 1: New Bass Line, Title, Key ===== -->
   <!-- ===== Row 1: New Bass Line, Title, Key ===== -->
  <header>
    <button id="randomFiltered" class="new-bass-btn" type="button">New Bass Line</button>

    <div class="title-badges" id="titlePills" aria-hidden="false" style="margin-left:6px">
      <div class="title-pill" id="titlePill">No title <small id="titleSub"></small></div>
      <div class="title-pill" id="keyPill">
  <span class="key-label">Current key:</span>
  <span id="keyPillValue"></span>
</div>
      <!-- NOTE: the studio credit was removed from here -->
    </div>

    <!-- Studio credit moved outside the title-badges so it can be pushed to the far right -->
    <div class="title-pill studio-credit-pill">
  Created for the University of Iowa Organ Studio
</div>
  </header>


  <!-- ===== Row 2: Music viewer ===== -->
  <div id="viewer" class="card" style="margin-top:8px">
  <div id="svg">Waiting for Verovio…</div>
  <div id="modeTagline" class="small" style="margin-top:8px">
    <img class="tagline-img" src="./emanuel.png" alt="C. P. E. Bach wordmark">
    <span id="historicalStatus" class="visually-hidden"></span>
  </div>
</div>

  <!-- ===== Row 3: Key Range + Scale + Spacing (NO big card) ===== -->
  <div class="line" id="row3">
    <!-- Key Range -->
    <div class="group" data-role="key-range">
      <div class="small">Key Range</div>
      <div class="key-grid" id="keyGrid">
        <button class="key-btn" data-count="0">0♯/0♭</button>
        <button class="key-btn" data-count="1">1♯/1♭</button>
        <button class="key-btn" data-count="2">2♯/2♭</button>
        <button class="key-btn" data-count="3">3♯/3♭</button>
        <button class="key-btn" data-count="4">4♯/4♭</button>
        <button class="key-btn" data-count="5">5♯/5♭</button>
        <button class="key-btn" data-count="6">6♯/6♭</button>
        <button class="key-btn" data-count="7">7♯/7♭</button>
      </div>
      <div style="display:flex;gap:6px;margin-left:6px">
        <button id="selectAllKeys" class="btn">all</button>
        <button id="selectNoneKeys" class="btn">none</button>
      </div>
    </div>

    <!-- Scale -->
    <div class="group" data-role="scale">
      <div class="small">Scale</div>
      <button class="small-pill" id="scaleReset">reset</button>
      <button class="btn" id="scaleMinus">−</button>
      <button class="btn" id="scalePlus">+</button>
      <div class="small-pill" id="scaleValue">50</div>
      <!-- Keep slider in DOM for JS; hidden with CSS -->
      <div class="slider" aria-hidden="true"><input id="scaleSlider" type="range" min="10" max="120" value="50"></div>
    </div>

    <!-- Spacing -->
    <div class="group" data-role="spacing">
      <div class="small">Spacing</div>
      <button class="small-pill" id="spacingReset">reset</button>
      <button class="btn" id="spacingMinus">−</button>
      <button class="btn" id="spacingPlus">+</button>
      <div class="small-pill" id="spacingValue">0.32</div>
      <!-- Keep slider in DOM for JS; hidden with CSS -->
      <div class="slider" aria-hidden="true"><input id="spacingSlider" type="range" min="10" max="120" value="32"></div>
    </div>
  </div>

  <!-- ===== (Hidden) Transpose/Octave UI kept for JS ======= -->
  <div class="controls-row" style="margin-top:8px">
    <div class="card">
      <div style="font-weight:700">Transpose</div>
      <div style="display:flex;gap:6px">
        <button class="tp-btn" id="tpMinus">−</button>
        <button class="tp-btn" id="tpPlus">+</button>
        <button class="tp-btn" id="tpToggle">♯/♭</button>
      </div>
      <div style="height:6px"></div>
      <div style="font-weight:700">Octave</div>
      <div style="display:flex;gap:6px">
        <button class="tp-btn" id="octMinus">−</button>
        <button class="tp-btn" id="octPlus">+</button>
      </div>
    </div>
  </div>

  <!-- ===== Row 4: Filters (NO big outer card) ===== -->
  <div class="line" id="row4">
    <div class="group" data-role="dir">
      <div class="small">Dir:</div>
      <div id="dirRow" style="display:flex;gap:6px">
        <button class="btn" data-filter="dir" data-value="ascending">Ascending</button>
        <button class="btn" data-filter="dir" data-value="descending">Descending</button>
      </div>
    </div>

    <div class="group" data-role="mode">
  <div class="small">Mode:</div>
  <div id="modeRow" style="display:flex;gap:6px">
    <button class="btn" data-filter="mode" data-value="major">Major</button>
    <button class="btn" data-filter="mode" data-value="minor">Minor</button>
    <!-- NEW -->
    <button class="btn" data-filter="mode" data-value="chromatic">Chromatic</button>
    <button class="btn" data-filter="mode" data-value="pedal">Pedal Point</button>
  </div>
</div>

    <div class="group" data-role="level">
      <div class="small">Lvl:</div>
      <div id="diffRow" style="display:flex;gap:6px">
        <button class="btn" data-filter="diff" data-value="1">1</button>
        <button class="btn" data-filter="diff" data-value="2">2</button>
        <button class="btn" data-filter="diff" data-value="3">3</button>
        <button class="btn" data-filter="diff" data-value="4">4</button>
        <button class="btn" data-filter="diff" data-value="5">5</button>
        <button class="btn" data-filter="diff" data-value="6">6</button>
        <button class="btn" data-filter="diff" data-value="7">7</button>
      </div>
    </div>

    <div class="group" data-role="accidentals">
      <div class="small" style="min-width:88px">Accidentals:</div>
      <div class="radio-inline" id="accRadioInline">
        <label id="labelHistoric"><input type="radio" name="accMode" value="historic" checked> Historic</label>
        <label id="labelModern"><input type="radio" name="accMode" value="modern"> Modern</label>
      </div>
    </div>

    <div class="group" data-role="matching">
      <div class="small">Matching: <span id="matchCount">0</span> / <span id="totalCount">0</span></div>
      <button id="clearFilters" class="btn">Clear filters</button>
    </div>

    <div class="spacer"></div>
  </div>

  <!-- ===== Row 5: Include spelled-tonics (NO big outer card) ===== -->
  <div class="line" id="row5">
    <div class="group" data-role="include">
      <div class="small" style="min-width:64px">Include</div>
      <div style="display:flex;gap:6px">
        <button id="includeSelectAll" class="btn" type="button">all</button>
        <button id="includeSelectNone" class="btn" type="button">none</button>
      </div>
      <div class="include-grid" id="includeGrid" aria-label="Spelled tonics to include (select to restrict)"></div>
    </div>
<!-- NEW: Figured-bass placement (own card to the right of Include) -->
    <div class="group" data-role="fig-place" style="align-self:flex-start; min-width:auto;">
      <div class="small">Figures</div>
      <div class="radio-inline" id="figPlaceInline">
        <label id="labelFigBelow"><input type="radio" name="figPlace" id="fbBelow" value="below" checked> below</label>
        <label id="labelFigAbove"><input type="radio" name="figPlace" id="fbAbove" value="above"> above</label>
      </div>
    </div>

  </div>

  <!-- ===== Humdrum panel ===== -->
  <label class="small" style="margin-top:8px;display:block">Displayed humdrum / .krn (absolute original shown below):</label>
  <div id="humPanel" class="card" style="margin-top:8px;white-space:pre-wrap;font-family:monospace">(no file loaded)</div>

  <!-- ===== Trace panel (kept for JS, hidden) ===== -->
  <!-- To re-show, remove display:none on this container -->
  <div class="card" style="margin-top:8px; display:none">
    <div class="row">
      <div class="small">Trace:</div>
      <label><input type="checkbox" id="traceToggle"> Trace ON</label>
      <button id="clearTrace" class="btn">Clear trace</button>
      <button id="downloadTrace" class="btn">Download trace</button>
      <div class="spacer"></div>
      <div class="small" id="status">Status: initializing…</div>
    </div>
    <label class="small" style="margin-top:6px;display:block">Trace output (copy &amp; paste here):</label>
    <div id="tracePanel" class="card" style="margin-top:6px;white-space:pre-wrap;font-family:monospace">(trace disabled)</div>
  </div>


<!-- Logo directly after filters -->
<div id="logoAfterFilters" aria-label="University of Iowa Organ Studio logo">
  <img src="Organ-Studio-LockupStacked-RGB.svg" alt="University of Iowa School of Music">
</div>

<script>
/* ========================================================================== 
   Full app (complete). Changes:
   - "tonics" removed.
   - Include grid (spelled-tonics) implemented in the Include area.
   - Include all/none buttons wired; default = all lit.
   - Historic/Modern radio labels show selected state.
   ========================================================================== */

(async function () {
// -------------------- CONSTANTS --------------------
const BASE_PITCH = { 'C':0,'D':2,'E':4,'F':5,'G':7,'A':9,'B':11 };
const ACC_OFF = { '--': -2, '-': -1, 'n': 0, '#': +1, '##': +2 };
const ACC_GLYPHS = ['--','-','n','#','##'];
const MAJOR_BY_COUNT = {0:['C'],1:['G','F'],2:['D','Bb'],3:['A','Eb'],4:['E','Ab'],5:['B','Db'],6:['F#','Gb'],7:['C#','Cb']};
const MINOR_BY_COUNT = {0:['a'],1:['e','d'],2:['b','g'],3:['f#','c'],4:['c#','f'],5:['g#','bb'],6:['d#','eb'],7:['a#','ab']};
const KEY_TOKEN_RE = /^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/

// -------------------- DOM refs --------------------
const svgHost = document.getElementById('svg');
const humPanel = document.getElementById('humPanel');
const status = document.getElementById('status');

const dirRow = document.getElementById('dirRow');
const modeRow = document.getElementById('modeRow');
const diffRow = document.getElementById('diffRow');
const matchCount = document.getElementById('matchCount');
const totalCount = document.getElementById('totalCount');

const randomBtn = document.getElementById('randomFiltered');
const clearBtn = document.getElementById('clearFilters');

const titlePill = document.getElementById('titlePill');
const keyPillValue= document.getElementById('keyPillValue');

const traceToggle = document.getElementById('traceToggle');
const tracePanel = document.getElementById('tracePanel');
const clearTraceBtn = document.getElementById('clearTrace');
const downloadTraceBtn = document.getElementById('downloadTrace');

const modeTagline = document.getElementById('modeTagline');
const historicalStatus = document.getElementById('historicalStatus');


// Accidentals (Historic/Modern)
const accRadios = Array.from(document.querySelectorAll('input[name="accMode"]'));
let ACC_MODE = 'historic'; // 'historic' | 'modern'

// NEW: Figured-bass placement state (false = below **fb, true = above **fba)
let FB_ABOVE = false;

// Key range state/UI
const keyButtons = Array.from(document.querySelectorAll('.key-btn'));
const selectAllKeysBtn = document.getElementById('selectAllKeys');
const selectNoneKeysBtn = document.getElementById('selectNoneKeys');
let enabledCounts = new Set([0,1,2,3,4,5,6,7]);

// Include spelled-tonics grid
const includeGridEl = document.getElementById('includeGrid');
const includeSelectAllBtn = document.getElementById('includeSelectAll');
const includeSelectNoneBtn = document.getElementById('includeSelectNone');
let allowedTonicBases = new Set(); // elements like "F#", "B-", "C" where flats use '-' glyph

// Scale / Spacing (UI-only)
const scaleSlider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');
const spacingSlider = document.getElementById('spacingSlider');
const spacingValue = document.getElementById('spacingValue');
const scaleReset = document.getElementById('scaleReset');
const spacingReset= document.getElementById('spacingReset');
const scaleMinus = document.getElementById('scaleMinus');
const scalePlus = document.getElementById('scalePlus');
const spacingMinus= document.getElementById('spacingMinus');
const spacingPlus = document.getElementById('spacingPlus');

// Transpose / Octave
const tpMinus = document.getElementById('tpMinus');
const tpPlus = document.getElementById('tpPlus');
const tpToggle= document.getElementById('tpToggle');
const octMinus= document.getElementById('octMinus');
const octPlus = document.getElementById('octPlus');
// --- HUMDRUM: default collapsed with chevron toggle (visual-only) ---
(function initHumdrumCollapsed() {
  const humPanelEl = document.getElementById('humPanel');
  if (!humPanelEl) return;

  // Hide the original label (keep in DOM)
  const humLabel = Array.from(document.querySelectorAll('label.small')).find(l =>
    /displayed humdrum|humdrum/i.test((l.textContent || '').trim())
  );
  if (humLabel) humLabel.classList.add('humdrum-original-label');

  // Create the new toggle
  const toggle = document.createElement('button');
  toggle.type = 'button';
  toggle.className = 'humdrum-toggle';
  toggle.setAttribute('aria-expanded', 'false');
  toggle.setAttribute('aria-controls', 'humPanel');

  const chev = document.createElement('span');
  chev.className = 'humdrum-chevron';
  chev.textContent = '►'; // closed

  const txt = document.createElement('span');
  txt.textContent = 'Humdrum panel -- click to open';

  toggle.appendChild(chev);
  toggle.appendChild(txt);

  // Insert above the panel and start collapsed
  humPanelEl.parentNode.insertBefore(toggle, humPanelEl);
  humPanelEl.style.display = 'none';

  toggle.addEventListener('click', () => {
    const isOpen = humPanelEl.style.display !== 'none';
    if (isOpen) {
      humPanelEl.style.display = 'none';
      toggle.setAttribute('aria-expanded', 'false');
      chev.textContent = '►';
      txt.textContent = 'Humdrum panel -- click to open';
    } else {
      humPanelEl.style.display = 'block';
      toggle.setAttribute('aria-expanded', 'true');
      chev.textContent = '▼';
      txt.textContent = 'Humdrum panel -- click to close';
    }
  });
})();

// -------------------- Filter state (internal) --------------------
const selected = { dir: new Set(), mode: new Set(), diff: new Set() };

// make sure catalog exists before any UI code calls currentMatches()
let catalog = [];

// --- DEFAULT SELECTED: Direction, Mode, Level buttons (visual only) ---
(function initDefaultFilterSelections(){
  // Direction
  document.querySelectorAll('#dirRow .btn').forEach(btn => {
    btn.classList.add('selected');
  });

  // Mode — default ON for Major/Minor; OFF for Chromatic/Pedal
document.querySelectorAll('#modeRow .btn').forEach(btn => {
  const v = btn.dataset.value;
  const on = (v === 'major' || v === 'minor');
  if (on) btn.classList.add('selected'); else btn.classList.remove('selected');
});

// Mode
Array.from(document.querySelectorAll('#modeRow .btn')).forEach(b => {
  const v = b.dataset.value;
  if (v) selected.mode.add(v);
});

  // Level 1–7
  document.querySelectorAll('#diffRow .btn').forEach(btn => {
    btn.classList.add('selected');
  });

  // Initialize the internal selected sets to match the visual defaults:
  // Dir
  Array.from(document.querySelectorAll('#dirRow .btn')).forEach(b => {
    const v = b.dataset.value;
    if (v) selected.dir.add(v);
  });
  // Mode
  Array.from(document.querySelectorAll('#modeRow .btn')).forEach(b => {
    const v = b.dataset.value;
    if (v) selected.mode.add(v);
  });
  // Diff
  Array.from(document.querySelectorAll('#diffRow .btn')).forEach(b => {
    const v = b.dataset.value;
    if (v) selected.diff.add(v);
  });

  // Update counts initially
  updateMatchCount();
})();

// -------------------- Utils --------------------
function setStatus(txt, isErr){
  if (status) {
    status.textContent = 'Status: ' + txt;
    status.style.color = isErr ? 'crimson' : '';
  }
}
function escapeHtml(str){
  return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}
function nextLetter(letter){
  return 'CDEFGAB'[('CDEFGAB'.indexOf(letter.toUpperCase()) + 1) % 7];
}
function letterStepsUp(fromLetter, steps){ // steps >= 0
  const order = 'CDEFGAB';
  const i = order.indexOf(fromLetter.toUpperCase());
  return order[(i + (steps % 7) + 7) % 7];
}

// Normalize tonic to Humdrum glyphs ('-', '--', '#', '##', 'n')
function normalizeTonicForHumdrum(s) {
  if (!s) return s;
  const raw = String(s).trim();
  const m = raw.match(/^([A-Ga-g])([#\u266f-]{0,2})?$/);
  if (!m) return raw;
  const letter = m[1];
  let acc = m[2] || '';
  acc = acc
    .replace(/\u266f/g, '#')
    .replace(/\u266d/g, '-')
    .replace(/bb/g, '--')
    .replace(/b/g, '-');
  return letter + acc;
}

// Parse tonic string "A", "Ab", "C#", returns {letter, acc, mode}
function parseTonicString(s){
  if (!s) return null;
  const m = String(s).trim().match(/^([A-Ga-g])([#\u266f-]{0,2})$/);
  if (!m) return null;
  let letter = m[1].toUpperCase();
  let acc = (m[2] || '') || 'n';
  acc = acc.replace(/\u266f/g, '#');
  if (acc === '') acc = 'n';
  return { letter, acc, mode: (m[1] === m[1].toLowerCase() ? 'minor' : 'major') };
}

function spelledToSemitone(letter, glyph){
  const base = BASE_PITCH[letter.toUpperCase()];
  const off = (ACC_OFF[glyph] !== undefined) ? ACC_OFF[glyph] : 0;
  return ((base + off) % 12 + 12) % 12;
}
function semitoneToAccidentalForLetter(letter, targetSemitone){
  for (const g of ACC_GLYPHS){
    const v = ((BASE_PITCH[letter.toUpperCase()] + ACC_OFF[g])%12+12)%12;
    if (v === ((targetSemitone%12)+12)%12) return g;
  }
  return null;
}

// Build key signature scale (letters fixed, accidentals from signature)
function buildScale(tonicStr, mode){
  const parsed = parseTonicString(tonicStr);
  if (!parsed) throw new Error('Bad tonic: ' + tonicStr);
  const pattern = (mode === 'minor') ? [2,1,2,2,1,2,2] : [2,2,1,2,2,2,1];
  const tonicSem = spelledToSemitone(parsed.letter, parsed.acc);
  let letters = [];
  let L = parsed.letter;
  for (let i=0;i<7;i++){
    letters.push(L);
    L = nextLetter(L);
  }
  const sems = [tonicSem];
  for (let i=0;i<6;i++) sems.push((sems[sems.length-1] + pattern[i])%12);
  const scale = [];
  for (let i=0;i<7;i++){
    const letter = letters[i];
    const sem = (sems[i]+12)%12;
    const acc = semitoneToAccidentalForLetter(letter, sem);
    if (!acc) throw new Error(`Cannot spell degree ${i+1} (${letter}) in key ${tonicStr}`);
    scale.push({ letter, acc, semitone: sem });
  }
  return scale;
}

// --------- compute spelled interval from original key to target key ----------
const PERFECT_CLASSES = new Set([1,4,5]);
const MAJOR_BASE = {2:2,3:4,6:9,7:11}; // semitones for Major intervals
const PERFECT_BASE = {1:0,4:5,5:7};

function diatonicDistanceNum(fromLetter, toLetter){
  const order = 'CDEFGAB';
  const a = order.indexOf(fromLetter.toUpperCase());
  const b = order.indexOf(toLetter.toUpperCase());
  const steps = (b - a + 7) % 7; // 0..6
  return steps + 1; // 1..7
}

function computeKeyToKeyInterval(origTonicStr, targetTonicStr){
  const o = parseTonicString(normalizeTonicForHumdrum(origTonicStr));
  const t = parseTonicString(normalizeTonicForHumdrum(targetTonicStr));
  if (!o || !t) throw new Error('Bad tonic(s) for interval');

  const num = diatonicDistanceNum(o.letter, t.letter); // 1..7 upward within octave
  const oSem = spelledToSemitone(o.letter, o.acc);
  const tSem = spelledToSemitone(t.letter, t.acc);
  let semDelta = ((tSem - oSem) % 12 + 12) % 12; // 0..11 (upward class)

  let base = PERFECT_CLASSES.has(num) ? PERFECT_BASE[num] : MAJOR_BASE[num]; // P or M baseline
  // Convert to -2..+2 difference
  let diff = semDelta - base;
  if (diff > 6) diff -= 12; // normalize

  let quality = 'P';
  if (PERFECT_CLASSES.has(num)){
    if (diff === 0) quality = 'P';
    else if (diff === +1) quality = 'A';
    else if (diff === -1) quality = 'd';
    else if (diff === +2) quality = 'AA';
    else if (diff === -2) quality = 'dd';
    else throw new Error(`Unsupported quality for perfect class: diff=${diff}`);
  } else {
    if (diff === 0) quality = 'M';
    else if (diff === -1) quality = 'm';
    else if (diff === +1) quality = 'A';
    else if (diff === -2) quality = 'd';
    else if (diff === +2) quality = 'AA';
    else if (diff === -3) quality = 'dd';
    else throw new Error(`Unsupported quality for major/minor class: diff=${diff}`);
  }
  const totalSemitones = base + diff;
  return { number: num, quality, semitones: ((totalSemitones % 12) + 12) % 12 };
}

// transpose ANY spelled pitch by a spelled interval (letter-preserving) ----------
function transposeSpelledPitchByInterval(originalLetter, originalAcc, interval){
  // Step 1: letter motion
  const targetLetter = letterStepsUp(originalLetter, interval.number - 1);

  // Step 2: target semitone = original semitone + interval.semitones
  const origSem = spelledToSemitone(originalLetter, originalAcc);
  const targSem = ((origSem + interval.semitones) % 12 + 12) % 12;

  // Step 3: choose the accidental for the *fixed target letter* that matches targSem
  const acc = semitoneToAccidentalForLetter(targetLetter, targSem);
  if (!acc) return null; // cannot express with --,-,n,#,##

  return { letter: targetLetter, acc, semitone: targSem };
}

// Diatonic spelling for a numeral above (works for chromatic bass) -------------
function diatonicSpelling(tonicStr, mode, bassSpelled, numeral){
  // Compute the diatonic *letter* N above bass
  let letter = bassSpelled.letter;
  for (let i=1;i<=numeral-1;i++) letter = nextLetter(letter);

  // Key signature defines the accidental for that letter (baseline diatonic)
  const scale = buildScale(tonicStr, mode);
  const entry = scale.find(s => s.letter === letter);
  if (entry) return { letter: entry.letter, acc: entry.acc, semitone: entry.semitone };

  // Fallback (rare): derive semitone by key pattern
  const pattern = (mode === 'minor') ? [2,1,2,2,1,2,2] : [2,2,1,2,2,2,1];
  const bassSem = spelledToSemitone(bassSpelled.letter, bassSpelled.acc);
  let sum = 0;
  for (let i=0;i<numeral-1;i++) sum += pattern[i%7];
  const expSem = ((bassSem + sum)%12+12)%12;
  const g = semitoneToAccidentalForLetter(letter, expSem);
  if (g) return { letter, acc: g, semitone: spelledToSemitone(letter, g) };
  throw new Error(`Unable to diatonically spell numeral ${numeral} above ${bassSpelled.letter}${bassSpelled.acc} in ${tonicStr}`);
}

// Verovio toolkit
let vrv;
// Tighter defaults similar to Boyvin
const baseOptions = {
  scale: 50,

  // pageWidth will be overwritten by the fit-to-viewer loop each render
  pageWidth: 900,

  adjustPageHeight: true,

  // Reduce the internal page margins to shrink SVG whitespace
  pageMarginTop: 8,       // default is larger
  pageMarginBottom: 10,
  pageMarginLeft: 12,
  pageMarginRight: 12,

  // Slightly tighter system and staff spacing
  spacingSystem: 9,
  spacingStaff: 8,

  // Your existing spacing values
  spacingLinear: 0.32,
  spacingNonLinear: 0.46
};

// -------------------- Verovio init --------------------
async function waitForVerovioGlobal(timeout = 10000) {
  return new Promise((resolve, reject) => {
    const start = performance.now();
    (function poll() {
      if (window.verovio && (window.verovio.toolkit || window.verovio.module)) return resolve();
      if (performance.now() - start > timeout) return reject(new Error('verovio global not available'));
      setTimeout(poll, 40);
    })();
  });
}
async function createToolkitRobust() {
  if (typeof window.verovio === 'undefined') throw new Error('verovio not loaded');
  if (typeof window.verovio.toolkit === 'function') {
    try { return new verovio.toolkit(); } catch(e){}
  }
  const mod = window.verovio && window.verovio.module;
  if (mod && typeof mod.onRuntimeInitialized === 'function') {
    return new Promise((resolve, reject) => {
      const old = mod.onRuntimeInitialized;
      mod.onRuntimeInitialized = function() {
        try {
          const tk = new verovio.toolkit();
          resolve(tk);
        } catch (err) {
          reject(err);
        }
        if (typeof old === 'function') try { old(); } catch(e){}
      };
      if (mod._initialized) {
        try { const tk = new verovio.toolkit(); resolve(tk); } catch (err) { reject(err); }
      }
    });
  }
  await new Promise(r => setTimeout(r, 300));
  if (typeof window.verovio.toolkit === 'function') return new verovio.toolkit();
  throw new Error('Unable to initialize verovio toolkit');
}

try {
  setStatus('waiting for verovio global...');
  await waitForVerovioGlobal();
} catch (e) {
  setStatus('Verovio not found: ' + e.message, true);
  svgHost.textContent = 'Verovio not available';
}
try {
  setStatus('creating verovio toolkit...');
  vrv = await createToolkitRobust();
  if (vrv) vrv.setOptions(baseOptions);
} catch (e) {
  setStatus('Failed to create toolkit: ' + (e.message || e), true);
  svgHost.textContent = 'Toolkit init failed — see console';
}
setStatus('toolkit ready');

// -------------------- Trace --------------------
let TRACE_ON = false;
let traceBuf = [];
function renderTrace(){
  tracePanel.textContent = TRACE_ON ? traceBuf.join('\n') : '(trace disabled)';
}
function traceClear(){ traceBuf = []; renderTrace(); }
function traceLog(msg){
  if (!TRACE_ON) return;
  traceBuf.push(`[${new Date().toISOString()}] ${msg}`);
  if (traceBuf.length > 3000) traceBuf.shift();
  renderTrace();
}
function traceDownload(){
  const blob = new Blob([traceBuf.join('\n')], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'krn-transpose-trace.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
if (traceToggle) traceToggle.addEventListener('change', (e)=>{
  TRACE_ON = e.target.checked;
  renderTrace();
});
if (clearTraceBtn) clearTraceBtn.addEventListener('click', traceClear);
if (downloadTraceBtn) downloadTraceBtn.addEventListener('click', traceDownload);

// -------------------- Courtesy / suppression / modern override --------------------
function suppressThirdFourthSpinesAfterKey(krnText){
  const lines = krnText.split(/\r?\n/);
  let suppress = false;
  return lines.map(line => {
    if (!line.includes('\t')) {
      if (!suppress && KEY_TOKEN_RE.test(line.trim())) suppress = true;
      return line;
    }
    const fields = line.split('\t');
    if (!suppress) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        suppress = true;
        return line;
      }
      return line;
    }
    for (let i = 2; i <= 3 && i < fields.length; i++){
      const tok = (fields[i]||'').trim();
      if (tok !== '*-') fields[i] = '.';
    }
    return fields.join('\t');
  }).join('\n');
}

function applyModernOverride(krnText){
  const lines = krnText.split(/\r?\n/);
  let afterKey = false;
  return lines.map(line => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      return line;
    }
    const fields = line.split('\t');
    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        return line;
      }
      return line;
    }
    if (fields.length >= 3) {
      const s3 = (fields[2] ?? '').trim();
      if (s3 && s3 !== '.' && !s3.startsWith('*') && !s3.startsWith('=') && s3 !== '*-') {
        fields[1] = s3; // spine-3 → spine-2
      }
    }
    return fields.join('\t');
  }).join('\n');
}

// Courtesy from spine-4 (q / Nq) + conflict detection
function applyCourtesyFromSpine4(krnText){
  const lines = krnText.split(/\r?\n/);
  const out = [];
  let afterKey = false;
  let lastBass = null;
  const conflicts = [];
  const firstKeyMatch = krnText.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origKey = firstKeyMatch ? (firstKeyMatch[1] + (firstKeyMatch[2]||'')) : null;
  const origMode = firstKeyMatch ? (firstKeyMatch[1] === firstKeyMatch[1].toUpperCase() ? 'major':'minor') : 'major';
  lines.forEach((line, idx) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      out.push(line);
      return;
    }
    const fields = line.split('\t');
    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        out.push(line);
        return;
      }
      out.push(line);
      return;
    }
    // Track bass (spine-1)
    const f0 = (fields[0]||'').trim();
    const isData = (tok) => tok && tok !== '.' && !tok.startsWith('*') && !tok.startsWith('=');
    if (isData(f0)) {
      const m = f0.match(/([A-Ga-g])([#\u266f-]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }
    if (fields.length >= 4 && origKey && lastBass) {
      const s3 = (fields[2] ?? '').trim();
      const s4 = (fields[3] ?? '').trim();
      const s3Has = isData(s3);
      const s4Has = isData(s4);
      if (s3Has && s4Has) {
        conflicts.push({ line: idx+1, s3, s4 });
        out.push(fields.join('\t'));
        return;
      }
      if (s4Has) {
        const tokens = s4.split(/\s+/);
        const mapped = tokens.map(tok => {
          if (tok === 'q') {
            const dia = diatonicSpelling(origKey, origMode, lastBass, 3);
            return dia.acc; // accidental for diatonic third
          }
          const mq = tok.match(/^(\d+)q$/);
          if (mq) {
            const N = parseInt(mq[1], 10);
            const dia = diatonicSpelling(origKey, origMode, lastBass, N);
            return String(N) + dia.acc;
          }
          return tok;
        });
        fields[1] = mapped.join(' ');
      }
    }
    out.push(fields.join('\t'));
  });
  return { text: out.join('\n'), conflicts };
}

// ------------- Resolve qInSpine2 -------------
function resolveQInSpine2(krnText, targetTonic, targetMode){
  if (!targetTonic) return krnText;

  const lines = krnText.split(/\r?\n/);
  const out = [];
  let afterKey = false;
  let lastBass = null;



  // Original key
  const firstKeyMatch = krnText.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origKey = firstKeyMatch
    ? normalizeTonicForHumdrum(firstKeyMatch[1] + (firstKeyMatch[2]||''))
    : null;

  // Spelled key→key interval (no semitone-delta guessing)
  let spelledInterval = null;
  try {
    if (origKey && targetTonic) {
      spelledInterval = computeKeyToKeyInterval(origKey, targetTonic);
    }
  } catch(e){
    spelledInterval = null;
  }

  const isData = (tok) => tok && tok !== '.' && !tok.startsWith('*') && !tok.startsWith('=') && tok !== '*-';

  lines.forEach((line) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      out.push(line);
      return;
    }
    const fields = line.split('\t');

    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        out.push(line);
        return;
      }
      out.push(line);
      return;
    }

    // Track last bass (original spelled bass on this row)
    const f0 = (fields[0]||'').trim();
    if (isData(f0)) {
      const stripped = String(f0).replace(/^[0-9]+[\.]*/,'').replace(/[^A-Ga-g#\u266f\-b]*$/,'');
      const m = stripped.match(/([A-Ga-g])([#\u266f\-b]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'').replace(/bb/g,'--').replace(/b/g,'-').replace(/\u266f/g,'#') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }

    // Resolve q / Nq in spine-2 using *transposed spelled bass*
    if (fields.length >= 2) {
      const s2 = (fields[1]||'').trim();
      if (isData(s2)) {
        const tokens = s2.split(/\s+/);
        const mapped = tokens.map(tok => {
          if (tok === 'q' || /^(\d+)q$/.test(tok)) {
            if (!lastBass || !spelledInterval) return tok;
            const newBass = transposeSpelledPitchByInterval(lastBass.letter, lastBass.acc, spelledInterval);
            if (!newBass) return tok;
            const N = (tok === 'q') ? 3 : parseInt(tok.match(/^(\d+)q$/)[1], 10);
            const dia = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic).trim()), targetMode, newBass, N);
            return (tok === 'q') ? (dia.acc || 'n') : (String(N) + (dia.acc || 'n'));
          }
          return tok;
        });
        fields[1] = mapped.join(' ');
      }
    }

    out.push(fields.join('\t'));
  });

  return out.join('\n');
}

// -------------------- Figured-bass placement transformer --------------------
// Switch **fb <-> **fba in header and manage 'x' padding for alignment when above.
function applyFiguredBassPlacement(krnText, placeAbove) {
  if (!krnText) return krnText;
  const lines = krnText.split(/\r?\n/);
  let headerLineIdx = -1;
  let fbIndex = -1;

  // 1) Find the first header line containing **spines and locate the **fb/**fba spine index
  for (let i = 0; i < lines.length; i++) {
    const s = lines[i];
    if (!/\*\*/.test(s)) continue; // not a spine header
    const toks = s.split('\t');
    for (let c = 0; c < toks.length; c++) {
      if (/^\*\*fb(?:a)?\b/.test(toks[c])) {
        fbIndex = c;
      }
    }
    headerLineIdx = i;
    break;
  }
  if (headerLineIdx < 0 || fbIndex < 0) return krnText; // no **fb/**fba spine found

  // 2) Rewrite header token: **fb -> **fba for above, and reverse for below
  {
    const toks = lines[headerLineIdx].split('\t');
    toks[fbIndex] = placeAbove
      ? toks[fbIndex].replace(/^\*\*fb(?:a)?/, '**fba')
      : toks[fbIndex].replace(/^\*\*fba/, '**fb');
    lines[headerLineIdx] = toks.join('\t');
  }

  // 3) Compute global max number of numerals across the fb spine (for top-alignment)
  function countNumerals(tok) {
    if (!tok || tok === '.' || /^[\*\=\!\|]/.test(tok)) return 0;
    const parts = tok.trim().split(/\s+/);
    let numerals = 0;
    for (const p of parts) {
      const m = p.match(/\d+/g);
      numerals += m ? m.length : (/\d/.test(p) ? 1 : 0);
    }
    return numerals || (parts.some(p => /\d/.test(p)) ? 1 : 0);
  }
  let globalMax = 0;
  for (let i = headerLineIdx + 1; i < lines.length; i++) {
    const s = lines[i];
    if (!s.includes('\t')) continue;
    const toks = s.split('\t');
    const tok = toks[fbIndex];
    if (!tok || tok === '.' || /^[\*\=\!\|]/.test(tok)) continue;
    globalMax = Math.max(globalMax, countNumerals(tok));
  }

  // 4) Transform data rows: when placing above, apply leading 'x' padding; below strips them
  for (let i = headerLineIdx + 1; i < lines.length; i++) {
    const s = lines[i];
    if (!s.includes('\t')) continue;
    const toks = s.split('\t');
    let tok = toks[fbIndex] || '';
    if (!tok || tok === '.' || /^[\*\=\!\|]/.test(tok)) { lines[i] = toks.join('\t'); continue; }

    const parts = tok.trim().split(/\s+/);
    // Normalize any preexisting padding by removing leading x
    while (parts[0] === 'x') parts.shift();

    if (placeAbove) {
      const numeralsHere = countNumerals(parts.join(' ')) || 1;
      const need = Math.max(0, globalMax - Math.max(1, numeralsHere));
      tok = (need > 0 ? ('x '.repeat(need)) : '') + parts.join(' ');
      toks[fbIndex] = tok.trim();
    } else {
      // below: no padding
      toks[fbIndex] = parts.join(' ');
    }
    lines[i] = toks.join('\t');
  }

  return lines.join('\n');
}

// -------------------- Figure-aware transform (spines 1 & 2) --------------------
function transformFiguresForTonicWithTrace(originalKrn, targetTonic, targetMode){
  traceLog(`TRANSPOSE START => targetTonic=${targetTonic} targetMode=${targetMode}`);

  const origKeyMatch = originalKrn.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origTonicStr = origKeyMatch
    ? normalizeTonicForHumdrum(origKeyMatch[1] + (origKeyMatch[2]||'')) 
    : null;

  if (!origTonicStr) {
    traceLog('ERROR: original key token not found; abort');
    return originalKrn;
  }

  const origParsed = parseTonicString(origTonicStr);
  const targetParsed = parseTonicString(normalizeTonicForHumdrum(String(targetTonic || '').trim()));

  if (!origParsed || !targetParsed) {
    traceLog('ERROR: parse tonic failed');
    return originalKrn;
  }

  // Spelled interval between keys (letter-preserving)
  let spelledInterval = null;
  try {
    spelledInterval = computeKeyToKeyInterval(origTonicStr, targetTonic);
  } catch (e) {
    traceLog('ERROR: key->key interval failed: ' + e.message);
    return originalKrn;
  }

  const lines = originalKrn.split(/\r?\n/);
  let afterKey = false;
  let lastBass = null; // original spelled bass
  const outLines = [];

  lines.forEach((line, lineno) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      outLines.push(line);
      return;
    }
    const fields = line.split('\t');

    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        outLines.push(line);
        return;
      }
      outLines.push(line);
      return;
    }

    // Bass from spine-1 (original spelled bass)
    const f0 = (fields[0]||'').trim();
    if (f0 && f0 !== '.' && !f0.startsWith('*') && !f0.startsWith('=')) {
      const m = f0.match(/([A-Ga-g])([#\u266f-]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }

    // Target spelled bass via *spelled* interval (always try to compute)
    let newBassSpelled = null;
    if (lastBass && spelledInterval) {
      newBassSpelled = transposeSpelledPitchByInterval(lastBass.letter, lastBass.acc, spelledInterval);
      if (!newBassSpelled) {
        traceLog(`ERROR: cannot spell new bass for ${lastBass.letter}${lastBass.acc} by interval ${spelledInterval.number}${spelledInterval.quality}; leaving row unchanged`);
      }
    }

    // Process spine-2 only
    if (fields.length >= 2) {
      const originalCell = fields[1] || '';
      const tokens = originalCell.trim() === '' ? [] : originalCell.trim().split(/\s+/);

      const newTokens = tokens.map(tok => {
        // Keep-as-is tokens: \d+#\|, numeral ending with / or \, and literal "5-" only in historic mode
        if (/^\d+#\|$/.test(tok) || /^\d+[\/\\]$/.test(tok) || (ACC_MODE === 'historic' && /^5-$/.test(tok))) {
          return tok;
        }

        // Accidental-only (standalone) — refers to diatonic third
        if (/^(--|##|#|-|n)$/.test(tok)) {
          const numeral = 3;
          if (!lastBass || !newBassSpelled) {
            traceLog(`WARN: standalone accidental ${tok} but bass unknown or cannot spell new bass; leaving token as-is`);
            return tok;
          }
          try {
            const origDiat = diatonicSpelling(origTonicStr, origParsed.mode, lastBass, numeral);
            const origDiatSem = spelledToSemitone(origDiat.letter, origDiat.acc);
            const producedSem = spelledToSemitone(origDiat.letter, tok);

            // STASIS: produced equals diatonic
            if (producedSem === origDiatSem) {
              const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
              return tgtDiat.acc;
            }

            let dirRaw = (producedSem - origDiatSem + 12) % 12;
            let dir;
            if (dirRaw === 0) dir = 0;
            else if (dirRaw === 1) dir = +1;
            else if (dirRaw === 11) dir = -1;
            else dir = (dirRaw <= 6) ? dirRaw : dirRaw - 12;
            if (Math.abs(dir) > 2) {
              traceLog(`ERROR: standalone accidental ${tok} produced dir=${dir} outside allowed range; leaving token unchanged`);
              return tok;
            }

            const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
            const finalSem = ((tgtDiat.semitone + dir)%12+12)%12;
            const finalAcc = semitoneToAccidentalForLetter(tgtDiat.letter, finalSem);
            if (!finalAcc) {
              traceLog(`ERROR: cannot safely spell altered diatonic ${numeral} above ${newBassSpelled.letter}${newBassSpelled.acc} in ${targetTonic}; leaving token ${tok} unchanged`);
              return tok;
            }
            return finalAcc;
          } catch (e) {
            traceLog(`ERROR (standalone accidental): ${e.message}; leaving ${tok} unchanged`);
            return tok;
          }
        }

        // Numeral with optional accidental
        const m2 = tok.match(/^(\d+)(--|##|#|-|n)?$/);
        if (!m2) return tok;

        const numeral = parseInt(m2[1], 10);
        const accPart = m2[2] || '';

        if (!lastBass || !newBassSpelled) {
          traceLog(`WARN: numeral ${tok} but no bass/new-bass-known; leaving token as-is`);
          return tok;
        }
        if (!accPart) return tok; // unaltered, port as-is

        try {
          const origDiat = diatonicSpelling(origTonicStr, origParsed.mode, lastBass, numeral);
          const origDiatSem = spelledToSemitone(origDiat.letter, origDiat.acc);
          const producedSem = spelledToSemitone(origDiat.letter, accPart);

          // STASIS
          if (producedSem === origDiatSem) {
            const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
            return String(numeral) + tgtDiat.acc;
          }

          let dirRaw = (producedSem - origDiatSem + 12) % 12;
          let dir;
          if (dirRaw === 0) dir = 0;
          else if (dirRaw === 1) dir = +1;
          else if (dirRaw === 11) dir = -1;
          else dir = (dirRaw <= 6) ? dirRaw : dirRaw - 12;

          if (dir === 0) return tok;
          if (Math.abs(dir) > 2) {
            traceLog(`ERROR: alteration for ${tok} yields dir=${dir} outside allowed range; leaving token unchanged`);
            return tok;
          }

          const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
          const finalSem = ((tgtDiat.semitone + dir)%12+12)%12;
          const finalAcc = semitoneToAccidentalForLetter(tgtDiat.letter, finalSem);
          if (!finalAcc) {
            traceLog(`ERROR: cannot safely spell transformed numeral ${numeral} above ${tgtDiat.letter} in ${targetTonic}; leaving ${tok} unchanged`);
            return tok;
          }
          return String(numeral) + finalAcc;
        } catch (e) {
          traceLog(`ERROR (numeral transform): ${e.message}; leaving ${tok} unchanged`);
          return tok;
        }
      });

      fields[1] = newTokens.join(' ');
    }

    // Suppress spines 3 & 4
    for (let i = 2; i <= 3 && i < fields.length; i++){
      const tok = (fields[i]||'').trim();
      if (tok !== '*-') fields[i] = '.';
    }

    outLines.push(fields.join('\t'));
  });

  traceLog('TRANSPOSE END');
  return outLines.join('\n');
}

// -------------------- Catalog / filters / UI --------------------
function capitalize(s){ return String(s || '').replace(/^\w/, c => c.toUpperCase()); }
function updatePillsFromCatalogEntry(entry){
  function uc(s){ return String(s||'').replace(/^\w/, c => c.toUpperCase()); }
  const dirWord = entry?.dir ? uc(entry.dir) : '';
  const modeWord = entry?.mode ? uc(entry.mode) : '';
  const lvl = entry?.diff != null ? String(entry.diff) : '';
  const leftParts = [dirWord, modeWord].filter(Boolean).join(' ').trim();
  const core = 'Rule of the Octave';
  let pieces = [];
  if (leftParts) pieces.push(leftParts);
  pieces.push(core);
  if (lvl) pieces.push(lvl);
  const finalText = pieces.join(' ');
  titlePill.innerHTML = escapeHtml(finalText || 'No title');
}
function formatKeyName(tonic, mode){
  if (!tonic) return 'original';
  const m = String(tonic).trim().match(/^([A-Ga-g])(.+)?$/);
  if (!m) return tonic + ' ' + (mode === 'minor' ? 'minor' : 'major');
  let letter = m[1], acc = m[2] || '';
  acc = acc.replace(/bb/g, '♭♭').replace(/b/g, '♭').replace(/#/g, '♯').replace(/--/g,'♭♭').replace(/-/g,'♭');
  const root = (mode === 'minor') ? letter.toLowerCase() : letter.toUpperCase();
  return root + acc + ' ' + (mode === 'minor' ? 'minor' : 'major');
}
function updateKeyPill(tonic, mode){
  keyPillValue.textContent = formatKeyName(tonic, mode);
  if (!tonic) document.getElementById('keyPill').style.display = 'none';
  else document.getElementById('keyPill').style.display = '';
}

let currentKrn = '';
let currentEntry = null;
let lastTargetTonic = '';
let lastTargetMode = '';
let lastOriginalKey = '';
let lastOriginalMode = '';
let lastRenderTranspose = ''; // what was sent to verovio transpose (tonic or numeric)
let transposePreferFlats = false;
let currentRenderSemitoneShift = 0;

// NEW: Keep a copy of the transposed text BEFORE placement (so radios can re-apply quickly)
let lastTransformedKrn = '';

// -------------------- Fetch helpers --------------------
async function fetchList(){
  try {
    const r = await fetch('tunes.json?_=' + Date.now(), { cache:'no-cache' });
    if (!r.ok) return [];
    const arr = await r.json();
    const list = Array.isArray(arr) ? arr : (Array.isArray(arr.files) ? arr.files : []);
    return (list || []).map(x => String(x).replace(/^\/+/, ''));
  } catch(e){
    return [];
  }
}
async function fetchText(path){
  const p = path.startsWith('tunes/') ? path : 'tunes/' + path;
  const r = await fetch(p + '?_=' + Date.now(), { cache:'no-cache' });
  if (!r.ok) throw new Error('fetch failed: ' + p);
  const t = await r.text();
  return { path: p, text: t };
}
function metaFromHeader(krn){
  const lines = krn.split(/\r?\n/).slice(0, 120);
  let dir = null, category = null, title = null, diff = null;

  // Try to detect key-mode (major/minor) from the key token: *C: vs *a:
  let keyMode = null;
  const keyMatch = krn.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m);
  if (keyMatch) {
    keyMode = (keyMatch[1] === keyMatch[1].toUpperCase()) ? 'major' : 'minor';
  }

  for (const ln of lines){
    const s = (ln||'').trim();
    if (!s || !s.startsWith('!!')) continue;

    const titleMatch = s.match(/^!!\s*(?:Title|T)\s+(.*)$/i);
    if (titleMatch && titleMatch[1] && !title) {
      title = titleMatch[1].trim();
      continue;
    }

    const numMatch = s.match(/^!!\s*Number\s+(\d+)\s*$/i);
    if (numMatch && numMatch[1]) {
      diff = parseInt(numMatch[1], 10);
      continue;
    }

    const dirLine = s.match(/^!!\s*Dir\b(.*)$/i);
    if (dirLine){
      const rest = (dirLine[1] || '').trim();

      // Direction
      if (/ascending/i.test(rest)) dir = 'ascending';
      if (/descending/i.test(rest)) dir = 'descending';

      // Category detection (new)
      if (/chromatic/i.test(rest)) {
        category = 'chromatic';
      } else if (/pedal\s*point/i.test(rest)) {
        category = 'pedal';
      } else {
        // Legacy detection for major/minor in the Dir line
        if (/major/i.test(rest)) category = 'major';
        if (/minor/i.test(rest)) category = 'minor';
      }
      continue;
    }
  }

  // If no category was found in Dir line, fall back to key-mode
  if (!category) category = keyMode || 'major';

  return { dir, mode: category, keyMode, diff, title };
}
async function buildCatalog(paths, concurrency=4){
  catalog = [];
  let i = 0;
  const results = [];
  async function worker(){
    while (i < paths.length){
      const idx = i++;
      const raw = paths[idx];
      if (!/\.(krn|hum|txt)$/i.test(raw)) continue;
      try {
        const { path, text } = await fetchText(raw);
        const meta = metaFromHeader(text);
results.push({
  path,
  dir: meta.dir,
  mode: meta.mode,         // filter category: 'major'|'minor'|'chromatic'|'pedal'
  keyMode: meta.keyMode,   // actual key-mode: 'major'|'minor' (from *C:/*a:)
  diff: meta.diff,
  title: meta.title,
  text
});
      } catch(e){ /* skip */ }
    }
  }
  await Promise.all(Array.from({length:concurrency}, worker));
// Defensive: ensure no holes/undefined got in (shouldn’t happen, but safe)
catalog = results.filter(Boolean);
  if (totalCount) totalCount.textContent = String(catalog.length);
  updateMatchCount();
}

function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

function matchesFilters(item){
  // Defensive: skip falsy catalog entries (avoids "reading 'mode' of undefined")
  if (!item) return false;

  if (selected.dir.size){
    if (!item.dir || !selected.dir.has(item.dir)) return false;
  }
  if (selected.mode.size){
    if (!item.mode || !selected.mode.has(item.mode)) return false;
  }
  if (selected.diff.size){
    const d = String(item.diff ?? '');
    if (!selected.diff.has(d)) return false;
  }
  return true;
}

function currentMatches(){ return catalog.filter(matchesFilters); }
function updateMatchCount(){
  if (matchCount) matchCount.textContent = String(currentMatches().length);
}

// -------------------- Key button helpers (fixed) --------------------
function refreshKeyButtonsUI(){
  keyButtons.forEach(btn => {
    const c = Number(btn.dataset.count);
    if (enabledCounts.has(c)) btn.classList.add('selected');
    else btn.classList.remove('selected');
  });
}
refreshKeyButtonsUI();
keyButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const c = Number(btn.dataset.count);
    if (enabledCounts.has(c)) {
      enabledCounts.delete(c);
    } else {
      enabledCounts.add(c);
    }
    refreshKeyButtonsUI();
    updateMatchCount();
  });
});
selectAllKeysBtn.addEventListener('click', () => {
  for (let i=0;i<=7;i++) enabledCounts.add(i);
  refreshKeyButtonsUI();
  updateMatchCount();
  // also select all spelled-tonics for convenience
  selectAllIncludeTonics();
});
selectNoneKeysBtn.addEventListener('click', () => {
  enabledCounts.clear();
  refreshKeyButtonsUI();
  updateMatchCount();
  // also clear include spelled-tonics
  clearAllIncludeTonics();
});

// -------------------- Build allowed tonics (original) --------------------
function buildAllowedTonicsForMode(mode){
  const byCount = (mode === 'minor') ? MINOR_BY_COUNT : MAJOR_BY_COUNT;
  const allowed = [];
  for (const cStr of Object.keys(byCount)){
    const c = Number(cStr);
    if (!enabledCounts.has(c)) continue;
    for (const tonic of byCount[c] || []) allowed.push(tonic);
  }
  return allowed;
}

// -------------------- INCLUDE grid wiring (spelled-tonics) --------------------
function uniqueTonicBasesFromMaps(){
  const set = new Set();
  for (const arr of Object.values(MAJOR_BY_COUNT)) for (const t of arr) {
    const n = normalizeTonicForHumdrum(t);
    if (!n) continue;
    const p = parseTonicString(n);
    if (!p) continue;
    const base = p.letter + (p.acc === 'n' ? '' : p.acc);
    set.add(base);
  }
  for (const arr of Object.values(MINOR_BY_COUNT)) for (const t of arr) {
    const n = normalizeTonicForHumdrum(t);
    if (!n) continue;
    const p = parseTonicString(n);
    if (!p) continue;
    const base = p.letter + (p.acc === 'n' ? '' : p.acc);
    set.add(base);
  }
  return Array.from(set).sort((a,b)=>{
    const order='CDEFGAB';
    const ia = order.indexOf(a[0]), ib = order.indexOf(b[0]);
    if (ia !== ib) return ia-ib;
    if (a.length !== b.length) return a.length - b.length;
    return a.localeCompare(b);
  });
}

function renderIncludeButtons(){
  const list = uniqueTonicBasesFromMaps();
  includeGridEl.innerHTML = '';
  list.forEach(base => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'include-btn';
    const display = base.replace(/--/g,'♭♭').replace(/-/g,'♭').replace(/#/g,'♯');
    btn.textContent = display;
    btn.dataset.base = base;
    btn.addEventListener('click', () => {
      const b = btn.dataset.base;
      if (allowedTonicBases.has(b)) {
        allowedTonicBases.delete(b);
        btn.classList.remove('toggled');
      } else {
        allowedTonicBases.add(b);
        btn.classList.add('toggled');
      }
    });
    includeGridEl.appendChild(btn);
  });
}
renderIncludeButtons();

function selectAllIncludeTonics(){
  allowedTonicBases.clear();
  const btns = Array.from(includeGridEl.querySelectorAll('.include-btn'));
  btns.forEach(btn => {
    const b = btn.dataset.base;
    allowedTonicBases.add(b);
    btn.classList.add('toggled');
  });
}
function clearAllIncludeTonics(){
  allowedTonicBases.clear();
  const btns = Array.from(includeGridEl.querySelectorAll('.include-btn'));
  btns.forEach(btn => btn.classList.remove('toggled'));
}

// Wire the include all/none buttons
if (includeSelectAllBtn) {
  includeSelectAllBtn.addEventListener('click', () => {
    selectAllIncludeTonics();
  });
}
if (includeSelectNoneBtn) {
  includeSelectNoneBtn.addEventListener('click', () => {
    clearAllIncludeTonics();
  });
}

// -------------------- Effective allowed tonics (updated) --------------------
function getEffectiveAllowedTonicsForMode(mode){
  // If the user selected spelled tonics, filter allowed tonics by these bases.
  const allowedByCount = buildAllowedTonicsForMode(mode);
  if (allowedTonicBases.size === 0) return allowedByCount;

  const out = [];
  // Prepare allowed base specs: {letter, accOrEmpty}
  const allowedSpecs = Array.from(allowedTonicBases).map(b => {
    const letter = b[0].toUpperCase();
    const acc = b.length > 1 ? b.slice(1) : '';
    return {letter, acc};
  });

  for (const t of allowedByCount){
    const n = normalizeTonicForHumdrum(t);
    const p = parseTonicString(n);
    if (!p) continue;
    const candLetter = p.letter; // uppercase
    const candAcc = p.acc === 'n' ? '' : p.acc; // '' | '#' | '-'
    // If any allowedSpec matches this candidate:
    for (const spec of allowedSpecs){
      if (candLetter !== spec.letter) continue;
      const specAcc = spec.acc; // '' | '#' | '-'
      if (specAcc === '') {
        if (candAcc === '') { out.push(t); break; }
      } else {
        if (candAcc === specAcc) { out.push(t); break; }
      }
    }
  }

  return out;
}

// -------------------- Rendering --------------------
function getCurrentScaleSpacing(){
  const scale = (scaleSlider && scaleSlider.value) ? Number(scaleSlider.value) : baseOptions.scale;
  const spacingLinear = (spacingSlider && spacingSlider.value) ? Number(spacingSlider.value)/100 : baseOptions.spacingLinear;
  return { scale, spacingLinear };
}
function tonicToVerovioAscii(tonic) {
  if (!tonic) return '';
  return String(tonic)
    .replace(/--/g, 'bb')
    .replace(/-/g, 'b')
    .replace(/\u266d/g, 'b')
    .replace(/\u266f/g, '#');
}

/* ====== Fit-to-viewer utilities (Humdrum) ====== */
let lastGoodPageWidth = null;
let lastRenderReason = "init";

/* Measure the available pixel width inside #viewer (with a floor) */
function viewerAvailableWidth(){
  const el = document.getElementById('viewer');
  if (!el) return 800;
  const rect = el.getBoundingClientRect();
  const w = Math.floor(rect.width || el.clientWidth || 0);
  return Math.max(340, w);
}

/* Read the intrinsic width of the rendered <svg> in #svg */
function svgIntrinsicWidthPx(){
  const svg = document.querySelector('#svg svg');
  if (!svg) return 0;
  const wAttr = parseFloat(svg.getAttribute('width') || "0");
  if (Number.isFinite(wAttr) && wAttr > 0) return wAttr;
  try{
    const box = svg.getBBox();
    return box.width || 0;
  } catch {
    return 0;
  }
}

/* Render once with a specific pageWidth and transpose */
function renderHumOnce(krnText, transposeStr, optionsOverride = {}){
  const { scale, spacingLinear } = getCurrentScaleSpacing();

  const options = {
    ...baseOptions,
    pageWidth: Math.max(100, Math.floor(optionsOverride.pageWidth || baseOptions.pageWidth || 900)),
    scale: Number(scale),
    spacingLinear: Number(spacingLinear),
    transpose: String(transposeStr || "")
  };

  lastRenderTranspose = options.transpose;

  if (vrv) {
    vrv.setOptions(options);
    const svg = vrv.renderData(krnText || '', {});
    svgHost.innerHTML = svg;

    // Ensure there is no vertical clamp; we handle fit via width only
    const viewer = document.getElementById('viewer');
    if (viewer) viewer.style.maxHeight = "";
  } else {
    svgHost.textContent = '(verovio not initialized) — preview disabled';
  }
}

/* Iteratively fit the rendered SVG width to nearly fill the viewer */
async function fitPageWidthToViewerHum(krnText, transposeStr){
  const avail = viewerAvailableWidth();
  const hardMax = Math.floor(avail - 6);  // small safety margin
  const FILL_TARGET = 0.92;               // aim for ~92% of container

  // Heuristic: reuse last good width unless spacing just changed
  let pw = (lastGoodPageWidth && Math.abs(lastGoodPageWidth - avail) < 260 && lastRenderReason !== "spacing")
    ? lastGoodPageWidth
    : avail;

  // 1) initial render
  renderHumOnce(krnText, transposeStr, { pageWidth: pw });
  let w = svgIntrinsicWidthPx();

  // 2) shrink if necessary
  let tries = 0;
  while (w > hardMax && tries < 8){
    pw = Math.max(320, Math.floor(pw * 0.94));
    renderHumOnce(krnText, transposeStr, { pageWidth: pw });
    w = svgIntrinsicWidthPx();
    tries++;
  }

  // 3) grow toward target fill
  tries = 0;
  while (w > 0 && w < hardMax * FILL_TARGET && tries < 10){
    const bump = Math.max(16, Math.floor((hardMax - w) * 0.35));
    pw = Math.min(5000, pw + bump);
    renderHumOnce(krnText, transposeStr, { pageWidth: pw });
    const newW = svgIntrinsicWidthPx();
    if (newW <= w + 1) break; // stalled
    w = newW;
    if (w > hardMax) break;
    tries++;
  }

  // 4) final clamp down if we overshot
  tries = 0;
  w = svgIntrinsicWidthPx();
  while (w > hardMax && tries < 8){
    pw = Math.max(320, Math.floor(pw * 0.96));
    renderHumOnce(krnText, transposeStr, { pageWidth: pw });
    w = svgIntrinsicWidthPx();
    tries++;
  }

  lastGoodPageWidth = pw;
}

/* Light debounce helper for resize events */
function debounce(fn, delay = 150){
  let t = null;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
}

// Fit-to-viewer render (like Boyvin)
function renderWithVerovio(krnText, tonicForRender){
  try {
    // Prefer numeric transpose when octave shifting; otherwise the spelled tonic
    const transposeParam =
      (currentRenderSemitoneShift && !isNaN(Number(currentRenderSemitoneShift)))
        ? String(Number(currentRenderSemitoneShift))
        : (tonicForRender ? tonicToVerovioAscii(String(tonicForRender)) : '');

    // Run the iterative pageWidth fitting loop
    fitPageWidthToViewerHum(krnText || '', transposeParam);
  } catch (e) {
    svgHost.textContent = 'Render failed: ' + (e?.message || e);
    traceLog && traceLog('renderWithVerovio error: ' + (e?.message || e));
  } finally {
    lastRenderReason = "other";
  }
}

// -------------------- Pipeline --------------------
// -------------------- Pipeline --------------------
function runPipelineForEntry(entry, tonic, m){
  const originalAbsolute = entry.text;

  // Prepare a working copy first
  let prepared = entry.text;

  // Modern override (if on)
  if (ACC_MODE === 'modern') {
    prepared = applyModernOverride(prepared);
  }

  // Always show the image tagline + a hidden historical span
  modeTagline.innerHTML =
    '<img src="./emanuel.png" alt="Carl Philipp Emanuel Bach" class="tagline-img">' +
    '<span id="historicalStatus" class="visually-hidden"></span>';

  // Re-query the fresh span (the old const points to a removed node after innerHTML)
  const hs = document.getElementById('historicalStatus');
  if (hs) hs.textContent = `Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}`;

  // Courtesy
  const { text: withCourtesy, conflicts } = applyCourtesyFromSpine4(prepared);
  if (conflicts.length){
    const msg = `ERROR: figures present in both spine-3 and spine-4 on ${conflicts.length} row(s) — e.g., line ${conflicts[0].line}.`;
    setStatus(msg, true);
    traceLog(msg);
  } else {
    setStatus(`Loaded: ${entry.path} — mode=${m}${tonic?', target='+tonic:''}`);
  }

  // Resolve q/Nq now that s3→s2 may have occurred
  const withResolvedQ = resolveQInSpine2(withCourtesy, tonic, m);

  // Suppress spines 3 & 4 (text to Verovio)
  const suppressed = suppressThirdFourthSpinesAfterKey(withResolvedQ);
  const krnSentToVerovio = suppressed;

  // Figure-aware transform using spelled interval + chromatic-bass support
  const transformed = transformFiguresForTonicWithTrace(
    krnSentToVerovio,
    String(tonic || '').trim(),
    m
  );

  // Save the pre-placement form, then apply placement
  lastTransformedKrn = transformed;
  currentKrn = applyFiguredBassPlacement(lastTransformedKrn, FB_ABOVE);

  // Humdrum panel
  humPanel.textContent = '';
  humPanel.textContent += '## 1) ORIGINAL .krn (absolute source)\n\n';
  humPanel.textContent += originalAbsolute + '\n\n';
  humPanel.textContent += '## 2) .krn sent to Verovio (after modern override + courtesy + q-resolve; then suppressed)\n\n';
  humPanel.textContent += krnSentToVerovio + '\n\n';
  humPanel.textContent += `## TARGET KEY: ${formatKeyName(tonic, m)}\n\n`;
  humPanel.textContent += '## 3) Transpose output (after figure-aware transform)\n\n';
  humPanel.textContent += lastTransformedKrn + '\n\n';
  humPanel.textContent += `## 4) Placement applied: ${FB_ABOVE ? 'ABOVE (**fba + x-padding)' : 'BELOW (**fb)'}\n\n`;
  humPanel.textContent += currentKrn + '\n\n';
  humPanel.textContent += `## 5) Historical mode status: Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}\n`;

  // Remember keys so toggles can act
  lastTargetTonic = tonic;
  lastTargetMode = m;

  // Reset numeric render shift (octave) when we start a new pipeline run
  currentRenderSemitoneShift = 0;

  // Update badge and render
  updateKeyPill(tonic, m);
  renderWithVerovio(currentKrn, tonic);
}

// -------------------- Sample / Random --------------------
const sample = `**kern\t**fb\t**text\t**text
!!\t\tactual acc.\tforce diatonic accidental
!! Dir\tDescending Minor
!! Title\tRule of the Octave
!! Number\t4
*clefF4\t*\t*\t*
*k[]\t*k[]\t*k[]\t*k:
*a:\t*a:\t*a:\t*a:
=1\t=1\t.\t.
4AA\t5\t.\t.
4BB\t7\t.\t.
4C\t6\t.\t.
4D\t9\t.\t.
.\t8\t.\t.
4E\t6 4\t.\t.
.\t5 #\t.\t.
4F#\t6\t.\t.
4G#\t6 5\t.\t.
4A\t.\t.\t.
=|\t=|\t.\t.
*-\t*-\t*-\t*-`;

// -------------------- Enharmonic toggle sets --------------------
const ENH_MAJOR_PAIRS = [['C#','Db'], ['F#','Gb']];
const ENH_MINOR_PAIRS = [['Eb','D#'], ['Ab','G#'], ['A#','Bb']];

function findEnhPairContaining(name, mode){
  if (!name) return null;
  const norm = normalizeTonicForHumdrum(name);
  const pairs = (mode === 'minor') ? ENH_MINOR_PAIRS : ENH_MAJOR_PAIRS;
  for (const pair of pairs){
    for (const p of pair){
      if (normalizeTonicForHumdrum(p) === norm) return pair;
    }
  }
  return null;
}

// -------------------- Semitone/tonic helpers for tp+/- --------------------
function semitoneToTonicName(targetSemitone, mode, preferFlats){
  const byCount = (mode === 'minor') ? MINOR_BY_COUNT : MAJOR_BY_COUNT;
  const candidates = [];
  for (const arr of Object.values(byCount)){
    for (const t of arr) candidates.push(t);
  }
  const matches = candidates.filter(t => {
    const n = normalizeTonicForHumdrum(t);
    const p = parseTonicString(n);
    if (!p) return false;
    return spelledToSemitone(p.letter, p.acc) === ((targetSemitone%12)+12)%12;
  });
  if (!matches.length) return null;
  if (matches.length === 1) return matches[0];
  const flats = matches.filter(x => /b|--|-/.test(x));
  const sharps = matches.filter(x => /#/.test(x));
  if (preferFlats && flats.length) return flats[0];
  if (!preferFlats && sharps.length) return sharps[0];
  return matches[0];
}

function pickSpelledTonicBySemitoneStep(currentSpelledTonic, mode, step){
  const baseParsed = parseTonicString(normalizeTonicForHumdrum(currentSpelledTonic));
  if (!baseParsed) return null;
  const baseSem = spelledToSemitone(baseParsed.letter, baseParsed.acc);
  const newSem = ((baseSem + step) % 12 + 12) % 12;
  const candidatesAllowed = buildAllowedTonicsForMode(mode);
  for (const cand of candidatesAllowed){
    const p = parseTonicString(normalizeTonicForHumdrum(cand));
    if (!p) continue;
    if (spelledToSemitone(p.letter, p.acc) === newSem) return normalizeTonicForHumdrum(cand);
  }
  const standard = semitoneToTonicName(newSem, mode, transposePreferFlats);
  if (standard) return normalizeTonicForHumdrum(standard);
  if (candidatesAllowed && candidatesAllowed.length){
    const normList = candidatesAllowed.map(x => normalizeTonicForHumdrum(x));
    let idx = normList.indexOf(normalizeTonicForHumdrum(currentSpelledTonic));
    if (idx < 0) idx = 0;
    const next = normList[(idx + (step>0?1:-1) + normList.length) % normList.length];
    return normalizeTonicForHumdrum(next);
  }
  return null;
}

// -------------------- Transpose control wiring --------------------
function setTargetTonic(tonic){
  if (!currentEntry) { traceLog('setTargetTonic: no current entry'); return; }
  const t = normalizeTonicForHumdrum(tonic);
  lastTargetTonic = t;
  // Use true key-mode (major/minor), not the category label (chromatic/pedal)
  lastTargetMode = lastTargetMode || currentEntry.keyMode || 'major';
  currentRenderSemitoneShift = 0;
  runPipelineForEntry(currentEntry, t, lastTargetMode);
}

if (tpPlus) tpPlus.addEventListener('click', () => {
  traceLog('tpPlus pressed (semitone up)');
  if (!lastTargetTonic || !lastTargetMode) { traceLog('tpPlus: no current spelled tonic; nothing to do'); return; }
  const next = pickSpelledTonicBySemitoneStep(lastTargetTonic, lastTargetMode, +1);
  if (next) { traceLog(`tpPlus -> chosen spelled tonic ${next}`); setTargetTonic(next); } else { traceLog('tpPlus: failed to find next spelled tonic - no change'); }
});
if (tpMinus) tpMinus.addEventListener('click', () => {
  traceLog('tpMinus pressed (semitone down)');
  if (!lastTargetTonic || !lastTargetMode) { traceLog('tpMinus: no current spelled tonic; nothing to do'); return; }
  const next = pickSpelledTonicBySemitoneStep(lastTargetTonic, lastTargetMode, -1);
  if (next) { traceLog(`tpMinus -> chosen spelled tonic ${next}`); setTargetTonic(next); } else { traceLog('tpMinus: failed to find next spelled tonic - no change'); }
});

if (tpToggle) tpToggle.addEventListener('click', () => {
  traceLog('tpToggle clicked');
  if (!lastTargetTonic || !lastTargetMode) {
    transposePreferFlats = !transposePreferFlats;
    tpToggle.classList.toggle('active', transposePreferFlats);
    traceLog('tpToggle: no spelled tonic loaded; toggled preferFlats=' + transposePreferFlats);
    return;
  }
  const pair = findEnhPairContaining(lastTargetTonic, lastTargetMode);
  if (!pair) {
    transposePreferFlats = !transposePreferFlats;
    tpToggle.classList.toggle('active', transposePreferFlats);
    traceLog('tpToggle: no pair for ' + lastTargetTonic + '; preferFlats=' + transposePreferFlats);
    updateKeyPill(lastTargetTonic, lastTargetMode);
    return;
  }
  const norm = normalizeTonicForHumdrum(lastTargetTonic);
  const other = normalizeTonicForHumdrum(pair[0]) === norm ? pair[1] : pair[0];
  traceLog(`tpToggle: switching ${norm} -> ${other}`);
  setTargetTonic(other);
  transposePreferFlats = /b|--|-/.test(other);
  tpToggle.classList.toggle('active', transposePreferFlats);
});

// Refit on viewport resize (phone rotation, split view, etc.)
window.addEventListener('resize', debounce(() => {
  lastRenderReason = "resize";
  lastGoodPageWidth = null;  // force recompute
  if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic || '');
}, 150));


// -------------------- Octave buttons (render-only numeric transpose) --------------------
function applyRenderSemitoneShift(delta){
  // accumulate numeric render shifts (12 per octave)
  currentRenderSemitoneShift = (currentRenderSemitoneShift || 0) + delta;
  traceLog(`applyRenderSemitoneShift => ${currentRenderSemitoneShift}`);
  // Re-render with same pipeline-output KRn, but numeric transpose to verovio.
  renderWithVerovio(currentKrn || sample, lastTargetTonic || '');
  // Keep key pill showing the spelled target key (do not change it)
  updateKeyPill(lastTargetTonic || '', lastTargetMode || '');
}
if (octPlus) octPlus.addEventListener('click', () => { traceLog('octPlus clicked'); applyRenderSemitoneShift(+12); });
if (octMinus) octMinus.addEventListener('click', () => { traceLog('octMinus clicked'); applyRenderSemitoneShift(-12); });

// -------------------- Accidentals toggle re-run + label visuals --------------------
const labelHistoric = document.getElementById('labelHistoric');
const labelModern = document.getElementById('labelModern');
function updateAccLabelVisuals(){
  const checked = document.querySelector('input[name="accMode"]:checked');
  if (checked && checked.value === 'modern') {
    labelModern.classList.add('selected');
    labelHistoric.classList.remove('selected');
  } else {
    labelHistoric.classList.add('selected');
    labelModern.classList.remove('selected');
  }
}
accRadios.forEach(r => {
  r.addEventListener('change', () => {
    if (!r.checked) return;
    ACC_MODE = r.value === 'modern' ? 'modern' : 'historic';
    updateAccLabelVisuals();
    traceLog(`Accidentals mode changed => ${ACC_MODE}`);

    if (currentEntry && lastTargetTonic && lastTargetMode) {
      runPipelineForEntry(currentEntry, lastTargetTonic, lastTargetMode);
    } else {
      // Keep the image tagline and add a fresh hidden span
      modeTagline.innerHTML =
        '<img src="./emanuel.png" alt="Carl Philipp Emanuel Bach" class="tagline-img">' +
        '<span id="historicalStatus" class="visually-hidden"></span>';

      // Write to the new span
      const hs = document.getElementById('historicalStatus');
      if (hs) hs.textContent = `Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}`;
    }
  });
});
updateAccLabelVisuals(); // initialize visual

// -------------------- Figured-bass placement radio wiring --------------------
function updateFigPlaceLabelVisuals() {
  const fbAbove = document.getElementById('fbAbove');
  const fbBelow = document.getElementById('fbBelow');
  const labA = document.getElementById('labelFigAbove');
  const labB = document.getElementById('labelFigBelow');
  const above = !!(fbAbove && fbAbove.checked);
  if (labA) labA.classList.toggle('selected', above);
  if (labB) labB.classList.toggle('selected', !above);
}

(function initFigPlacementRadios(){
  const fbAbove = document.getElementById('fbAbove');
  const fbBelow = document.getElementById('fbBelow');

  const applyAndRender = () => {
    FB_ABOVE = !!(fbAbove && fbAbove.checked);
    updateFigPlaceLabelVisuals();

    // Re-apply placement to the latest transposed KRn and re-render
    if (lastTransformedKrn) {
      currentKrn = applyFiguredBassPlacement(lastTransformedKrn, FB_ABOVE);
      renderWithVerovio(currentKrn, lastTargetTonic || '');

      // Re-run the pipeline so the Humdrum panel sections stay perfectly in sync
      if (currentEntry && lastTargetTonic && lastTargetMode) {
        runPipelineForEntry(currentEntry, lastTargetTonic, lastTargetMode);
      }
    }
  };

  if (fbAbove) fbAbove.addEventListener('change', applyAndRender);
  if (fbBelow) fbBelow.addEventListener('change', applyAndRender);

  // initial visuals
  updateFigPlaceLabelVisuals();
})();


// -------------------- Filter button wiring (FIX) --------------------
// Utility to toggle a value in a Set and update UI/counts
function toggleFilterValue(filterName, value, btnEl) {
  const set = selected[filterName];
  if (!set) return;
  if (set.has(value)) {
    set.delete(value);
    btnEl.classList.remove('selected');
  } else {
    set.add(value);
    btnEl.classList.add('selected');
  }
  updateMatchCount();
}

// Attach listeners to Dir / Mode / Diff buttons
Array.from(document.querySelectorAll('#dirRow .btn')).forEach(btn => {
  btn.addEventListener('click', () => {
    const v = btn.dataset.value;
    if (!v) return;
    toggleFilterValue('dir', v, btn);
  });
});
Array.from(document.querySelectorAll('#modeRow .btn')).forEach(btn => {
  btn.addEventListener('click', () => {
    const v = btn.dataset.value;
    if (!v) return;
    toggleFilterValue('mode', v, btn);
  });
});
Array.from(document.querySelectorAll('#diffRow .btn')).forEach(btn => {
  btn.addEventListener('click', () => {
    const v = btn.dataset.value;
    if (!v) return;
    toggleFilterValue('diff', v, btn);
  });
});

// Clear filters button: clear internal sets and visual selected classes
if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    selected.dir.clear();
    selected.mode.clear();
    selected.diff.clear();
    document.querySelectorAll('#dirRow .btn, #modeRow .btn, #diffRow .btn').forEach(b => b.classList.remove('selected'));
    updateMatchCount();
  });
}

// -------------------- Sample / Random wiring (UPDATED to respect include spelled-tonics) ----
randomBtn.addEventListener('click', async () => {
  // Pick from filtered catalog, or fall back to sample
  const pick = catalog.length
    ? pickRandom(currentMatches())
    : { path:'sample', text: sample, dir:'descending', mode:'major', keyMode:'major', diff:1, title:'Sample' };

  currentEntry = pick;

  // Category for UI (may be 'chromatic' or 'pedal' in addition to 'major'/'minor')
  const mCategory = pick.mode || 'major';

  // True key-mode (major/minor) from key token for tonic/key-range logic
  const mForTonics =
    pick.keyMode ||
    ((pick.text.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m)?.[1] ===
      pick.text.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m)?.[1]?.toUpperCase())
      ? 'major'
      : 'minor') || 'major';

  // Use effective allowed tonics (Include-grid and Key-Range) based on true key-mode
  const allowedTonics = getEffectiveAllowedTonicsForMode(mForTonics);
  traceLog(`Allowed tonics for key-mode=${mForTonics}: ${JSON.stringify(allowedTonics)}`);

  if (!allowedTonics.length){
    const msg = 'No allowed keys selected for this mode. Enable one or more key-range buttons (0..7) or choose Include keys.';
    setStatus(msg, true);
    traceLog('ERROR: ' + msg);
    // Title uses category for readability; key pill shows no target key
    updatePillsFromCatalogEntry(pick);
    updateKeyPill('', mForTonics);
    humPanel.textContent = '##original\n' + suppressThirdFourthSpinesAfterKey(pick.text) + '\n\n##transposed to [none]\n';
    return;
  }

  // Choose a target tonic within the allowed set
  const tonic = normalizeTonicForHumdrum(pickRandom(allowedTonics));
  lastTargetTonic = tonic;
  lastTargetMode  = mForTonics;

  // Update UI and run pipeline
  updatePillsFromCatalogEntry(pick);        // shows "Ascending Chromatic ..." etc, based on category
  updateKeyPill(tonic || '', mForTonics);   // key pill always shows Major/Minor
  runPipelineForEntry(pick, tonic, mForTonics);
});

// -------------------- Scale / Spacing wiring --------------------
function updateScaleValueDisplay(){
  if (scaleValue && scaleSlider) scaleValue.textContent = String(Number(scaleSlider.value));
}
function updateSpacingValueDisplay(){
  if (spacingValue && spacingSlider) spacingValue.textContent = (Number(spacingSlider.value)/100).toFixed(2);
}
if (scaleSlider){
  scaleSlider.addEventListener('input', () => {
    updateScaleValueDisplay();
    if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic);
    else renderWithVerovio(sample, '');
  });
  updateScaleValueDisplay();
}
if (spacingSlider){
  spacingSlider.addEventListener('input', () => {
    updateSpacingValueDisplay();
    if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic);
    else renderWithVerovio(sample, '');
  });
  updateSpacingValueDisplay();
}
if (scaleMinus) scaleMinus.addEventListener('click', ()=>{ scaleSlider.value = Math.max(10, Number(scaleSlider.value)-1); updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (scalePlus) scalePlus.addEventListener('click', ()=>{ scaleSlider.value = Math.min(120, Number(scaleSlider.value)+1); updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (scaleReset) scaleReset.addEventListener('click', ()=>{ scaleSlider.value = 50; updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });

if (spacingMinus) spacingMinus.addEventListener('click', ()=>{ spacingSlider.value = Math.max(10, Number(spacingSlider.value)-1); updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (spacingPlus) spacingPlus.addEventListener('click', ()=>{ spacingSlider.value = Math.min(120, Number(spacingSlider.value)+1); updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (spacingReset) spacingReset.addEventListener('click', ()=>{ spacingSlider.value = 32; updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });

// -------------------- Misc UI placeholders --------------------
if (tpMinus) tpMinus.addEventListener('click', ()=> { /* handled above */ });
if (tpPlus) tpPlus.addEventListener('click', ()=> { /* handled above */ });
if (tpToggle) tpToggle.addEventListener('click', ()=> { /* handled above */ });

// -------------------- Init: catalog or sample --------------------
const paths = await (async () => {
  try { return await fetchList(); } catch(e){ return []; }
})();
if (paths.length){
  setStatus('Indexing tunes.json…');
  await buildCatalog(paths, 4);
  setStatus('Index complete — choose filters & key range, then click “New Bass Line”.');
} else {
  setStatus('No tunes.json found — using sample.');
}

// By default include all spelled tonics (user asked default = all lit up)
selectAllIncludeTonics();

// Also make sure key-range default selected matches earlier behavior (all)
for (let i=0;i<=7;i++) enabledCounts.add(i);
refreshKeyButtonsUI();
updateMatchCount();

if (!currentKrn) {
  currentEntry = { path:'sample', text: sample, dir:'descending', mode:'major', diff:1, title:'Sample' };
  const prepared = suppressThirdFourthSpinesAfterKey(sample);
  humPanel.textContent = '##original\n' + prepared + '\n\n##transposed to [none]\n';
  renderWithVerovio(sample, '');
  setStatus('ready — toggle TRACE and click "New Bass Line"');
}

})();
</script>
</body>
</html>
