<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Figured Bass Trainer6.3</title>


  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="icon" href="/School-of-Music-LockupStacked-RGB.svg" type="image/svg+xml" />
  <script src="verovio-toolkit-wasm.js"></script>
  <script src="verovio-toolkit-hum.js"></script>

  <style>
  :root{
    --bg:#f7f7f9; --card:#ffffff; --border:#e3e3ea; --ink:#1b1b1f; --muted:#6b6b76;
    --gold:#FFCD00; --gold-border:#d7a900; --butter:#FFEFAD; --butter-border:#E6D48A; --radius:12px;
  }
  *{box-sizing:border-box}
  body{ font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin:0; padding:10px; background:var(--bg); color:var(--ink); font-weight:400; }
  .card{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:8px 10px; }
  button{ border:none; border-radius:10px; padding:8px 10px; font-size:.96rem; cursor:pointer;
    transition:background-color 120ms ease, opacity 120ms ease, transform 60ms ease, box-shadow 120ms ease; user-select:none; }
  button:active{transform:translateY(.5px)} button[disabled]{opacity:.6;cursor:not-allowed}
  .btn-gold{ background:var(--gold); color:#2d2300; border:1px solid var(--gold-border); }
  .btn-gold.pill3d { background:var(--gold); color:#2d2300; border:1px solid var(--gold-border); box-shadow:0 2px 0 rgba(160,120,0,.55); }
  .btn-lite{ background:var(--butter); color:#3b2f00; border:1px solid var(--butter-border); }
  .miniBtn{ padding:6px 10px; border-radius:10px; font-size:.92rem; min-width:40px; text-align:center; }
  .pill3d{ border-radius:999px; padding:10px 16px; box-shadow:0 2px 0 rgba(160,120,0,.12),0 10px 20px rgba(0,0,0,.04); background:transparent; border:1px solid var(--border) }
  .btn-green-pill{ background:#2f7d55; color:#fff; border-radius:999px; padding:10px 16px; }

  #row1{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
  .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#fff; white-space:nowrap; }
  #viewerWrap{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; margin-bottom:8px; }
  #viewer{ padding:8px 12px 4px; min-height:120px; overflow-x:hidden; overflow-y:auto; position:relative; }
  #svg{ display:block }
  #musicFooter{ border-top:1px solid var(--border); padding:6px 12px; font-size:.82rem; color:#9aa0aa; text-align:left; background:#fff; }

  #row3{ display:flex; gap:10px; align-items:stretch; margin-bottom:8px; flex-wrap:wrap; }
  #keyRangeCard{ width:260px; min-width:260px; padding:8px 10px; }
  .keyRangeGrid{ display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:6px; }
  .range-btn{ padding:6px 8px; font-size:0.88rem; border-radius:10px; background:#f3f3f8; color:#333; border:1px solid var(--border); }
  .range-btn.active { background:var(--butter); border:1px solid var(--butter-border); box-shadow: 0 2px 0 rgba(230,212,138,.6); }

  .tool-btn{ background:#f3f3f8; color:#555; border-radius:8px; padding:6px 8px; border:1px solid var(--border); }

  #stackCol{ margin-left:0; width:320px; min-width:320px; display:flex; flex-direction:column; gap:10px; }
  .sliderHeader{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; font-size:.95rem; color:var(--ink); }
  .badge{ padding:3px 9px; border:1px solid var(--border); border-radius:999px; background:#fff; color:#222; font-size:0.88rem; }
  input[type="range"]{ width:100%; accent-color:var(--gold); margin:0; }
  .miniStackCard{ width:260px; min-width:260px; display:flex; flex-direction:column; gap:6px; padding:8px 10px; }
  .stackRow{ display:flex; gap:8px; align-items:center; flex-wrap:nowrap; }

  .chk-label{ display:inline-flex;align-items:center;gap:6px;font-size:.95rem;padding:3px 8px;border-radius:10px;border:1px solid var(--border);background:#fff; }

  .hum-panel{ margin-top:8px; background:#0f1724; color:#e6eef8; font-family:monospace; font-size:0.86rem; border-radius:10px; overflow:auto; border:1px solid #22303b; }
  .hum-panel pre{ margin:0; padding:10px; white-space:pre-wrap; word-break:break-word; }
  .hum-panel summary{ padding:8px 12px; cursor:pointer; font-weight:600; }

  .collection-card{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:10px; border:1px solid var(--border); background:#fff; }
  #row4 { display:flex; gap:10px; margin-bottom:8px; flex-wrap:wrap; align-items:flex-start; }

  .chip .label{ font-size:0.88rem; color:var(--muted); }
  .chip .value{ font-weight:600; margin-left:6px; font-size:0.95rem; }

  #figPlacementCard, .conventions-card { width:360px; min-width:260px; margin:8px 10px 0 0; padding:6px; display:inline-block; vertical-align:top; }
  #figPlacementCard fieldset, .conventions-card fieldset { border:0;margin:0;padding:0; }
  #figPlacementCard legend, .conventions-card legend { font-weight:600; margin-bottom:6px; font-size:0.92rem; }
  .placement-row{ display:flex; gap:14px; align-items:center; justify-content:flex-start; }
  .placement-row label, .conventions-row label {
    display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:8px; border:1px solid var(--border);
    cursor:pointer; background:#fafafa; font-size:.90rem; line-height:1;
  }

  .cpe-card { display:inline-block; vertical-align:top; width:180px; min-width:160px; margin:8px 10px 0 0; padding:8px; }
  .small-filter-card { display:inline-block; vertical-align:top; width:240px; min-width:220px; margin:8px 10px 0 0; padding:8px; }

  .row-equal-height { display:flex; gap:12px; align-items:stretch; flex-wrap:wrap; }
  .row-equal-height .card { display:flex; flex-direction:column; justify-content:flex-start; }

  .asc-desc-controls, .major-minor-controls { display:flex; gap:8px; }
  .asc-desc-btn, .major-minor-btn { padding:8px 12px; border-radius:10px; background:#f3f3f8; border:1px solid var(--border); cursor:pointer; }
  .asc-desc-btn.active, .major-minor-btn.active { background:var(--butter); border:1px solid var(--butter-border); box-shadow:0 2px 0 rgba(230,212,138,.6); }

  .som-logo { display:block; max-width:720px; margin:18px auto 12px auto; opacity:0.98; }

  input[type="radio"], input[type="checkbox"] { accent-color: var(--gold); }

  .boldLabel { font-weight:600; }
  </style>
</head>
<body>
  <div id="row1">
    <button id="randomBtn" class="btn-gold pill3d" type="button">New Bass Line</button>

    <span class="chip pill3d" title="Current title">
      <span id="titleValue" class="valueOnly">—</span>
    </span>

    <span class="chip" title="Current key">
      <span class="label">Key</span>
      <span id="statusKey" class="value">—</span>
    </span>
  </div>

  <div id="viewerWrap">
    <div id="viewer"><div id="svg"></div></div>
    <div id="musicFooter">created for the University of Iowa Organ Studio</div>

    <div style="padding:8px 12px;">
      <div class="card" id="figPlacementCard">
        <fieldset>
          <legend>Figured bass placement</legend>
          <div class="placement-row">
            <label><input type="radio" name="figPlacement" id="figBelow" value="below" checked /> below</label>
            <label><input type="radio" name="figPlacement" id="figAbove" value="above" /> above</label>
          </div>
        </fieldset>
      </div>

      <div class="card conventions-card">
        <fieldset>
          <legend>Accidentals</legend>
          <div class="placement-row conventions-row">
            <label><input type="radio" name="conventionsMode" id="conv_historic" value="historic" checked /> historic</label>
            <label><input type="radio" name="conventionsMode" id="conv_modern" value="modern" /> modern</label>
          </div>
        </fieldset>
      </div>
    </div>

  </div>

  <div id="row3">
    <div class="card" id="keyRangeCard">
      <div class="keyRangeHeader">Key range</div>
      <div class="keyRangeGrid" id="keysRangeRowTop"></div>
      <div style="height:6px"></div>
      <div class="keyRangeGrid" id="keysRangeRowBottom"></div>
      <div class="keyRangeToolsBottom" style="margin-top:8px">
        <button class="tool-btn" type="button" id="keysAllBtn">select all</button>
        <button class="tool-btn" type="button" id="keysNoneBtn">select none</button>
      </div>
    </div>

    <div id="stackCol">
      <div class="card">
        <div class="sliderHeader">
          <div>Scale</div>
          <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
            <button id="scaleResetBtn" class="reset-btn" type="button" title="Reset scale to default">reset</button>
            <button id="musicMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease scale">–</button>
            <button id="musicPlusBtn" class="miniBtn btn-lite" type="button" title="Increase scale">+</button>
            <span id="scaleBadge" class="badge">—</span>
          </div>
        </div>
        <input id="scaleSlider" type="range" min="30" max="200" step="2" value="50" />
      </div>

      <div class="card">
        <div class="sliderHeader">
          <div>Spacing</div>
          <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
            <button id="spacingResetBtn" class="reset-btn" type="button" title="Reset spacing to default">reset</button>
            <button id="spacingMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease spacing">–</button>
            <button id="spacingPlusBtn" class="miniBtn btn-lite" type="button" title="Increase spacing">+</button>
            <span id="spacingBadge" class="badge">—</span>
          </div>
        </div>
        <!-- max spacing increased to 0.50; default 0.32 -->
        <input id="spacingSlider" type="range" min="0.20" max="0.99" step="0.01" value="0.50" />
      </div>
    </div>

    <div class="card miniStackCard" id="xposeOctCard">
      <div class="stackTitle">Transpose</div>
      <div class="stackRow wrap">
        <button id="halfDownBtn" class="miniBtn btn-lite" type="button">–</button>
        <button id="halfUpBtn" class="miniBtn btn-lite" type="button">+</button>
        <button id="enharmonicBtn" class="btn-green-pill" type="button" title="Toggle enharmonic display">♯/♭</button>
      </div>

      <div class="stackTitle" style="margin-top:10px;">Octave</div>
      <div class="stackRow">
        <button id="octDownBtn" class="miniBtn btn-lite" type="button">–</button>
        <button id="octUpBtn" class="miniBtn btn-lite" type="button">+</button>
      </div>
    </div>
  </div>

  <div class="row-equal-height" style="margin-top:12px;">
    <div class="card cpe-card">
      <div class="boldLabel">CPE Bach</div>
      <div style="height:6px"></div>
      <div class="major-minor-controls">
        <button id="filterMajorBtn" class="major-minor-btn active" type="button">Major</button>
        <button id="filterMinorBtn" class="major-minor-btn active" type="button">Minor</button>
      </div>
    </div>

    <div class="card small-filter-card">
      <div class="boldLabel">Direction</div>
      <div style="height:6px"></div>
      <div class="asc-desc-controls">
        <button id="filterAscBtn" class="asc-desc-btn active" type="button">Ascending</button>
        <button id="filterDescBtn" class="asc-desc-btn active" type="button">Descending</button>
      </div>
    </div>

    <div class="card small-filter-card" id="maxDifficultyCard">
      <div class="boldLabel">Max difficulty</div>
      <div style="height:6px"></div>
      <div class="sliderHeader" style="margin-top:6px;">
        <div></div>
        <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
          <button id="maxMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease max difficulty">–</button>
          <button id="maxPlusBtn" class="miniBtn btn-lite" type="button" title="Increase max difficulty">+</button>
          <span id="maxBadge" class="badge">7</span>
        </div>
      </div>
      <input id="maxRange" type="range" min="1" max="7" step="1" value="7" />
    </div>
  </div>

  <details id="filtersCard" open style="margin-top:12px;">
    <summary>Filters</summary>
    <div id="optionsBar">
      <fieldset class="panel" id="exPanel">
        <legend>
          <span>Exclude</span>
          <span class="panel-tools">
            <button class="tool-btn" type="button" id="exAllBtn">select all</button>
            <button class="tool-btn" type="button" id="exNoneBtn">select none</button>
          </span>
        </legend>
        <div class="row" id="exRow" style="padding:8px 6px;"></div>
      </fieldset>
    </div>
  </details>

  <div style="margin-top:8px;">
    <div class="collection-card card">
      <div style="font-weight:600">My Collection</div>
      <div style="width:12px"></div>
      <div style="color:var(--muted); font-size:.92rem">(custom collection editor coming)</div>
      <div style="flex:1"></div>
      <button id="manageCollectionBtn" class="miniBtn btn-lite" type="button">Manage</button>
    </div>
  </div>

  <div style="padding:16px 0 8px 0; text-align:center;">
    <img src="School-of-Music-LockupStacked-RGB.svg" alt="School of Music" class="som-logo" />
  </div>

  <details class="hum-panel" id="humPanelWrap" open style="margin:10px 16px 40px 16px;">
    <summary>Humdrum source used for rendering (click to collapse)</summary>
    <pre id="humPanel">loading…</pre>
  </details>

  <script>
  (async function(){
    /* -------------------- Constants & helpers -------------------- */
    const LETTER_TO_INDEX = { 'C':0,'D':2,'E':4,'F':5,'G':7,'A':9,'B':11 };

    function tonicNameNormalized(name) {
      if (!name) return null;
      return String(name).replace(/♯/g,'#').replace(/♭/g,'b').replace(/-/g,'b').trim();
    }

    function indexToTonic(index, preferAccidental) {
      index = (index + 12) % 12;
      const candidates = SAFE_TONICS_MAJOR[index] || [];
      if (preferAccidental === '#') {
        const c = candidates.find(x => x.includes('#'));
        if (c) return c;
      }
      if (preferAccidental === 'b') {
        const c = candidates.find(x => x.includes('b'));
        if (c) return c;
      }
      for (const c of candidates) {
        if (c in ACCIDENTAL_COUNT) return c;
      }
      return candidates[0] || 'C';
    }

    function keyToIndex(letter, accidental) {
      let idx = LETTER_TO_INDEX[(letter||'').toUpperCase()];
      if (idx == null) return null;
      if (accidental === '#' || accidental === '♯') idx = (idx + 1) % 12;
      if (accidental === 'b' || accidental === '♭' || accidental === '-') idx = (idx + 11) % 12;
      return idx;
    }

    /* -------------------- enharmonic display toggle -------------------- */
    let displayTonicOverride = null;
    let enharmonicCycleList = null;
    function toggleEnharmonicDisplay() {
      if (!enharmonicCycleList || enharmonicCycleList.length <= 1) {
        displayTonicOverride = enharmonicCycleList ? enharmonicCycleList[0] : displayTonicOverride;
        renderWithTranspose();
        return;
      }
      const cur = displayTonicOverride || enharmonicCycleList[0];
      let i = enharmonicCycleList.findIndex(n => tonicNameNormalized(n) === tonicNameNormalized(cur));
      if (i === -1) i = 0;
      const next = enharmonicCycleList[(i+1) % enharmonicCycleList.length];
      displayTonicOverride = next;
      renderWithTranspose();
    }

    /* -------------------- meta extraction -------------------- */
    function extractSecondSpineMeta(humText) {
      const out = { dir: null, title: null, number: null };
      if (!humText) return out;
      const lines = String(humText).split(/\r?\n/);

      let headerLineIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        if (/^\*\*/.test(lines[i].trim())) { headerLineIndex = i; break; }
      }
      if (headerLineIndex === -1) return out;

      for (let i = headerLineIndex + 1; i < lines.length; i++) {
        const ln = lines[i];
        if (!ln) continue;
        if (/^\*/.test(ln.trim())) break;
        if (!/^!!/.test(ln.trim())) continue;

        const payload = ln.replace(/^!!\s*/, '');
        const cols = payload.split(/\t/).map(s => s.trim());

        for (let c = 0; c < cols.length; c++) {
          const valNext = (c+1 < cols.length) ? cols[c+1] : null;
          if (/^Dir$/i.test(cols[c]) && valNext) out.dir = out.dir || valNext;
          if (/^Title$/i.test(cols[c]) && valNext) out.title = out.title || valNext;
          if (/^Number$/i.test(cols[c]) && valNext) out.number = out.number || valNext;
        }

        if ((!out.dir || !out.title || !out.number) && cols.length >= 1) {
          const m = cols[0].match(/^([^:]+)\s*:\s*(.+)$/);
          if (m) {
            const lab = m[1].trim(), val = m[2].trim();
            if (/^Dir$/i.test(lab) && val) out.dir = out.dir || val;
            if (/^Title$/i.test(lab) && val) out.title = out.title || val;
            if (/^Number$/i.test(lab) && val) out.number = out.number || val;
          }
        }

        if (out.dir && out.title && out.number) break;
      }
      return out;
    }

    /* -------------------- robust asset helpers -------------------- */
    // Build a relative path that works for GitHub Pages (keeps repo base path)
    function normalizeTunePath(entry) {
      if (!entry) return '';
      let e = String(entry);
      e = e.replace(/^"+|"+$/g,''); // trim stray quotes if any
      e = e.replace(/^\/+/, ''); // drop leading slash
      // If tune.json entries use 'tunes/...' already, keep it, otherwise prepend 'tunes/'
      if (!/^tunes\//i.test(e) && !/^tunes\.json$/i.test(e)) e = 'tunes/' + e;
      return e;
    }

    function buildRelativeForAsset(pathSegment) {
      // compute directory of current document (keeps repo path for GitHub Pages)
      const baseDir = (window.location.pathname.endsWith('/'))
        ? window.location.pathname
        : window.location.pathname.replace(/\/[^/]*$/, '/');
      // join and dedupe slashes, but leave leading slash (so browser will request same origin + path)
      // We purposely avoid a domain (origin) so fetch uses same origin, same branch root
      let p = baseDir + pathSegment;
      p = p.replace(/\/{2,}/g, '/');
      // If the site is hosted at domain root, leading slash is fine; if hosted under /repo/, baseDir includes /repo/
      return p;
    }

    // fetch helper: logs and uses encodeURI (so slashes remain)
    async function fetchAsset(entry) {
      const rel = normalizeTunePath(entry);
      const urlPath = buildRelativeForAsset(rel);
      console.log('[fetchAsset] trying', { entry, rel, urlPath });
      try {
        const resp = await fetch(encodeURI(urlPath), { cache: 'no-cache' });
        if (!resp || !resp.ok) {
          console.warn('[fetchAsset] fetch failed', resp && resp.status, urlPath);
          return null;
        }
        return resp;
      } catch (e) {
        console.error('[fetchAsset] error', e, urlPath);
        return null;
      }
    }

    /* -------------------- safe random loader (robust) -------------------- */
    async function loadRandomTuneToHumData() {
      try {
        const tunesJsonPath = buildRelativeForAsset('tunes.json?_=' + Date.now());
        console.log('[loadRandomTuneToHumData] requesting', tunesJsonPath);
        let listResp;
        try { listResp = await fetch(encodeURI(tunesJsonPath), { cache: 'no-cache' }); }
        catch (e) { console.error('[loadRandomTuneToHumData] fetch failed', e); return null; }
        if (!listResp || !listResp.ok) {
          console.warn('[loadRandomTuneToHumData] tunes.json missing', listResp && listResp.status);
          return null;
        }
        const listJson = await listResp.json();
        console.log('[loadRandomTuneToHumData] tunes.json content', listJson);

        let files = [];
        if (Array.isArray(listJson)) files = listJson.slice();
        else if (Array.isArray(listJson.files)) files = listJson.files.slice();
        else {
          console.warn('[loadRandomTuneToHumData] tunes.json has unexpected shape');
          return null;
        }
        if (!files.length) { console.warn('[loadRandomTuneToHumData] tunes.json empty'); return null; }
        const pick = files[Math.floor(Math.random() * files.length)];
        console.log('[loadRandomTuneToHumData] picked', pick);

        const fileResp = await fetchAsset(pick);
        if (!fileResp) { console.warn('[loadRandomTuneToHumData] file fetch failed'); return null; }
        const text = await fileResp.text();
        return { filename: pick, text };
      } catch (e) {
        console.error('[loadRandomTuneToHumData] unexpected error', e);
        return null;
      }
    }

    /* -------------------- initial file load -------------------- */
    let humData = "";
    let filename = null;

    try {
      const initial = await loadRandomTuneToHumData();
      if (initial) {
        filename = initial.filename;
        humData = initial.text;
        const meta = extractSecondSpineMeta(humData);
        const pillText = (meta.dir || meta.title || meta.number)
          ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
          : (filename || '—');
        document.getElementById('titleValue').textContent = pillText || (filename || '—');
      } else {
        document.getElementById('titleValue').textContent = '— (no tunes/list.json)';
      }
    } catch (e) { console.warn(e); }

    /* -------------------- verovio & base options -------------------- */
if (!(window.verovio && typeof verovio.toolkit === 'function')) {
  document.getElementById('svg').textContent = 'Verovio not loaded. Check script paths: verovio-toolkit-wasm.js and verovio-toolkit-hum.js';
  document.getElementById('humPanel').textContent = '##original humdrum file##\n' + (humData || '(empty)');
  return;
}

// instantiate verovio toolkit
const vrvToolkit = new verovio.toolkit();

const baseOptions = {
  scale: 50, pageWidth: 900, adjustPageHeight: true,
  spacingLinear: 0.50,
  spacingNonLinear: 0.50 * (0.46 / 0.32), // preserve ratio
  spacingSystem: 10, spacingStaff: 8
};
vrvToolkit.setOptions(baseOptions);


    /* -------------------- state -------------------- */
    let figuresAbove = false;
    let conventionsMode = 'historic';
    let currentSemitones = 0; // -6..+6 preferred
    let octaveShift = 0;      // integer, each = ±12 semitones displayed with prefix +/- 
    let currentScale = baseOptions.scale;
    let currentSpacingLinear = baseOptions.spacingLinear;
    let originalKeyIndex = null;
    let originalIsMajor = true;
    let originalAccidentalPref = '';

    // filters
    let maxDifficulty = 7;
    let filterAscending = true;
    let filterDescending = true;
    let filterMajor = true;
    let filterMinor = true;

    /* -------------------- figures helpers & parsing -------------------- */
    function normalizeAccRaw(acc) {
      if (!acc) return '';
      acc = acc.replace(/\s+/g, '');
      acc = acc.replace(/-/g, 'b');
      acc = acc.replace(/[\/\\]/g,'#');
      return acc;
    }
    function toHumdrumAcc(acc) {
      if (!acc) return '';
      acc = String(acc).replace(/♭/g,'b').replace(/♯/g,'#').replace(/b/g,'-');
      return acc;
    }

    function parseKernPitch(t) {
      if (!t) return null;
      const m = String(t).match(/([A-Ga-g])([#♯b♭-]{0,2})/);
      if (!m) return null;
      const letter = m[1].toUpperCase();
      let acc = m[2] || '';
      if (acc === '-') acc = 'b';
      if (acc === '--') acc = 'bb';
      const pc = (() => {
        if (!acc) return keyToIndex(letter, '');
        if (acc === '#' || acc === '♯') return keyToIndex(letter, '#');
        if (acc === 'b' || acc === '♭' || acc === '-') return keyToIndex(letter, 'b');
        if (acc === '##') return (LETTER_TO_INDEX[letter] + 2) % 12;
        if (acc === 'bb') return (LETTER_TO_INDEX[letter] + 10) % 12;
        return keyToIndex(letter, acc[0] || '');
      })();
      return { letter, acc, pc };
    }

    function accFromDesiredVsNatural(desiredPc, naturalPc, diatonicPc) {
      const diffNat = (desiredPc - naturalPc + 12) % 12;
      if (diffNat === 0) {
        if (diatonicPc !== naturalPc) return 'n';
        return '';
      }
      if (diffNat === 1) return '#';
      if (diffNat === 11) return 'b';
      if (diffNat === 2) return '##';
      if (diffNat === 10) return 'bb';
      return null;
    }

    /* -------------------- diatonic map (mode aware) -------------------- */
    const LETTERS = ['C','D','E','F','G','A','B'];
    const SCALE_OFFSETS_MAJOR = [0,2,4,5,7,9,11];
    const SCALE_OFFSETS_NAT_MINOR = [0,2,3,5,7,8,10];

    function findScaleMapFor(semitonesOffset) {
      if (typeof originalKeyIndex !== 'number' || originalKeyIndex === null) return null;
      const targetKeyIndex = (originalKeyIndex + semitonesOffset + 120) % 12;
      const tonicName = indexToTonic(targetKeyIndex, originalAccidentalPref) || 'C';
      const tonicLetter = tonicName[0].toUpperCase();
      const OFFSETS = originalIsMajor ? SCALE_OFFSETS_MAJOR : SCALE_OFFSETS_NAT_MINOR;
      const tonicLetterIdx = LETTERS.indexOf(tonicLetter);

      const map = {};
      for (let d = 0; d < 7; d++) {
        const letter = LETTERS[(tonicLetterIdx + d) % 7];
        const pc = (targetKeyIndex + OFFSETS[d]) % 12;
        map[letter] = pc;
      }
      return map;
    }

    function parseKeyInterpretation(hum) {
      const lines = hum.split(/\r?\n/);
      for (let ln of lines) {
        ln = ln.trim();
        const m = ln.match(/^\*([A-Ga-g])([#b♯♭-]?)\s*:/);
        if (m) {
          let acc = m[2] || '';
          if (acc === '-') acc = 'b';
          return { letter: m[1], accidental: acc };
        }
      }
      return null;
    }

    /* -------------------- prepareFiguredBassForTranspose -------------------- */
    function prepareFiguredBassForTranspose(humText, semitones) {
      if (!humText) return '';

      const lines = humText.split(/\r?\n/);

      // --------- discover spines (kern, fb, 3rd=actual, 4th=force-diatonic) ----------
      let headerBlockEnd = -1;
      let kernIndices = [];
      let fbIndex = null;
      let actualTextIndex = null;  // 3rd spine
      let forceTextIndex  = null;  // 4th spine

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const toks = (line.indexOf('\t') !== -1) ? line.split('\t') : line.split(/\s+/);

        if (toks.some(t => String(t).startsWith('**'))) {
          headerBlockEnd = i;

          // first/any **kern indices (we'll use the 1st as bass reference)
          for (let c = 0; c < toks.length; c++) {
            if (String(toks[c]).startsWith('**kern')) kernIndices.push(c);
          }

          // first **fb-like index
          for (let c = 0; c < toks.length; c++) {
            const t = String(toks[c]);
            if (t.startsWith('**fb') || t.startsWith('**fba') || t.startsWith('**fbb')) {
              if (fbIndex === null) fbIndex = c;
            }
          }

          // 3rd and 4th spines: first and second **text after **fb
          if (fbIndex !== null) {
            let foundFirst = false;
            for (let c = fbIndex + 1; c < toks.length; c++) {
              const t = String(toks[c]);
              if (t.startsWith('**text')) {
                if (!foundFirst) { actualTextIndex = c; foundFirst = true; }
                else { forceTextIndex = c; break; }
              }
            }
          }
        } else {
          if (headerBlockEnd >= 0) break;
        }
      }

      if (fbIndex === null) return humText;

      const preHeaderLines = lines.slice(0, headerBlockEnd + 1);
      const restLines      = lines.slice(headerBlockEnd + 1);

      // --------- global max numerals for alignment (from original fb column) ----------
      let globalMax = 0;
      for (const line of restLines) {
        if (!line) continue;
        const toks = (line.indexOf('\t') !== -1) ? line.split('\t') : line.split(/\s+/);
        const tok = toks[fbIndex];
        if (!tok || tok === '.' || /^[\*\=\!\|]/.test(tok)) continue;
        const parts = String(tok).trim().split(/\s+/).filter(Boolean);
        let numeralsCount = 0;
        for (const p of parts) {
          const digits = p.match(/\d+/g);
          numeralsCount += (digits ? digits.length : 0);
        }
        if (numeralsCount === 0 && parts.some(p => /\d/.test(p))) numeralsCount = 1;
        globalMax = Math.max(globalMax, numeralsCount);
      }

      // --------- target key map (major / natural minor) ----------
      const scalePCByLetter = findScaleMapFor(semitones);
      const scaleLettersByPc = scalePCByLetter
        ? Object.keys(scalePCByLetter).reduce((acc, L) => {
            const pc = scalePCByLetter[L];
            acc[pc] = acc[pc] || [];
            acc[pc].push(L);
            return acc;
          }, {})
        : null;

      // ===== Helpers (5a–5c logic) =====

      function pcNewBass(bassInfo) {
        // Keep newBassPc as the sounding pitch class only (for playback/transpose purposes).
        return (bassInfo.pc + semitones + 120) % 12;
      }

      /**
       * NEW: Determine the target diatonic letter for the given degree **preferentially by stepping
       * from the spelled bass letter**. This preserves spelling semantics: C# -> counts from C, Db -> counts from D.
       *
       * If bassLetterSpelled is unavailable, fallback to the old behavior that finds a bass letter by matching pc.
       */
      function targetLetterForDegree(newBassPc, degree, bassLetterSpelled) {
        // Prefer letter-stepping from spelled bass if provided
        if (bassLetterSpelled && typeof bassLetterSpelled === 'string') {
          const LETTERS7 = ['C','D','E','F','G','A','B'];
          const startIdx = LETTERS7.indexOf(bassLetterSpelled.toUpperCase());
          if (startIdx !== -1) {
            return LETTERS7[(startIdx + (degree - 1)) % 7];
          }
        }

        // Fallback: find a letter in the target key whose diatonic pc matches newBassPc
        if (!scalePCByLetter || !scaleLettersByPc) return null;

        let bassLetterInTargetKey = null;
        for (const L of Object.keys(scalePCByLetter)) {
          if (scalePCByLetter[L] === newBassPc) { bassLetterInTargetKey = L; break; }
        }
        if (!bassLetterInTargetKey) return null;

        const LETTERS7 = ['C','D','E','F','G','A','B'];
        const bassIdxInLetters = LETTERS7.indexOf(bassLetterInTargetKey);
        return LETTERS7[(bassIdxInLetters + (degree - 1)) % 7];
      }

      // PRINT ACCIDENTAL RELATIVE TO THE NATURAL LETTER (Step 6)
      function accidentalForDirection(targetLetter, direction) {
        if (!targetLetter || !scalePCByLetter) return null;
        const diatonicPc = scalePCByLetter[targetLetter];
        const naturalPc  = LETTER_TO_INDEX[targetLetter];
        let desiredPc    = diatonicPc;

        if (direction === '#' || /#[♯]/.test(direction)) desiredPc = (diatonicPc + 1) % 12;
        else if (direction === 'b' || /b/.test(direction)) desiredPc = (diatonicPc + 11) % 12;
        else if (direction === '##') desiredPc = (diatonicPc + 2) % 12;
        else if (direction === 'bb') desiredPc = (diatonicPc + 10) % 12;
        else if (/n/i.test(direction)) desiredPc = naturalPc;
        else desiredPc = diatonicPc;

        // relative to natural (so F## -> '##', Ab -> 'b', etc.)
        const finalAccSym = accFromDesiredVsNatural(desiredPc, naturalPc, diatonicPc);
        return finalAccSym; // '', 'n', '#', 'b', '##', 'bb', or null
      }

      // 4th spine: courtesy accidental for the *diatonic* pitch itself (always explicit)
      function accidentalForDiatonic(targetLetter) {
        if (!targetLetter || !scalePCByLetter) return null;
        const diatonicPc = scalePCByLetter[targetLetter];
        const naturalPc  = LETTER_TO_INDEX[targetLetter];
        const diff = (diatonicPc - naturalPc + 12) % 12;
        if (diff === 0)  return 'n';
        if (diff === 1)  return '#';
        if (diff === 11) return 'b';
        if (diff === 2)  return '##';
        if (diff === 10) return 'bb';
        return null;
      }

      function parseFigurePart(partRaw) {
        const s = String(partRaw).trim();
        const mNumAcc = s.match(/^([0-9]+)\s*([#♯b♭nN\-\/\\]+)?$/);
        if (mNumAcc) {
          const degree = parseInt(mNumAcc[1], 10);
          const accRaw = normalizeAccRaw(mNumAcc[2] || '');
          return { degree, acc: accRaw, accOnly: false, raw: s };
        }
        const mAccOnly = s.match(/^([#♯b♭nN\-\/\\]+)$/);
        if (mAccOnly) {
          const accRaw = normalizeAccRaw(mAccOnly[1] || '');
          return { degree: 3, acc: accRaw, accOnly: true, raw: s }; // D2
        }
        return null;
      }

      function parseForceDiatonicPart(partRaw) {
        let part = String(partRaw).trim();
        let trailingBar = '';
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }
        const m = part.match(/^([0-9]+)q$/i);
        if (!m) return null;
        return { degree: parseInt(m[1], 10), trailingBar };
      }

      function isHistoricalPassThroughToken(fullToken) {
        return (
          fullToken === '5-' ||
          fullToken === '4#|' ||
          /[\\\/]$/.test(fullToken) // slashed endings
        );
      }

      // ===== per-part processors =====

      // ---- NEW HELPER: build an ORIGINAL scale map (if original key known) ----
      // originalScalePCByLetter maps letters to pc for the SOURCE key (before transpose).
      // We can use originalKeyIndex & originalIsMajor from outer scope (globals).
      const ORIGINAL_OFFSETS = originalIsMajor ? SCALE_OFFSETS_MAJOR : SCALE_OFFSETS_NAT_MINOR;
      const originalScalePCByLetter = (typeof originalKeyIndex === 'number' && originalKeyIndex !== null)
        ? (function() {
            const map = {};
            // pick spelled tonic letter from the original key index if possible:
            const originalTonicName = indexToTonic(originalKeyIndex, originalAccidentalPref) || 'C';
            const tonicLetter = originalTonicName[0].toUpperCase();
            const tonicLetterIdx = LETTERS.indexOf(tonicLetter);
            for (let d = 0; d < 7; d++) {
              const letter = LETTERS[(tonicLetterIdx + d) % 7];
              map[letter] = (originalKeyIndex + ORIGINAL_OFFSETS[d]) % 12;
            }
            return map;
          })()
        : null;

      /**
       * Compute alteration offset (signed semitones) from the source (original)
       * Example: if in the source the diatonic pitch class for the degree was X,
       * and the actual desired sounding pitch was Y, return minimal signed offset:
       *   Y - X -> reduce to range -6..+6 (prefer -2,-1,0,1,2)
       *
       * Returns: integer (e.g. -2, -1, 0, 1, 2) OR null if cannot determine
       */
      function computeAlterationOffsetFromSource(parsedAcc, degree, bassInfo) {
        // If there is no explicit accidental token in the source (parsedAcc empty), treat as 0.
        if (!parsedAcc || !bassInfo || typeof bassInfo.pc !== 'number') {
          // parsedAcc might be empty string meaning "no chromatic info" -> return null so caller preserves numeral only
          if (!parsedAcc) return null;
          // otherwise fall through (but parsedAcc might be like '#' etc.)
        }

        // If we don't have originalScalePCByLetter, we cannot compute source diatonic pc robustly.
        if (!originalScalePCByLetter) {
          // as fallback: interpret parsedAcc symbol as +/-1 or +/-2 semitones
          const norm = normalizeAccRaw(parsedAcc || '');
          if (/^##?$/.test(norm)) return (norm.length === 2) ? +2 : +1;
          if (/^bb?$/.test(norm)) return (norm.length === 2) ? -2 : -1;
          if (/^n$/i.test(norm)) return 0;
          return null;
        }

        // Determine the spelled source target letter by stepping diatonically from spelled bass
        const sourceTargetLetter = targetLetterForDegree(bassInfo.pc, degree, bassInfo.letter);
        if (!sourceTargetLetter) return null;

        const sourceDiatonicPc = originalScalePCByLetter[sourceTargetLetter];
        if (typeof sourceDiatonicPc !== 'number') return null;

        // desired sounding pc in source: derive from parsedAcc if explicit, or if parsed.accOnly we must
        // interpret it relative to the actual sounding pitch where possible. For historical fb (no actual spine),
        // the token may be 6# meaning diatonic + 1.
        // For a robust approach, compute desiredPc by applying the parsed acc to the diatonic pc.
        let desiredPc;
        const norm = normalizeAccRaw(parsedAcc || '');
        if (!norm) {
          // no alteration written -> same as diatonic
          desiredPc = sourceDiatonicPc;
        } else if (/^n$/i.test(norm)) {
          desiredPc = LETTER_TO_INDEX[sourceTargetLetter]; // forced natural
        } else if (norm === '#') {
          desiredPc = (sourceDiatonicPc + 1) % 12;
        } else if (norm === 'b') {
          desiredPc = (sourceDiatonicPc + 11) % 12;
        } else if (norm === '##') {
          desiredPc = (sourceDiatonicPc + 2) % 12;
        } else if (norm === 'bb') {
          desiredPc = (sourceDiatonicPc + 10) % 12;
        } else {
          // fallback: try to guess from first char
          if (norm[0] === '#') desiredPc = (sourceDiatonicPc + 1) % 12;
          else if (norm[0] === 'b' || norm[0] === '-') desiredPc = (sourceDiatonicPc + 11) % 12;
          else if (/n/i.test(norm[0])) desiredPc = LETTER_TO_INDEX[sourceTargetLetter];
          else return null;
        }

        // compute minimal signed difference desiredPc - sourceDiatonicPc in -6..+6
        let diff = (desiredPc - sourceDiatonicPc + 12) % 12;
        if (diff > 6) diff = diff - 12;
        return diff;
      }

      // PRINT ACCIDENTAL RELATIVE TO THE NATURAL LETTER (Step 6) — *unchanged* but we'll use it after applying offset
      function accidentalForDesiredPc(targetLetter, desiredPc, allowNaturalPreserve) {
        if (!targetLetter || !scalePCByLetter) return null;
        const naturalPc  = LETTER_TO_INDEX[targetLetter];
        const diatonicPc = scalePCByLetter[targetLetter]; // diatonic in target key
        // now compare desiredPc to naturalPc (not diatonicPc) for final symbol
        const finalAccSym = accFromDesiredVsNatural(desiredPc, naturalPc, diatonicPc);
        // preserve explicit natural if requested (allowNaturalPreserve true and finalAccSym === '')
        if (allowNaturalPreserve && finalAccSym === 'n') return 'n';
        return finalAccSym;
      }

      function parseFigurePart(partRaw) {
        const s = String(partRaw).trim();
        const mNumAcc = s.match(/^([0-9]+)\s*([#♯b♭nN\-\/\\]+)?$/);
        if (mNumAcc) {
          const degree = parseInt(mNumAcc[1], 10);
          const accRaw = normalizeAccRaw(mNumAcc[2] || '');
          return { degree, acc: accRaw, accOnly: false, raw: s };
        }
        const mAccOnly = s.match(/^([#♯b♭nN\-\/\\]+)$/);
        if (mAccOnly) {
          const accRaw = normalizeAccRaw(mAccOnly[1] || '');
          return { degree: 3, acc: accRaw, accOnly: true, raw: s }; // D2
        }
        return null;
      }

      function parseForceDiatonicPart(partRaw) {
        let part = String(partRaw).trim();
        let trailingBar = '';
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }
        const m = part.match(/^([0-9]+)q$/i);
        if (!m) return null;
        return { degree: parseInt(m[1], 10), trailingBar };
      }

      function isHistoricalPassThroughToken(fullToken) {
        return (
          fullToken === '5-' ||
          fullToken === '4#|' ||
          /[\\\/]$/.test(fullToken) // slashed endings
        );
      }

      // ===== per-part processors (reworked to preserve semitone offset from source) =====

      function processFbPartHistorical(partRaw, kernTok) {
        if (!partRaw || /^[\*\=\!\|]/.test(partRaw) || partRaw === '.') return partRaw;

        const fullToken = String(partRaw);
        if (isHistoricalPassThroughToken(fullToken)) return fullToken;  // D1

        let trailingBar = '';
        let part = fullToken;
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }

        const parsed = parseFigurePart(part);
        if (!parsed) return fullToken;

        if (!parsed.acc && !parsed.accOnly) return String(parsed.degree) + trailingBar;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        // Compute the semitone alteration offset as it existed in the SOURCE
        const alterationOffset = computeAlterationOffsetFromSource(parsed.acc, parsed.degree, bassInfo);
        // Determine the target letter in the TRANSPOSED key by stepping from spelled new bass
        const newBassPc = pcNewBass(bassInfo);
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree, bassInfo.letter);
        if (!targetLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        // If we couldn't compute alterationOffset, fall back to previous behavior (interpret parsed.acc as direction)
        if (alterationOffset === null) {
          const finalAccSym = accidentalForDirection(targetLetter, parsed.acc);
          if (finalAccSym === null) {
            return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
          }
          return parsed.accOnly
            ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
            : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
        }

        // Apply the same signed alterationOffset to the TARGET diatonic pitch
        const targetDiatonicPc = scalePCByLetter[targetLetter];
        const desiredPcTarget = (targetDiatonicPc + alterationOffset + 120) % 12;

        const finalAccSym = accidentalForDesiredPc(targetLetter, desiredPcTarget, false);
        if (finalAccSym === null) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }
        return parsed.accOnly
          ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
          : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
      }

      function processFbPartActual(partFromActualSpine, kernTok) {
        if (!partFromActualSpine || /^[\*\=\!\|]/.test(partFromActualSpine) || partFromActualSpine === '.') return partFromActualSpine;

        let trailingBar = '';
        let part = String(partFromActualSpine);
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }

        const parsed = parseFigurePart(part);
        if (!parsed) return partFromActualSpine;

        // Numeral with NO accidental: keep numeral unchanged (no chromatic info to carry)
        if (!parsed.acc && !parsed.accOnly) return String(parsed.degree) + trailingBar;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          // No context – preserve literal (normalize to humdrum)
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        // Compute alteration offset in SOURCE
        const alterationOffset = computeAlterationOffsetFromSource(parsed.acc, parsed.degree, bassInfo);
        const newBassPc    = pcNewBass(bassInfo); // sound-only
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree, bassInfo.letter);
        if (!targetLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        if (alterationOffset === null) {
          // fallback: preserve original behavior, including preserving explicit 'n'
          let finalAccSym = accidentalForDirection(targetLetter, parsed.acc);
          if (finalAccSym === null) {
            return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
          }
          if (finalAccSym === '' && /n/i.test(parsed.acc)) finalAccSym = 'n';
          return parsed.accOnly
            ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
            : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
        }

        // apply alteration offset to target diatonic
        const targetDiatonicPc = scalePCByLetter[targetLetter];
        const desiredPcTarget = (targetDiatonicPc + alterationOffset + 120) % 12;
        let finalAccSym = accidentalForDesiredPc(targetLetter, desiredPcTarget, /n/i.test(parsed.acc));
        if (finalAccSym === null) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }
        // preserve explicit natural token from actual spine even if computed '':
        if (finalAccSym === '' && /n/i.test(parsed.acc)) finalAccSym = 'n';

        return parsed.accOnly
          ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
          : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
      }

      function processForceDiatonicPart(partFromForceSpine, kernTok) {
        if (!partFromForceSpine || /^[\*\=\!\|]/.test(partFromForceSpine) || partFromForceSpine === '.') return partFromForceSpine;

        let trailingBar = '';
        let token = String(partFromForceSpine);
        if (token.endsWith('|')) { trailingBar = '|'; token = token.slice(0, -1); }

        const parsed = parseForceDiatonicPart(token);
        if (!parsed) return partFromForceSpine;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          return String(parsed.degree) + 'n' + trailingBar; // safest courtesy
        }
        const newBassPc    = pcNewBass(bassInfo); // sound-only
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree, bassInfo.letter);
        if (!targetLetter) {
          return String(parsed.degree) + 'n' + trailingBar;
        }

        const diatonicAcc = accidentalForDiatonic(targetLetter); // '#','b','n','##','bb'
        const outAcc = diatonicAcc || 'n';
        return String(parsed.degree) + toHumdrumAcc(outAcc) + trailingBar;
      }

      // ===== process body lines =====

      let lastKernTokForBass = null;

      const processedRest = restLines.map(line => {
        if (!line) return line;
        const useTabs = line.indexOf('\t') !== -1;
        const toks = useTabs ? line.split('\t') : line.split(/\s+/);

        // handle header-like lines inside body
        if (toks.some(t => String(t).startsWith('**'))) {
          return useTabs ? toks.join('\t') : toks.join(' ');
        }

        const maxIdxToEnsure = Math.max(
          fbIndex,
          ...(kernIndices || [-1]),
          (actualTextIndex ?? -1),
          (forceTextIndex  ?? -1)
        );
        while (toks.length <= maxIdxToEnsure) toks.push('.');

        // carry-forward bass
        const kernTokRaw = (kernIndices && kernIndices.length) ? toks[kernIndices[0]] : null;
        const parsedBassNow = parseKernPitch(kernTokRaw);
        if (parsedBassNow && typeof parsedBassNow.pc === 'number') {
          lastKernTokForBass = kernTokRaw;
        }
        const kernTok = (parsedBassNow && typeof parsedBassNow.pc === 'number')
          ? kernTokRaw
          : lastKernTokForBass;

        // pick sources with precedence: 4th (always) > 3rd (if Actual) > 2nd
        const fbTokSrc  = toks[fbIndex];
        const forceTok  = (forceTextIndex  != null) ? toks[forceTextIndex] : null;
        const actualTok = (conventionsMode === 'modern' && actualTextIndex != null) ? toks[actualTextIndex] : null;

        let processedParts = null;

        if (forceTok && !/^[\*\=\!\|]/.test(forceTok) && forceTok !== '.') {
          const parts = String(forceTok).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processForceDiatonicPart(p, kernTok));
        } else if (actualTok && !/^[\*\=\!\|]/.test(actualTok) && actualTok !== '.') {
          const parts = String(actualTok).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processFbPartActual(p, kernTok));
        } else if (fbTokSrc && !/^[\*\=\!\|]/.test(fbTokSrc) && fbTokSrc !== '.') {
          const parts = String(fbTokSrc).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processFbPartHistorical(p, kernTok));
        }

        if (processedParts && processedParts.length) {
          let numeralsNow = processedParts.reduce((acc, p) =>
            acc + ((String(p).match(/\d+/g) || []).length || (/\d/.test(p) ? 1 : 0)), 0);
          if (numeralsNow === 0 && processedParts.some(p => /\d/.test(p))) numeralsNow = 1;
          const need = Math.max(0, globalMax - Math.max(1, numeralsNow));

          toks[fbIndex] = (figuresAbove && need > 0)
            ? (Array(need).fill('x').join(' ') + ' ' + processedParts.join(' ')).trim()
            : processedParts.join(' ');
        }

        // NEUTRALIZE helper spines on DATA rows only (preserve * / = / ! / |)
        function neutralizeHelperToken(tok) {
          if (!tok) return '.';
          if (/^[\*\=\!|]/.test(tok)) return tok; // keep interpretations, barlines, comments, '|' separators
          return '.';
        }
        if (actualTextIndex != null) toks[actualTextIndex] = neutralizeHelperToken(toks[actualTextIndex]);
        if (forceTextIndex  != null) toks[forceTextIndex]  = neutralizeHelperToken(toks[forceTextIndex]);

        return useTabs ? toks.join('\t') : toks.join(' ');
      });

      // header rewrite (figures-above + neutralize helper spine headers)
      const processedHeader = preHeaderLines.map(hl => {
        if (!hl) return hl;
        const useTabs = hl.indexOf('\t') !== -1;
        const toks = useTabs ? hl.split('\t') : hl.split(/\s+/);

        // Convert **fb -> **fba only if figuresAbove
        if (figuresAbove) {
          for (let c = 0; c < toks.length; c++) {
            if (String(toks[c]).startsWith('**fb') && !String(toks[c]).startsWith('**fba')) {
              toks[c] = String(toks[c]).replace(/^\*\*fb/, '**fba');
            }
          }
        }
        // Neutralize **text headers for helper spines
        for (let c = 0; c < toks.length; c++) {
          if (actualTextIndex != null && c === actualTextIndex && String(toks[c]).startsWith('**text')) {
            toks[c] = '**text-hidden';
          }
          if (forceTextIndex  != null && c === forceTextIndex  && String(toks[c]).startsWith('**text')) {
            toks[c] = '**text-hidden';
          }
        }

        return useTabs ? toks.join('\t') : toks.join(' ');
      });

      const finalLines = [];
      processedHeader.forEach(hl => finalLines.push(hl));
      processedRest.forEach(rl => finalLines.push(rl));
      return finalLines.join('\n');
    }

    /* -------------------- render & helpers -------------------- */
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function tonicDisplayWithGlyphs(s) { if (!s) return s; return String(s).replace(/#/g, '♯').replace(/b/g, '♭'); }
    function indexToTonicDisplay(idx) { return tonicDisplayWithGlyphs(indexToTonic((idx+12)%12, originalAccidentalPref)); }

    function renderWithTranspose() {
      const humPanelEl = document.getElementById('humPanel');

      // Always run the preparation pass so 4th spine can override even with 0 transpose
      const preparedHum = prepareFiguredBassForTranspose(humData || "", currentSemitones);

      const semText = String(currentSemitones || 0);
      const actualAccLine = '##Actual Accidentals=' + (conventionsMode === 'modern' ? 'TRUE' : 'FALSE');

      // --- NEW: compute a clear "target key" string to show in the hum panel ---
      let targetKeyStr = '';
      if (originalKeyIndex !== null) {
        const displayIdx = (originalKeyIndex + currentSemitones + 120) % 12;
        const tonicRaw = displayTonicOverride ? displayTonicOverride : indexToTonic(displayIdx, originalAccidentalPref);
        const tonic = tonicDisplayWithGlyphs(tonicRaw);
        const modeText = originalIsMajor ? ' major' : ' minor';
        if (octaveShift !== 0) {
          const octaveText = octaveShift > 0 ? " 8va↑ (" + String(octaveShift) + ")" : " 8va↓ (" + String(octaveShift) + ")";
          targetKeyStr = tonic + modeText + octaveText;
        } else {
          targetKeyStr = tonic + modeText;
        }
      } else {
        if (currentSemitones === 0 && octaveShift === 0) {
          targetKeyStr = "original";
        } else {
          const totalSem = currentSemitones + (octaveShift * 12);
          targetKeyStr = "transposed " + String(totalSem) + " st";
        }
      }

      const panelContent = [
        '##original humdrum file##',
        humData || '(empty)',
        '##currently displayed humdrum##',
        '##transpose ' + semText + ' semitones',
        actualAccLine,
        '##target key=' + targetKeyStr,
        preparedHum || '(empty)'
      ].join('\n\n');
      if (humPanelEl) humPanelEl.textContent = panelContent;

    // spacing-aware options: use viewer width if available, guard missing base values, cap extremes
const baseLinear = baseOptions.spacingLinear || 0.32;
const spacingNonLinearRatio =
  (baseOptions.spacingNonLinear && baseOptions.spacingLinear)
    ? baseOptions.spacingNonLinear / baseOptions.spacingLinear
    : 1;

const scaleFactor = currentSpacingLinear / baseLinear;

// give Verovio more horizontal room as spacing grows
const pageWidth =
  Math.round(baseOptions.pageWidth * Math.max(1, scaleFactor * 1.5));

const options = {
  ...baseOptions,
  scale: currentScale,
  spacingLinear: currentSpacingLinear,
  spacingNonLinear: currentSpacingLinear * spacingNonLinearRatio,
  pageWidth
};


           // Choose a suitable transpose option for Verovio.
      // If we know the original key (originalKeyIndex), request transposition by target tonic (keeps key-based spellings).
      // Otherwise request chromatic semitone transposition (integer), which works even if input lacks key info.
      let transposeOption = "";
      if (originalKeyIndex !== null) {
        const displayIdx = (originalKeyIndex + currentSemitones + 120) % 12;
        const tonicRaw = displayTonicOverride ? displayTonicOverride : indexToTonic(displayIdx, originalAccidentalPref);
        const prefix = octaveShift > 0 ? "+".repeat(octaveShift) : octaveShift < 0 ? "-".repeat(-octaveShift) : "";
        // Example: "+Gb" or "C"
        transposeOption = prefix + (tonicRaw || "");
      } else {
        // When no key info is available in the input, fall back to semitone transposition.
        // Verovio accepts an integer string (e.g. "1", "-1") to mean chromatic semitone steps.
        if (currentSemitones !== 0 || octaveShift !== 0) {
          // include octaveShift as additional 12-semitone steps:
          const totalSemitones = currentSemitones + (octaveShift * 12);
          transposeOption = String(totalSemitones);
        } else {
          transposeOption = ""; // no transpose
        }
      }
      options.transpose = transposeOption;

      // Status text for the UI:
      if (originalKeyIndex !== null) {
        const displayIdx = (originalKeyIndex + currentSemitones + 120) % 12;
        const tonicRaw = displayTonicOverride ? displayTonicOverride : indexToTonic(displayIdx, originalAccidentalPref);
        const tonic = tonicDisplayWithGlyphs(tonicRaw);
        const modeText = originalIsMajor ? ' major' : ' minor';
        if (octaveShift !== 0) {
          const octaveText = octaveShift > 0 ? " 8va↑ (" + String(octaveShift) + ")" : " 8va↓ (" + String(octaveShift) + ")";
          document.getElementById('statusKey').textContent = tonic + modeText + octaveText;
        } else {
          document.getElementById('statusKey').textContent = tonic + modeText;
        }
      } else {
        if (currentSemitones === 0 && octaveShift === 0) {
          document.getElementById('statusKey').textContent = "original";
        } else {
          const totalSem = currentSemitones + (octaveShift * 12);
          document.getElementById('statusKey').textContent = "transposed " + String(totalSem) + " st";
        }
      }


      vrvToolkit.setOptions(options);
      try {
        const svg = vrvToolkit.renderData(preparedHum, {});
        document.getElementById('svg').innerHTML = svg;
        document.getElementById('scaleBadge').textContent = String(currentScale);
        document.getElementById('spacingBadge').textContent = currentSpacingLinear.toFixed(2);
        document.getElementById('maxBadge').textContent = String(maxDifficulty);
      } catch (e) {
        document.getElementById('svg').textContent = "Render error: " + (e && e.message ? e.message : String(e));
        console.error(e);
      }
    }

    /* -------------------- UI wiring -------------------- */
    document.getElementById('halfUpBtn').addEventListener('click', ()=>{ currentSemitones += 1; displayTonicOverride = null; renderWithTranspose(); });
    document.getElementById('halfDownBtn').addEventListener('click', ()=>{ currentSemitones -= 1; displayTonicOverride = null; renderWithTranspose(); });
    document.getElementById('enharmonicBtn').addEventListener('click', ()=>{ toggleEnharmonicDisplay(); });

    // Octave buttons: immediate +/-12 semitones
    document.getElementById('octUpBtn').addEventListener('click', ()=>{ octaveShift += 1; renderWithTranspose(); });
    document.getElementById('octDownBtn').addEventListener('click', ()=>{ octaveShift -= 1; renderWithTranspose(); });

    document.getElementById('musicPlusBtn').addEventListener('click', () => { currentScale = clamp(currentScale + 2, 30, 200); renderWithTranspose(); });
    document.getElementById('musicMinusBtn').addEventListener('click', () => { currentScale = clamp(currentScale - 2, 30, 200); renderWithTranspose(); });
    document.getElementById('spacingPlusBtn').addEventListener('click', () => { currentSpacingLinear = clamp(currentSpacingLinear + 0.01, 0.20, 0.99); renderWithTranspose(); });
    document.getElementById('spacingMinusBtn').addEventListener('click', () => { currentSpacingLinear = clamp(currentSpacingLinear - 0.01, 0.20, 0.99); renderWithTranspose(); });
    document.getElementById('scaleResetBtn').addEventListener('click', ()=>{ currentScale = baseOptions.scale; renderWithTranspose(); });
    document.getElementById('spacingResetBtn').addEventListener('click', ()=>{ currentSpacingLinear = baseOptions.spacingLinear; renderWithTranspose(); });
    document.getElementById('scaleSlider').addEventListener('input', (e)=>{ currentScale = clamp(Number(e.target.value),30,200); renderWithTranspose(); });
    document.getElementById('spacingSlider').addEventListener('input', (e)=>{ currentSpacingLinear = clamp(Number(e.target.value),0.20,0.99); renderWithTranspose(); });

    // Accidentals radios
    const convHist = document.getElementById('conv_historic');
    const convMod = document.getElementById('conv_modern');
    if (convHist) convHist.addEventListener('change', (e)=>{ if (e.target.checked){ conventionsMode = 'historic'; renderWithTranspose(); }});
    if (convMod) convMod.addEventListener('change', (e)=>{ if (e.target.checked){ conventionsMode = 'modern'; renderWithTranspose(); }});

    // Figured-bass placement radio
    const rbBelow = document.getElementById('figBelow');
    const rbAbove = document.getElementById('figAbove');
    if (rbBelow) rbBelow.addEventListener('change', (e)=>{ if (e.target.checked){ figuresAbove = false; renderWithTranspose(); }});
    if (rbAbove) rbAbove.addEventListener('change', (e)=>{ if (e.target.checked){ figuresAbove = true; renderWithTranspose(); }});

    /* -------------------- Key range & Exclude UI -------------------- */
    const keyRangeButtons = new Map();
    const accidentalsSelected = new Set([0,1,2,3,4,5,6,7]);
    function addAccidentalRangeButtons(topId, bottomId){
      const top = document.getElementById(topId), bot = document.getElementById(bottomId);
      for (let n=0;n<=7;n++){
        const btn = document.createElement('button');
        btn.type='button';
        btn.className = 'range-btn' + (accidentalsSelected.has(n)?' active':'');
        btn.textContent = `${n}#/${n}♭`;
        btn.addEventListener('click', ()=>{ if (accidentalsSelected.has(n)){ accidentalsSelected.delete(n); btn.classList.remove('active'); } else { accidentalsSelected.add(n); btn.classList.add('active'); } });
        (n<=3?top:bot).appendChild(btn);
        keyRangeButtons.set(n, btn);
      }
      document.getElementById('keysAllBtn').addEventListener('click', ()=>{ for (let n=0;n<=7;n++){ accidentalsSelected.add(n); keyRangeButtons.get(n)?.classList.add('active'); }});
      document.getElementById('keysNoneBtn').addEventListener('click', ()=>{ for (let n=0;n<=7;n++){ accidentalsSelected.delete(n); keyRangeButtons.get(n)?.classList.remove('active'); }});
    }

    const excludeTonics = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B","Cb"];
    function addExcludeCheckboxes(containerId, values){
      const row = document.getElementById(containerId);
      values.forEach(val=>{
        const id = `${containerId}_${String(val).replace(/[^A-Za-z0-9]/g,'_')}`;
        const label = document.createElement('label'); label.className = 'chk-label';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.id = id; cb.value = val; cb.checked = false;
        const span = document.createElement('span'); span.textContent = val.replace(/#/g,"♯").replace(/b/g,"♭");
        label.appendChild(cb); label.appendChild(span); row.appendChild(label);
      });
    }

    document.getElementById('exAllBtn').addEventListener('click', ()=>{ document.querySelectorAll('#exRow input[type="checkbox"]').forEach(el=>el.checked=true); });
    document.getElementById('exNoneBtn').addEventListener('click', ()=>{ document.querySelectorAll('#exRow input[type="checkbox"]').forEach(el=>el.checked=false); });

    function getExcludedTonicsSet() {
      const s = new Set();
      document.querySelectorAll('#exRow input[type="checkbox"]').forEach(cb=>{
        if (cb.checked) s.add(tonicNameNormalized(cb.value));
      });
      return s;
    }

    /* -------------------- initial setup & render -------------------- */
    addAccidentalRangeButtons("keysRangeRowTop","keysRangeRowBottom");
    addExcludeCheckboxes("exRow", excludeTonics);
   /* document.getElementById('titleValue').textContent = filename || '—'; */

    /* -------------------- Asc/Desc, Major/Minor, Max difficulty -------------------- */
    const ascBtn = document.getElementById('filterAscBtn');
    const descBtn = document.getElementById('filterDescBtn');
    ascBtn.addEventListener('click', ()=>{ filterAscending = !filterAscending; ascBtn.classList.toggle('active', filterAscending); });
    descBtn.addEventListener('click', ()=>{ filterDescending = !filterDescending; descBtn.classList.toggle('active', filterDescending); });

    const majorBtn = document.getElementById('filterMajorBtn');
    const minorBtn = document.getElementById('filterMinorBtn');
    majorBtn.addEventListener('click', ()=>{ filterMajor = !filterMajor; majorBtn.classList.toggle('active', filterMajor); });
    minorBtn.addEventListener('click', ()=>{ filterMinor = !filterMinor; minorBtn.classList.toggle('active', filterMinor); });

    const maxMinusBtn = document.getElementById('maxMinusBtn');
    const maxPlusBtn = document.getElementById('maxPlusBtn');
    const maxBadge = document.getElementById('maxBadge');
    const maxRange = document.getElementById('maxRange');
    function setMaxDifficulty(v) { maxDifficulty = clamp(Number(v),1,7); maxBadge.textContent = String(maxDifficulty); maxRange.value = String(maxDifficulty); }
    maxMinusBtn.addEventListener('click', ()=> setMaxDifficulty(maxDifficulty - 1));
    maxPlusBtn.addEventListener('click', ()=> setMaxDifficulty(maxDifficulty + 1));
    maxRange.addEventListener('input', (e)=> setMaxDifficulty(e.target.value));
    setMaxDifficulty(7);

    /* -------------------- Candidate selection logic (7#/7b handled) -------------------- */

    const SAFE_TONICS_MAJOR = {
      0:  ['C'],
      1:  ['C#','Db'],
      2:  ['D'],
      3:  ['D#','Eb'],
      4:  ['E','Fb'],
      5:  ['F'],
      6:  ['F#','Gb'],
      7:  ['G'],
      8:  ['G#','Ab'],
      9:  ['A'],
      10: ['A#','Bb'],
      11: ['B','Cb']
    };

    const ACCIDENTAL_COUNT = {
      'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6, 'C#': 7,
      'F': 1, 'Bb': 2, 'Eb': 3, 'Ab': 4, 'Db': 5, 'Gb': 6, 'Cb': 7,
      'A#': 7, 'G#': 6, 'D#': 3
    };

    // Strict: collect counts for index
    function countsForIndexCandidates(idx) {
      const cand = SAFE_TONICS_MAJOR[idx] || [];
      const counts = new Set();
      for (const name of cand) {
        const norm = tonicNameNormalized(name);
        if (norm in ACCIDENTAL_COUNT) counts.add(ACCIDENTAL_COUNT[norm]);
      }
      return Array.from(counts);
    }

    /**
     * Pick a display name for the given index.
     * - preferredCounts is a Set of accidental counts the user has selected (e.g. {7})
     * - If any spellings match preferredCounts, pick randomly among those.
     * - Otherwise, pick randomly among spellings whose accidental-count <= 7.
     * - If none of the spellings have a known accidental-count, fall back to a canonical name.
     */
    function pickDisplayNameForIndexByAccCount(idx, preferredCounts /* Set */) {
      const names = SAFE_TONICS_MAJOR[idx] || [];
      // collect spellings with known counts
      const withCount = names.map(n => {
        const norm = tonicNameNormalized(n);
        const cnt = (norm in ACCIDENTAL_COUNT) ? ACCIDENTAL_COUNT[norm] : null;
        return { raw: n, norm, cnt };
      });

      // 1) prefer spellings that match the user's selected buckets
      const preferred = withCount.filter(x => x.cnt !== null && preferredCounts.has(x.cnt)).map(x => x.raw);
      if (preferred.length) return preferred[Math.floor(Math.random() * preferred.length)];

      // 2) otherwise use any spelling that is not "theoretical" (>7 accidentals)
      const nonTheoretical = withCount.filter(x => x.cnt !== null && x.cnt <= 7).map(x => x.raw);
      if (nonTheoretical.length) return nonTheoretical[Math.floor(Math.random() * nonTheoretical.length)];

      // 3) fallback: return any name (maybe unknown) or indexToTonic
      if (names.length) return names[Math.floor(Math.random() * names.length)];
      return indexToTonic(idx, '');
    }
// Return true if this pitch-class index has at least one MAJOR spelling
// with <= 7 accidentals. Blocks theoretical major keys like G# major, A# major.
// Helper: ensure an index can be a practical MAJOR key (some spelling <= 7 accidentals)
function isMajorKeyAllowedForIndex(idx) {
  const cand = SAFE_TONICS_MAJOR[idx] || [];
  for (const n of cand) {
    const norm = tonicNameNormalized(n);
    if (norm in ACCIDENTAL_COUNT && ACCIDENTAL_COUNT[norm] <= 7) {
      return true;
    }
  }
  return false;
}

async function pickRandomTuneAndTranspose() {
  const tunesJsonPath = buildRelativeForAsset('tunes.json?_=' + Date.now());
  let listResp;
  try { listResp = await fetch(encodeURI(tunesJsonPath), { cache: 'no-cache' }); }
  catch (e) { console.error('[pickRandomTuneAndTranspose] fetch failed', e); return null; }
  if (!listResp || !listResp.ok) {
    console.warn('[pickRandomTuneAndTranspose] tunes.json not available', listResp && listResp.status);
    return null;
  }

  const listJson = await listResp.json();
  const files = Array.isArray(listJson) ? listJson.slice() : (Array.isArray(listJson.files) ? listJson.files.slice() : []);
  if (!files.length) { console.warn('[pickRandomTuneAndTranspose] no files listed'); return null; }

  const candidates = [];
  for (const f of files) {
    try {
      const fr = await fetchAsset(f);
      if (!fr || !fr.ok) { console.warn('[pickRandomTuneAndTranspose] skipping missing', f); continue; }
      const text = await fr.text();
      const meta = extractSecondSpineMeta(text || '');
      const dir = (meta.dir || '').toLowerCase();

      const isAsc = /\bascend/.test(dir);
      const isDesc = /\bdescend/.test(dir);

      if (!filterAscending && isAsc) continue;
      if (!filterDescending && isDesc) continue;

      const num = parseInt((meta.number || '').toString().replace(/[^\d]/g,''), 10);
      if (!isNaN(num) && num > maxDifficulty) continue;
      if (isNaN(num) && maxDifficulty < 7) continue;

      const k = parseKeyInterpretation(text || '');
      if (!k) continue;
      const idx = keyToIndex(k.letter, k.accidental);
      const isMajor = (k.letter === k.letter.toUpperCase());
      if (!filterMajor && isMajor) continue;
      if (!filterMinor && !isMajor) continue;

      candidates.push({ filename: f, text, original: { index: idx, isMajor, tonic: indexToTonic(idx, '') }, meta });
    } catch (e) { console.warn('[pickRandomTuneAndTranspose] error reading', f, e); }
  }

  if (!candidates.length) return null;

  const sourcePick = candidates[Math.floor(Math.random() * candidates.length)];

  // Make sure buckets are numeric (defensive)
  const accidentalSet = new Set(Array.from(accidentalsSelected).map(x => Number(x)).filter(n => !Number.isNaN(n)));
  const excluded = getExcludedTonicsSet();
  const possibleTargets = [];

  for (let idx = 0; idx < 12; idx++) {
    // GLOBAL: block theoretical MAJOR keys such as G# major or A# major
    if (!isMajorKeyAllowedForIndex(idx)) {
      console.debug('[pick] skipping idx (theoretical major):', idx, SAFE_TONICS_MAJOR[idx]);
      continue;
    }

    const names = SAFE_TONICS_MAJOR[idx] || [];
    const nameInfos = names.map(n => {
      const norm = tonicNameNormalized(n);
      const cnt = (norm in ACCIDENTAL_COUNT) ? ACCIDENTAL_COUNT[norm] : null;
      return { raw: n, norm, cnt };
    });

    // Determine which signature-counts to check: major vs relative-minor mapping
    const countsMajor = countsForIndexCandidates(idx);
    const countsMinor = countsForIndexCandidates((idx + 3) % 12);

    // If user wants to preserve mode of source, check appropriate bucket — but even if not,
    // we'll still enforce accidentalSet matching later on the validSpellings.
    const countsToCheck = sourcePick.original.isMajor ? countsMajor : countsMinor;

    // If the user has ticked specific accidental buckets, require the index to expose one of those counts
    if (accidentalSet.size > 0) {
      const hasBucketMatch = countsToCheck.some(c => accidentalSet.has(Number(c)));
      if (!hasBucketMatch) {
        console.debug('[pick] idx', idx, 'no bucket match (countsToCheck):', countsToCheck, 'accSet:', Array.from(accidentalSet));
        continue;
      }
    }

    // Exclude tonics explicitly excluded by user
    const anyExcluded = nameInfos.some(n => excluded.has(n.norm));
    if (anyExcluded) {
      console.debug('[pick] idx', idx, 'excluded by user:', nameInfos.map(n=>n.norm));
      continue;
    }

    // Only keep spellings that are non-theoretical (<=7)
    const validSpellings = nameInfos.filter(n => n.cnt !== null && n.cnt <= 7);
    if (!validSpellings.length) {
      console.debug('[pick] idx', idx, 'no non-theoretical spellings', nameInfos);
      continue;
    }

    // If user bucketed, at least one valid spelling must match a bucket
    if (accidentalSet.size > 0) {
      const matchesBucket = validSpellings.some(n => accidentalSet.has(Number(n.cnt)));
      if (!matchesBucket) {
        console.debug('[pick] idx', idx, 'valid spellings but none match bucket', validSpellings.map(v=>v.raw));
        continue;
      }
    }

    possibleTargets.push({ idx, validSpellings });
  }

  // fallback: relax bucket constraint but still respect theoretical-major guard & exclusions
  if (!possibleTargets.length) {
    for (let idx = 0; idx < 12; idx++) {
      const names = SAFE_TONICS_MAJOR[idx] || [];
      const nameInfos = names.map(n => {
        const norm = tonicNameNormalized(n);
        const cnt = (norm in ACCIDENTAL_COUNT) ? ACCIDENTAL_COUNT[norm] : null;
        return { raw: n, norm, cnt };
      });
      const anyExcluded = nameInfos.some(n => excluded.has(n.norm));
      if (anyExcluded) continue;
      const validSpellings = nameInfos.filter(n => n.cnt !== null && n.cnt <= 7);
      if (!validSpellings.length) continue;
      possibleTargets.push({ idx, validSpellings });
    }
  }

  if (!possibleTargets.length) return null;

  // pick random valid candidate
  const chosen = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];

  // Compute semitones (range -6..+6 preferred)
  const srcIdx = (typeof sourcePick.original.index === 'number') ? sourcePick.original.index : 0;
  let semitonesRaw = ((chosen.idx - srcIdx) + 120) % 12;
  let sem = semitonesRaw;
  if (sem > 6) sem = sem - 12;

  // Prefer a display name that matches user's bucket if possible; fall back to pickDisplayName helper
  let displayName = null;
  const preferredCounts = accidentalSet;
  const validSpellings = (chosen.validSpellings || []).filter(s => s.cnt !== null && s.cnt <= 7);

  if (preferredCounts.size > 0) {
    const pref = validSpellings.filter(s => preferredCounts.has(Number(s.cnt))).map(s => s.raw);
    if (pref.length) displayName = pref[Math.floor(Math.random() * pref.length)];
  }
  if (!displayName) {
    // last resort: use the safer pickDisplayNameForIndexByAccCount (it too prefers <=7)
    displayName = pickDisplayNameForIndexByAccCount(chosen.idx, preferredCounts);
  }

  // Extra sanity: if the chosen displayName's accidental count doesn't match the bucket (when bucket non-empty),
  // try to find an alternate spelling. If none fits, log and continue with the safer name (we filtered earlier so this is unlikely)
  if (accidentalSet.size > 0) {
    const dnNorm = tonicNameNormalized(displayName);
    const dnCnt = (dnNorm in ACCIDENTAL_COUNT) ? ACCIDENTAL_COUNT[dnNorm] : null;
    if (dnCnt === null || !accidentalSet.has(Number(dnCnt))) {
      // try to find alternate
      const alt = (validSpellings || []).find(s => accidentalSet.has(Number(s.cnt)));
      if (alt) displayName = alt.raw;
      else console.debug('[pick] displayName did not match bucket but no alternate found for idx', chosen.idx, 'displayName', displayName);
    }
  }

  return {
    filename: sourcePick.filename,
    text: sourcePick.text,
    semitones: sem,
    displayName: displayName,
    enharmList: SAFE_TONICS_MAJOR[chosen.idx] || [],
    meta: sourcePick.meta
  };
}



    /* -------------------- Random button wiring -------------------- */
    const rb = document.getElementById('randomBtn');
    if (rb) rb.addEventListener('click', async()=>{
      rb.disabled = true;
      console.log('[randomBtn] clicked');
      try {
        const res = await pickRandomTuneAndTranspose();
        if (res) {
          humData = res.text;
          const meta = extractSecondSpineMeta(humData);
          const pillText = (meta.dir || meta.title || meta.number)
            ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
            : (res.filename || '—');
          document.getElementById('titleValue').textContent = pillText;

          const k = parseKeyInterpretation(humData||'');
          if (k) {
            originalKeyIndex = keyToIndex(k.letter, k.accidental);
            originalIsMajor = (k.letter === k.letter.toUpperCase());
            originalAccidentalPref = (k.accidental === '#' || k.accidental === '♯') ? '#' : (k.accidental === 'b' || k.accidental === '♭' || k.accidental === '-') ? 'b' : '';
          } else {
            originalKeyIndex = null;
            originalIsMajor = true;
            originalAccidentalPref = '';
          }

          currentSemitones = res.semitones;
          octaveShift = 0;
          displayTonicOverride = res.displayName || null;
          enharmonicCycleList = (res.enharmList && res.enharmList.length) ? res.enharmList.slice() : (originalKeyIndex !== null ? SAFE_TONICS_MAJOR[(originalKeyIndex+currentSemitones+120)%12] : []);
        } else {
          console.warn('[randomBtn] no candidate found (res null)');
          document.getElementById('titleValue').textContent = '— (no tunes found)';
          const r = await loadRandomTuneToHumData();
          if (r) {
            humData = r.text;
            const meta = extractSecondSpineMeta(humData);
            const pillText = (meta.dir || meta.title || meta.number)
              ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
              : (r.filename || '—');
            document.getElementById('titleValue').textContent = pillText;
            const k = parseKeyInterpretation(humData||'');
            if (k) {
              originalKeyIndex = keyToIndex(k.letter, k.accidental);
              originalIsMajor = (k.letter === k.letter.toUpperCase());
              originalAccidentalPref = (k.accidental === '#' || k.accidental === '♯') ? '#' : (k.accidental === 'b' || k.accidental === '♭' || k.accidental === '-') ? 'b' : '';
            }
            currentSemitones = 0;
            octaveShift = 0;
            displayTonicOverride = null;
            enharmonicCycleList = [];
          } else {
            console.warn('[randomBtn] fallback also failed — no tunes.json or files accessible');
            document.getElementById('humPanel').textContent = 'No tunes found or cannot fetch files. See console for details.';
          }
        }
      } finally {
        rb.disabled = false;
        renderWithTranspose();
      }
    });

    document.getElementById('manageCollectionBtn').addEventListener('click', ()=> alert('My Collection management placeholder — implement as needed.'));

    // initialize UI display values
    currentScale = baseOptions.scale;
    currentSpacingLinear = baseOptions.spacingLinear;
    document.getElementById('scaleBadge').textContent = String(currentScale);
    document.getElementById('spacingBadge').textContent = currentSpacingLinear.toFixed(2);
    document.getElementById('maxBadge').textContent = String(maxDifficulty);

    renderWithTranspose();
    window.addEventListener('resize', ()=>setTimeout(()=>renderWithTranspose(),150));
  })();
  </script>
</body>
</html>
