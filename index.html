<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Humdrum Viewer — Figured Bass Placement Restored</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />

  <!-- Preserve Verovio load order -->
  <script src="verovio-toolkit-wasm.js"></script>
  <script src="verovio-toolkit-hum.js"></script>

  <style>
  :root{
    --bg:#f7f7f9; --card:#ffffff; --border:#e3e3ea; --ink:#1b1b1f; --muted:#6b6b76;
    --gold:#FFCD00; --gold-border:#d7a900; --butter:#FFEFAD; --butter-border:#E6D48A; --radius:12px;
  }
  *{box-sizing:border-box}
  body{ font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin:0; padding:10px; background:var(--bg); color:var(--ink); font-weight:400; }
  .card{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:8px 10px; }
  button{ border:none; border-radius:10px; padding:8px 10px; font-size:.96rem; cursor:pointer;
    transition:background-color 120ms ease, opacity 120ms ease, transform 60ms ease, box-shadow 120ms ease; user-select:none; }
  button:active{transform:translateY(.5px)} button[disabled]{opacity:.6;cursor:not-allowed}
  .btn-gold{ background:var(--gold); color:#2d2300; border:1px solid var(--gold-border); }
  .btn-gold.pill3d { background:var(--gold); color:#2d2300; border:1px solid var(--gold-border); box-shadow:0 2px 0 rgba(160,120,0,.55); }
  .btn-lite{ background:var(--butter); color:#3b2f00; border:1px solid var(--butter-border); }
  .miniBtn{ padding:6px 10px; border-radius:10px; font-size:.92rem; min-width:40px; text-align:center; }
  .pill3d{ border-radius:999px; padding:10px 16px; box-shadow:0 2px 0 rgba(160,120,0,.12),0 10px 20px rgba(0,0,0,.04); background:transparent; border:1px solid var(--border) }
  .btn-green-pill{ background:#2f7d55; color:#fff; border-radius:999px; padding:10px 16px; }

  #row1{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:8px; }
  .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#fff; white-space:nowrap; }
  #viewerWrap{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; margin-bottom:8px; }
  #viewer{ padding:8px 12px 4px; min-height:120px; overflow-x:hidden; overflow-y:auto; position:relative; }
  #svg{ display:block }
  #musicFooter{ border-top:1px solid var(--border); padding:6px 12px; font-size:.82rem; color:#9aa0aa; text-align:left; background:#fff; }

  #row3{ display:flex; gap:10px; align-items:stretch; margin-bottom:8px; flex-wrap:wrap; }
  #keyRangeCard{ width:260px; min-width:260px; padding:8px 10px; }
  .keyRangeGrid{ display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:6px; }
  .range-btn{ padding:6px 8px; font-size:0.88rem; border-radius:10px; background:#f3f3f8; color:#333; border:1px solid var(--border); }
  .range-btn.active { background:var(--butter); border:1px solid var(--butter-border); box-shadow: 0 2px 0 rgba(230,212,138,.6); }

  .tool-btn{ background:#f3f3f8; color:#555; border-radius:8px; padding:6px 8px; border:1px solid var(--border); }

  #stackCol{ margin-left:0; width:320px; min-width:320px; display:flex; flex-direction:column; gap:10px; }
  .sliderHeader{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; font-size:.95rem; color:var(--ink); }
  .badge{ padding:3px 9px; border:1px solid var(--border); border-radius:999px; background:#fff; color:#222; font-size:0.88rem; }
  input[type="range"]{ width:100%; accent-color:var(--gold); margin:0; }
  .miniStackCard{ width:260px; min-width:260px; display:flex; flex-direction:column; gap:6px; padding:8px 10px; }
  .stackRow{ display:flex; gap:8px; align-items:center; flex-wrap:nowrap; }

  .chk-label{ display:inline-flex;align-items:center;gap:6px;font-size:.95rem;padding:3px 8px;border-radius:10px;border:1px solid var(--border);background:#fff; }

  .hum-panel{ margin-top:8px; background:#0f1724; color:#e6eef8; font-family:monospace; font-size:0.86rem; border-radius:10px; overflow:auto; border:1px solid #22303b; }
  .hum-panel pre{ margin:0; padding:10px; white-space:pre-wrap; word-break:break-word; }
  .hum-panel summary{ padding:8px 12px; cursor:pointer; font-weight:600; }

  .collection-card{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:10px; border:1px solid var(--border); background:#fff; }
  #row4 { display:flex; gap:10px; margin-bottom:8px; flex-wrap:wrap; align-items:flex-start; }

  .chip .label{ font-size:0.88rem; color:var(--muted); }
  .chip .value{ font-weight:600; margin-left:6px; font-size:0.95rem; }

  /* Figured-bass placement and Conventions look same */
  #figPlacementCard, .conventions-card { width:360px; min-width:260px; margin:8px 10px 0 0; padding:6px; display:inline-block; vertical-align:top; }
  #figPlacementCard fieldset, .conventions-card fieldset { border:0;margin:0;padding:0; }
  #figPlacementCard legend, .conventions-card legend { font-weight:600; margin-bottom:6px; font-size:0.92rem; }
  .placement-row{ display:flex; gap:14px; align-items:center; justify-content:flex-start; }
  .placement-row label, .conventions-row label {
    display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:8px; border:1px solid var(--border);
    cursor:pointer; background:#fafafa; font-size:.90rem; line-height:1;
  }

  .cpe-card { display:inline-block; vertical-align:top; width:180px; min-width:160px; margin:8px 10px 0 0; padding:8px; }
  .small-filter-card { display:inline-block; vertical-align:top; width:240px; min-width:220px; margin:8px 10px 0 0; padding:8px; }

  .row-equal-height { display:flex; gap:12px; align-items:stretch; flex-wrap:wrap; }
  .row-equal-height .card { display:flex; flex-direction:column; justify-content:flex-start; }

  .asc-desc-controls, .major-minor-controls { display:flex; gap:8px; }
  .asc-desc-btn, .major-minor-btn { padding:8px 12px; border-radius:10px; background:#f3f3f8; border:1px solid var(--border); cursor:pointer; }
  .asc-desc-btn.active, .major-minor-btn.active { background:var(--butter); border:1px solid var(--butter-border); box-shadow:0 2px 0 rgba(230,212,138,.6); }

  .som-logo { display:block; max-width:720px; margin:18px auto 12px auto; opacity:0.98; }

  /* radio accent color: make checked radios gold where supported */
  input[type="radio"], input[type="checkbox"] { accent-color: var(--gold); }

  </style>
</head>
<body>
  <div id="row1">
    <button id="randomBtn" class="btn-gold pill3d" type="button">New Bass Line</button>

    <span class="chip pill3d" title="Current title">
      <span id="titleValue" class="valueOnly">—</span>
    </span>

    <span class="chip" title="Current key">
      <span class="label">Key</span>
      <span id="statusKey" class="value">—</span>
    </span>
  </div>

  <div id="viewerWrap">
    <div id="viewer"><div id="svg"></div></div>
    <div id="musicFooter">created for the University of Iowa Organ Studio</div>

    <div style="padding:8px 12px;">
      <!-- Figured bass placement -->
      <div class="card" id="figPlacementCard">
        <fieldset>
          <legend>Figured bass placement</legend>
          <div class="placement-row">
            <label><input type="radio" name="figPlacement" id="figBelow" value="below" checked /> below</label>
            <label><input type="radio" name="figPlacement" id="figAbove" value="above" /> above</label>
          </div>
        </fieldset>
      </div>

      <!-- 17th/18th Conventions made to match the above -->
      <div class="card conventions-card">
        <fieldset>
          <legend>17th/18th Conventions</legend>
          <div class="placement-row conventions-row">
            <label><input type="radio" name="conventionsMode" id="conv_use" value="use" checked /> Use</label>
            <label><input type="radio" name="conventionsMode" id="conv_actual" value="actual" /> Actual Accidentals</label>
          </div>
        </fieldset>
      </div>
    </div>

  </div>

  <div id="row3">
    <div class="card" id="keyRangeCard">
      <div class="keyRangeHeader">Key range</div>
      <div class="keyRangeGrid" id="keysRangeRowTop"></div>
      <div style="height:6px"></div>
      <div class="keyRangeGrid" id="keysRangeRowBottom"></div>
      <div class="keyRangeToolsBottom" style="margin-top:8px">
        <button class="tool-btn" type="button" id="keysAllBtn">select all</button>
        <button class="tool-btn" type="button" id="keysNoneBtn">select none</button>
      </div>
    </div>

    <div id="stackCol">
      <div class="card">
        <div class="sliderHeader">
          <div>Scale</div>
          <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
            <button id="scaleResetBtn" class="reset-btn" type="button" title="Reset scale to default">reset</button>
            <button id="musicMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease scale">–</button>
            <button id="musicPlusBtn" class="miniBtn btn-lite" type="button" title="Increase scale">+</button>
            <span id="scaleBadge" class="badge">—</span>
          </div>
        </div>
        <input id="scaleSlider" type="range" min="30" max="200" step="2" value="44" />
      </div>

      <div class="card">
        <div class="sliderHeader">
          <div>Spacing</div>
          <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
            <button id="spacingResetBtn" class="reset-btn" type="button" title="Reset spacing to default">reset</button>
            <button id="spacingMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease spacing">–</button>
            <button id="spacingPlusBtn" class="miniBtn btn-lite" type="button" title="Increase spacing">+</button>
            <span id="spacingBadge" class="badge">—</span>
          </div>
        </div>
        <input id="spacingSlider" type="range" min="0.20" max="0.35" step="0.01" value="0.28" />
      </div>
    </div>

    <div class="card miniStackCard" id="xposeOctCard">
      <div class="stackTitle">Transpose</div>
      <div class="stackRow wrap">
        <button id="halfDownBtn" class="miniBtn btn-lite" type="button">–</button>
        <button id="halfUpBtn" class="miniBtn btn-lite" type="button">+</button>
        <button id="enharmonicBtn" class="btn-green-pill" type="button" title="Toggle enharmonic spelling">♯/♭</button>
      </div>

      <div class="stackTitle" style="margin-top:10px;">Octave</div>
      <div class="stackRow">
        <button id="octDownBtn" class="miniBtn btn-lite" type="button">–</button>
        <button id="octUpBtn" class="miniBtn btn-lite" type="button">+</button>
      </div>
    </div>
  </div>

  <!-- CPE Bach / Direction / Max difficulty row - equal heights -->
  <div class="row-equal-height" style="margin-top:12px;">
    <div class="card cpe-card" id="cpeCard">
      <div style="font-weight:600; margin-bottom:6px">CPE Bach</div>
      <div style="height:6px"></div>
      <div class="major-minor-controls">
        <button id="filterMajorBtn" class="major-minor-btn active" type="button">Major</button>
        <button id="filterMinorBtn" class="major-minor-btn active" type="button">Minor</button>
      </div>
    </div>

    <div class="card small-filter-card" id="directionCard">
      <div style="font-weight:600; margin-bottom:6px">Direction</div>
      <div class="asc-desc-controls">
        <button id="filterAscBtn" class="asc-desc-btn active" type="button">Ascending</button>
        <button id="filterDescBtn" class="asc-desc-btn active" type="button">Descending</button>
      </div>
    </div>

    <div class="card" style="min-width:220px;" id="maxDifficultyCard">
      <div class="sliderHeader">
        <div>Max difficulty</div>
        <div style="display:inline-flex;gap:6px;align-items:center;flex-wrap:wrap">
          <button id="maxResetBtn" class="reset-btn" type="button" title="Reset max difficulty">reset</button>
          <button id="maxMinusBtn" class="miniBtn btn-lite" type="button" title="Decrease max difficulty">–</button>
          <button id="maxPlusBtn" class="miniBtn btn-lite" type="button" title="Increase max difficulty">+</button>
          <span id="maxBadge" class="badge">7</span>
        </div>
      </div>
      <input id="maxRange" type="range" min="1" max="7" step="1" value="7" />
    </div>
  </div>

  <details id="filtersCard" open style="margin-top:12px;">
    <summary>Filters</summary>
    <div id="optionsBar">
      <fieldset class="panel" id="exPanel">
        <legend>
          <span>Exclude</span>
          <span class="panel-tools">
            <button class="tool-btn" type="button" id="exAllBtn">select all</button>
            <button class="tool-btn" type="button" id="exNoneBtn">select none</button>
          </span>
        </legend>
        <div class="row" id="exRow" style="padding:8px 6px;"></div>
      </fieldset>
    </div>
  </details>

  <div style="margin-top:8px;">
    <div class="collection-card card">
      <div style="font-weight:600">My Collection</div>
      <div style="width:12px"></div>
      <div style="color:var(--muted); font-size:.92rem">(custom collection editor coming)</div>
      <div style="flex:1"></div>
      <button id="manageCollectionBtn" class="miniBtn btn-lite" type="button">Manage</button>
    </div>
  </div>

  <div style="padding:16px 0 8px 0; text-align:center;">
    <img src="School-of-Music-LockupStacked-RGB.svg" alt="School of Music" class="som-logo" />
  </div>

  <!-- move hum-panel to bottom (under logo) -->
  <details class="hum-panel" id="humPanelWrap" open style="margin:10px 16px 40px 16px;">
    <summary>Humdrum source used for rendering (click to collapse)</summary>
    <pre id="humPanel">loading…</pre>
  </details>

  <script>
  (async function(){
    /* -------------------- Constants & helpers -------------------- */
    const LETTER_TO_INDEX = { 'C':0,'D':2,'E':4,'F':5,'G':7,'A':9,'B':11 };
    // Map canonical major tonic -> count of accidentals in its signature (0..7)
    const ACCIDENTAL_COUNT = {
      'C':0,'G':1,'D':2,'A':3,'E':4,'B':5,'F#':6,'C#':7,
      'F':1,'Bb':2,'Eb':3,'Ab':4,'Db':5,'Gb':6,'Cb':7
    };
    const SAFE_TONICS_MAJOR = {
      0: ['C'], 1: ['Db','C#'], 2: ['D'], 3: ['Eb'], 4: ['E','Fb'],
      5: ['F'], 6: ['F#','Gb'], 7: ['G'], 8: ['Ab'], 9: ['A'],
      10:['Bb'], 11:['B','Cb']
    };

    function tonicNameNormalized(name) {
      if (!name) return null;
      return String(name).replace(/♯/g,'#').replace(/♭/g,'b').replace(/-/g,'b').trim();
    }
    function canonicalMajorForIndex(idx) {
      const cand = SAFE_TONICS_MAJOR[(idx+12)%12] || [];
      for (const c of cand) {
        if (c in ACCIDENTAL_COUNT) return c;
      }
      return cand[0] || 'C';
    }
    function indexToTonic(index, isMajor, preferAccidental) {
      index = (index + 12) % 12;
      return canonicalMajorForIndex(index);
    }
    function keyToIndex(letter, accidental) {
      let idx = LETTER_TO_INDEX[(letter||'').toUpperCase()];
      if (idx == null) return null;
      if (accidental === '#' || accidental === '♯') idx = (idx + 1) % 12;
      if (accidental === 'b' || accidental === '♭' || accidental === '-') idx = (idx + 11) % 12;
      return idx;
    }

    /* -------------------- enharmonic toggle pairs (cycle through) -------------------- */
    const ENHARMONIC_PAIRS = [
      ['Bb','A#'],
      ['G#','Ab'],
      ['F#','Gb'],
      ['D#','Eb'],
      ['C#','Db']
    ];
    let enhIndex = 0;
    function toggleEnharmonicCycle() {
      enhIndex = (enhIndex + 1) % ENHARMONIC_PAIRS.length;
      enharmonicPreference = (enharmonicPreference === '#') ? 'b' : '#';
      renderWithTranspose();
    }

    /* -------------------- metadata extractor from second spine -------------------- */
    function extractSecondSpineMeta(humText) {
      const out = { dir: null, title: null, number: null };
      if (!humText) return out;
      const lines = String(humText).split(/\r?\n/);

      let headerLineIndex = -1;
      for (let i = 0; i < lines.length; i++) {
        if (/^\*\*/.test(lines[i].trim())) { headerLineIndex = i; break; }
      }
      if (headerLineIndex === -1) return out;

      for (let i = headerLineIndex + 1; i < lines.length; i++) {
        const ln = lines[i];
        if (!ln) continue;
        if (/^\*/.test(ln.trim())) break;
        if (!/^!!/.test(ln.trim())) continue;

        const payload = ln.replace(/^!!\s*/, '');
        const cols = payload.split(/\t/).map(s => s.trim());

        for (let c = 0; c < cols.length; c++) {
          const valNext = (c+1 < cols.length) ? cols[c+1] : null;
          if (/^Dir$/i.test(cols[c]) && valNext) out.dir = out.dir || valNext;
          if (/^Title$/i.test(cols[c]) && valNext) out.title = out.title || valNext;
          if (/^Number$/i.test(cols[c]) && valNext) out.number = out.number || valNext;
        }

        if ((!out.dir || !out.title || !out.number) && cols.length >= 1) {
          const m = cols[0].match(/^([^:]+)\s*:\s*(.+)$/);
          if (m) {
            const lab = m[1].trim(), val = m[2].trim();
            if (/^Dir$/i.test(lab) && val) out.dir = out.dir || val;
            if (/^Title$/i.test(lab) && val) out.title = out.title || val;
            if (/^Number$/i.test(lab) && val) out.number = out.number || val;
          }
        }

        if (out.dir && out.title && out.number) break;
      }
      return out;
    }

    /* -------------------- random loader (simple) -------------------- */
    async function loadRandomTuneToHumData() {
      try {
        const listResp = await fetch('tunes/list.json?_=' + Date.now(), { cache: 'no-cache' });
        if (!listResp || !listResp.ok) return null;
        const listJson = await listResp.json();
        const files = Array.isArray(listJson.files) ? listJson.files : [];
        if (files.length === 0) return null;
        const pick = files[Math.floor(Math.random() * files.length)];
        const fileResp = await fetch('tunes/' + encodeURIComponent(pick));
        if (!fileResp || !fileResp.ok) return null;
        const text = await fileResp.text();
        return { filename: pick, text };
      } catch (e) {
        console.error('loadRandomTuneToHumData error', e);
        return null;
      }
    }

    /* -------------------- initial file load -------------------- */
    let humData = "";
    let filename = null;

    try {
      const initial = await loadRandomTuneToHumData();
      if (initial) {
        filename = initial.filename;
        humData = initial.text;
        const meta = extractSecondSpineMeta(humData);
        const pillText = (meta.dir || meta.title || meta.number)
          ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
          : (filename || '—');
        document.getElementById('titleValue').textContent = pillText || (filename || '—');
      } else {
        document.getElementById('titleValue').textContent = '— (no tunes/list.json)';
      }
    } catch (e) {
      console.warn(e);
    }

    /* -------------------- verovio & base options -------------------- */
    if (!(window.verovio && typeof verovio.toolkit === 'function')) {
      document.getElementById('svg').textContent = 'Verovio not loaded. Check script paths: verovio-toolkit-wasm.js and verovio-toolkit-hum.js';
      document.getElementById('humPanel').textContent = '##original humdrum file##\n' + (humData || '(empty)') +
        '\n\n##currently displayed humdrum##\n(verovio not loaded)';
      return;
    }

    const vrvToolkit = new verovio.toolkit();
    const baseOptions = {
      scale: 44, pageWidth: 900, adjustPageHeight: true,
      spacingLinear: 0.28, spacingNonLinear: 0.46,
      spacingSystem: 10, spacingStaff: 8
    };
    vrvToolkit.setOptions(baseOptions);

    /* -------------------- state -------------------- */
    let figuresAbove = false; // fb placement
    let conventionsMode = 'use'; // 'use' or 'actual'
    let currentSemitones = 0;
    let octaveShift = 0;
    let enharmonicPreference = ''; // '#' or 'b'
    let currentScale = baseOptions.scale;
    let currentSpacingLinear = baseOptions.spacingLinear;
    let originalKeyIndex = null;
    let originalIsMajor = true;
    let originalAccidentalPref = '';
    let showFallbackOriginal = false; // when no candidates found, show fallback note in key badge

    // difficulty filter (global) default to 7
    let maxDifficulty = 7;
    let defaultMaxDifficulty = 7;

    /* -------------------- helpers used in FB transpose (restored) -------------------- */
    function normalizeAccRaw(acc) {
      if (!acc) return '';
      acc = acc.replace(/\s+/g, '');
      acc = acc.replace(/-/g, 'b'); // humdrum '-' -> internal 'b'
      acc = acc.replace(/[\/\\]/g, '#');
      return acc;
    }
    function toHumdrumAcc(acc) {
      if (!acc) return '';
      acc = String(acc);
      acc = acc.replace(/♭/g, 'b').replace(/♯/g, '#');
      acc = acc.replace(/b/g, '-');
      return acc;
    }
    function parseKernPitch(t) {
      if (!t) return null;
      const m = String(t).match(/([A-Ga-g])([#♯b♭-]{0,2})/);
      if (!m) return null;
      const letter = m[1].toUpperCase();
      let acc = m[2] || '';
      if (acc === '-') acc = 'b';
      if (acc === '--') acc = 'bb';
      const pc = (() => {
        if (!acc) return keyToIndex(letter, '');
        if (acc === '#' || acc === '♯') return keyToIndex(letter, '#');
        if (acc === 'b' || acc === '♭' || acc === '-') return keyToIndex(letter, 'b');
        if (acc === '##') return (LETTER_TO_INDEX[letter] + 2) % 12;
        if (acc === 'bb') return (LETTER_TO_INDEX[letter] + 10) % 12;
        return keyToIndex(letter, acc[0] || '');
      })();
      return { letter, acc, pc };
    }

    // <<< RESTORED helper — required for accidentals logic >>>
    function accFromDesiredVsNatural(desiredPc, naturalPc, diatonicPc) {
      const diffNat = (desiredPc - naturalPc + 12) % 12;

      // same pitch class as natural
      if (diffNat === 0) {
        // if diatonic pitch differs from natural, we need an explicit natural
        if (diatonicPc !== naturalPc) return 'n';
        return '';
      }

      // semitone adjustments relative to natural
      if (diffNat === 1)  return '#';
      if (diffNat === 11) return 'b';
      if (diffNat === 2)  return '##';
      if (diffNat === 10) return 'bb';

      return null;
    }

    function accSymbolFromDiff(diatonicPc, desiredPc, naturalPc) {
      const diff = (desiredPc - diatonicPc + 12) % 12;
      if (diff === 0) return '';
      if (desiredPc === naturalPc && diatonicPc !== naturalPc) return 'n';
      if (diff === 1) return '#';
      if (diff === 11) return 'b';
      if (diff === 2) return '##';
      if (diff === 10) return 'bb';
      return null;
    }

    const LETTERS = ['C','D','E','F','G','A','B'];
    const SCALE_OFFSETS_MAJOR = [0,2,4,5,7,9,11];
    const SCALE_OFFSETS_NAT_MINOR = [0,2,3,5,7,8,10];

    function findScaleMapFor(semitonesOffset) {
      if (typeof originalKeyIndex !== 'number' || originalKeyIndex === null) return null;
      const targetKeyIndex = (originalKeyIndex + semitonesOffset + 120) % 12;
      const tonicName = indexToTonic(targetKeyIndex, originalIsMajor, enharmonicPreference || originalAccidentalPref) || 'C';
      const tonicLetter = tonicName[0].toUpperCase();
      const OFFSETS = originalIsMajor ? SCALE_OFFSETS_MAJOR : SCALE_OFFSETS_NAT_MINOR;
      const tonicLetterIdx = LETTERS.indexOf(tonicLetter);

      const map = {};
      for (let d = 0; d < 7; d++) {
        const letter = LETTERS[(tonicLetterIdx + d) % 7];
        const pc = (targetKeyIndex + OFFSETS[d]) % 12;
        map[letter] = pc;
      }
      return map;
    }

    function parseKeyInterpretation(hum) {
      const lines = hum.split(/\r?\n/);
      for (let ln of lines) {
        ln = ln.trim();
        const m = ln.match(/^\*([A-Ga-g])([#b♯♭-]?)\s*:/);
        if (m) {
          let acc = m[2] || '';
          if (acc === '-') acc = 'b';
          return { letter: m[1], accidental: acc };
        }
      }
      return null;
    }

    {
      const keyInfo = parseKeyInterpretation(humData || "");
      if (keyInfo) {
        originalKeyIndex = keyToIndex(keyInfo.letter, keyInfo.accidental);
        originalIsMajor = (keyInfo.letter === keyInfo.letter.toUpperCase());
        if (keyInfo.accidental === '#' || keyInfo.accidental === '♯') originalAccidentalPref = '#';
        if (keyInfo.accidental === 'b' || keyInfo.accidental === '♭') originalAccidentalPref = 'b';
      }
    }

    /* -------------------- prepareFiguredBassForTranspose (kept) -------------------- */
    function prepareFiguredBassForTranspose(humText, semitones) {
      if (!humText) return '';

      const lines = humText.split(/\r?\n/);

      let headerBlockEnd = -1;
      let kernIndices = [];
      let fbIndex = null;
      let actualTextIndex = null;
      let forceTextIndex  = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const toks = (line.indexOf('\t') !== -1) ? line.split('\t') : line.split(/\s+/);

        if (toks.some(t => String(t).startsWith('**'))) {
          headerBlockEnd = i;

          for (let c = 0; c < toks.length; c++) {
            if (String(toks[c]).startsWith('**kern')) kernIndices.push(c);
          }

          for (let c = 0; c < toks.length; c++) {
            const t = String(toks[c]);
            if (t.startsWith('**fb') || t.startsWith('**fba') || t.startsWith('**fbb')) {
              if (fbIndex === null) fbIndex = c;
            }
          }

          if (fbIndex !== null) {
            let foundFirst = false;
            for (let c = fbIndex + 1; c < toks.length; c++) {
              const t = String(toks[c]);
              if (t.startsWith('**text')) {
                if (!foundFirst) { actualTextIndex = c; foundFirst = true; }
                else { forceTextIndex = c; break; }
              }
            }
          }
        } else {
          if (headerBlockEnd >= 0) break;
        }
      }

      if (fbIndex === null) return humText;

      const preHeaderLines = lines.slice(0, headerBlockEnd + 1);
      const restLines      = lines.slice(headerBlockEnd + 1);

      let globalMax = 0;
      for (const line of restLines) {
        if (!line) continue;
        const toks = (line.indexOf('\t') !== -1) ? line.split('\t') : line.split(/\s+/);
        const tok = toks[fbIndex];
        if (!tok || tok === '.' || /^[\*\=\!\|]/.test(tok)) continue;
        const parts = String(tok).trim().split(/\s+/).filter(Boolean);
        let numeralsCount = 0;
        for (const p of parts) {
          const digits = p.match(/\d+/g);
          numeralsCount += (digits ? digits.length : 0);
        }
        if (numeralsCount === 0 && parts.some(p => /\d/.test(p))) numeralsCount = 1;
        globalMax = Math.max(globalMax, numeralsCount);
      }

      const scalePCByLetter = findScaleMapFor(semitones);
      const scaleLettersByPc = scalePCByLetter
        ? Object.keys(scalePCByLetter).reduce((acc, L) => {
            const pc = scalePCByLetter[L];
            acc[pc] = acc[pc] || [];
            acc[pc].push(L);
            return acc;
          }, {})
        : null;

      function pcNewBass(bassInfo) {
        return (bassInfo.pc + semitones + 120) % 12;
      }

      function targetLetterForDegree(newBassPc, degree) {
        if (!scalePCByLetter || !scaleLettersByPc) return null;

        let bassLetterInTargetKey = null;
        for (const L of Object.keys(scalePCByLetter)) {
          if (scalePCByLetter[L] === newBassPc) { bassLetterInTargetKey = L; break; }
        }
        if (!bassLetterInTargetKey) return null;

        const LETTERS7 = ['C','D','E','F','G','A','B'];
        const bassIdxInLetters = LETTERS7.indexOf(bassLetterInTargetKey);
        return LETTERS7[(bassIdxInLetters + (degree - 1)) % 7];
      }

      function accidentalForDirection(targetLetter, direction) {
        if (!targetLetter || !scalePCByLetter) return null;
        const diatonicPc = scalePCByLetter[targetLetter];
        const naturalPc  = LETTER_TO_INDEX[targetLetter];
        let desiredPc    = diatonicPc;

        if (direction === '#' || /#[♯]/.test(direction)) desiredPc = (diatonicPc + 1) % 12;
        else if (direction === 'b' || /b/.test(direction)) desiredPc = (diatonicPc + 11) % 12;
        else if (direction === '##') desiredPc = (diatonicPc + 2) % 12;
        else if (direction === 'bb') desiredPc = (diatonicPc + 10) % 12;
        else if (/n/i.test(direction)) desiredPc = naturalPc;
        else desiredPc = diatonicPc;

        const finalAccSym = accFromDesiredVsNatural(desiredPc, naturalPc, diatonicPc);
        return finalAccSym;
      }

      function accidentalForDiatonic(targetLetter) {
        if (!targetLetter || !scalePCByLetter) return null;
        const diatonicPc = scalePCByLetter[targetLetter];
        const naturalPc  = LETTER_TO_INDEX[targetLetter];
        const diff = (diatonicPc - naturalPc + 12) % 12;
        if (diff === 0)  return 'n';
        if (diff === 1)  return '#';
        if (diff === 11) return 'b';
        if (diff === 2)  return '##';
        if (diff === 10) return 'bb';
        return null;
      }

      function parseFigurePart(partRaw) {
        const s = String(partRaw).trim();
        const mNumAcc = s.match(/^([0-9]+)\s*([#♯b♭nN\-\/\\]+)?$/);
        if (mNumAcc) {
          const degree = parseInt(mNumAcc[1], 10);
          const accRaw = normalizeAccRaw(mNumAcc[2] || '');
          return { degree, acc: accRaw, accOnly: false, raw: s };
        }
        const mAccOnly = s.match(/^([#♯b♭nN\-\/\\]+)$/);
        if (mAccOnly) {
          const accRaw = normalizeAccRaw(mAccOnly[1] || '');
          return { degree: 3, acc: accRaw, accOnly: true, raw: s };
        }
        return null;
      }

      function parseForceDiatonicPart(partRaw) {
        let part = String(partRaw).trim();
        let trailingBar = '';
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }
        const m = part.match(/^([0-9]+)q$/i);
        if (!m) return null;
        return { degree: parseInt(m[1], 10), trailingBar };
      }

      function isHistoricalPassThroughToken(fullToken) {
        return (
          fullToken === '5-' ||
          fullToken === '4#|' ||
          /[\\\/]$/.test(fullToken)
        );
      }

      function processFbPartHistorical(partRaw, kernTok) {
        if (!partRaw || /^[\*\=\!\|]/.test(partRaw) || partRaw === '.') return partRaw;

        const fullToken = String(partRaw);
        if (isHistoricalPassThroughToken(fullToken)) return fullToken;

        let trailingBar = '';
        let part = fullToken;
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }

        const parsed = parseFigurePart(part);
        if (!parsed) return fullToken;

        if (!parsed.acc && !parsed.accOnly) return String(parsed.degree) + trailingBar;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }
        const newBassPc    = pcNewBass(bassInfo);
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree);
        if (!targetLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        const finalAccSym = accidentalForDirection(targetLetter, parsed.acc);
        if (finalAccSym === null) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }
        return parsed.accOnly
          ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
          : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
      }

      function processFbPartActual(partFromActualSpine, kernTok) {
        if (!partFromActualSpine || /^[\*\=\!\|]/.test(partFromActualSpine) || partFromActualSpine === '.') return partFromActualSpine;

        let trailingBar = '';
        let part = String(partFromActualSpine);
        if (part.endsWith('|')) { trailingBar = '|'; part = part.slice(0, -1); }

        const parsed = parseFigurePart(part);
        if (!parsed) return partFromActualSpine;

        if (!parsed.acc && !parsed.accOnly) return String(parsed.degree) + trailingBar;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        const newBassPc    = pcNewBass(bassInfo);
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree);
        if (!targetLetter) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        let finalAccSym = accidentalForDirection(targetLetter, parsed.acc);
        if (finalAccSym === null) {
          return (parsed.accOnly ? toHumdrumAcc(parsed.acc) : String(parsed.degree) + toHumdrumAcc(parsed.acc)) + trailingBar;
        }

        if (finalAccSym === '' && /n/i.test(parsed.acc)) {
          finalAccSym = 'n';
        }

        return parsed.accOnly
          ? (toHumdrumAcc(finalAccSym) || '') + trailingBar
          : String(parsed.degree) + (toHumdrumAcc(finalAccSym) || '') + trailingBar;
      }

      function processForceDiatonicPart(partFromForceSpine, kernTok) {
        if (!partFromForceSpine || /^[\*\=\!\|]/.test(partFromForceSpine) || partFromForceSpine === '.') return partFromForceSpine;

        let trailingBar = '';
        let token = String(partFromForceSpine);
        if (token.endsWith('|')) { trailingBar = '|'; token = token.slice(0, -1); }

        const parsed = parseForceDiatonicPart(token);
        if (!parsed) return partFromForceSpine;

        const bassInfo = parseKernPitch(kernTok);
        if (!bassInfo || typeof bassInfo.pc !== 'number' || !scalePCByLetter) {
          return String(parsed.degree) + 'n' + trailingBar;
        }
        const newBassPc    = pcNewBass(bassInfo);
        const targetLetter = targetLetterForDegree(newBassPc, parsed.degree);
        if (!targetLetter) {
          return String(parsed.degree) + 'n' + trailingBar;
        }

        const diatonicAcc = accidentalForDiatonic(targetLetter);
        const outAcc = diatonicAcc || 'n';
        return String(parsed.degree) + toHumdrumAcc(outAcc) + trailingBar;
      }

      let lastKernTokForBass = null;

      const processedRest = restLines.map(line => {
        if (!line) return line;
        const useTabs = line.indexOf('\t') !== -1;
        const toks = useTabs ? line.split('\t') : line.split(/\s+/);

        if (toks.some(t => String(t).startsWith('**'))) {
          return useTabs ? toks.join('\t') : toks.join(' ');
        }

        const maxIdxToEnsure = Math.max(
          fbIndex,
          ...(kernIndices || [-1]),
          (actualTextIndex ?? -1),
          (forceTextIndex  ?? -1)
        );
        while (toks.length <= maxIdxToEnsure) toks.push('.');

        const kernTokRaw = (kernIndices && kernIndices.length) ? toks[kernIndices[0]] : null;
        const parsedBassNow = parseKernPitch(kernTokRaw);
        if (parsedBassNow && typeof parsedBassNow.pc === 'number') {
          lastKernTokForBass = kernTokRaw;
        }
        const kernTok = (parsedBassNow && typeof parsedBassNow.pc === 'number')
          ? kernTokRaw
          : lastKernTokForBass;

        const fbTokSrc  = toks[fbIndex];
        const forceTok  = (forceTextIndex  != null) ? toks[forceTextIndex] : null;
        const actualTok = (conventionsMode === 'actual' && actualTextIndex != null) ? toks[actualTextIndex] : null;

        let processedParts = null;

        if (forceTok && !/^[\*\=\!\|]/.test(forceTok) && forceTok !== '.') {
          const parts = String(forceTok).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processForceDiatonicPart(p, kernTok));
        } else if (actualTok && !/^[\*\=\!\|]/.test(actualTok) && actualTok !== '.') {
          const parts = String(actualTok).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processFbPartActual(p, kernTok));
        } else if (fbTokSrc && !/^[\*\=\!\|]/.test(fbTokSrc) && fbTokSrc !== '.') {
          const parts = String(fbTokSrc).trim().split(/\s+/).filter(Boolean);
          processedParts = parts.map(p => processFbPartHistorical(p, kernTok));
        }

        if (processedParts && processedParts.length) {
          let numeralsNow = processedParts.reduce((acc, p) =>
            acc + ((String(p).match(/\d+/g) || []).length || (/\d/.test(p) ? 1 : 0)), 0);
          if (numeralsNow === 0 && processedParts.some(p => /\d/.test(p))) numeralsNow = 1;
          const need = Math.max(0, globalMax - Math.max(1, numeralsNow));

          toks[fbIndex] = (figuresAbove && need > 0)
            ? (Array(need).fill('x').join(' ') + ' ' + processedParts.join(' ')).trim()
            : processedParts.join(' ');
        }

        function neutralizeHelperToken(tok) {
          if (!tok) return '.';
          if (/^[\*\=\!|]/.test(tok)) return tok;
          return '.';
        }
        if (actualTextIndex != null) toks[actualTextIndex] = neutralizeHelperToken(toks[actualTextIndex]);
        if (forceTextIndex  != null) toks[forceTextIndex]  = neutralizeHelperToken(toks[forceTextIndex]);

        return useTabs ? toks.join('\t') : toks.join(' ');
      });

      const processedHeader = preHeaderLines.map(hl => {
        if (!hl) return hl;
        const useTabs = hl.indexOf('\t') !== -1;
        const toks = useTabs ? hl.split('\t') : hl.split(/\s+/);

        if (figuresAbove) {
          for (let c = 0; c < toks.length; c++) {
            if (String(toks[c]).startsWith('**fb') && !String(toks[c]).startsWith('**fba')) {
              toks[c] = String(toks[c]).replace(/^\*\*fb/, '**fba');
            }
          }
        }
        for (let c = 0; c < toks.length; c++) {
          if (actualTextIndex != null && c === actualTextIndex && String(toks[c]).startsWith('**text')) {
            toks[c] = '**text-hidden';
          }
          if (forceTextIndex  != null && c === forceTextIndex  && String(toks[c]).startsWith('**text')) {
            toks[c] = '**text-hidden';
          }
        }

        return useTabs ? toks.join('\t') : toks.join(' ');
      });

      const finalLines = [];
      processedHeader.forEach(hl => finalLines.push(hl));
      processedRest.forEach(rl => finalLines.push(rl));
      return finalLines.join('\n');
    }

    /* -------------------- render & helpers -------------------- */
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function tonicDisplayWithGlyphs(s) { if (!s) return s; return String(s).replace(/#/g, '♯').replace(/b/g, '♭'); }

    function renderWithTranspose() {
      const humPanelEl = document.getElementById('humPanel');

      // Always run the preparation pass so 4th spine can override even with 0 transpose
      const preparedHum = prepareFiguredBassForTranspose(humData || "", currentSemitones);

      const semText = String(currentSemitones || 0);
      const actualAccLine = '##Actual Accidentals=' + (conventionsMode === 'actual' ? 'TRUE' : 'FALSE');
      const panelContent = [
        '##original humdrum file##',
        humData || '(empty)',
        '##currently displayed humdrum##',
        '##transpose ' + semText + ' semitones',
        actualAccLine,
        preparedHum || '(empty)'
      ].join('\n\n');
      if (humPanelEl) humPanelEl.textContent = panelContent;

      const options = {
        ...baseOptions,
        scale: currentScale,
        spacingLinear: currentSpacingLinear,
        spacingNonLinear: currentSpacingLinear * (baseOptions.spacingNonLinear / baseOptions.spacingLinear)
      };

      if (originalKeyIndex !== null) {
        const newIndex = (originalKeyIndex + currentSemitones + 120) % 12;
        const tonicRaw = indexToTonic(newIndex, true, enharmonicPreference || originalAccidentalPref);
        const tonic = tonicDisplayWithGlyphs(tonicRaw);
        const modeText = originalIsMajor ? ' major' : ' minor';
        const prefix = octaveShift > 0 ? "+".repeat(octaveShift) : octaveShift < 0 ? "-".repeat(-octaveShift) : "";
        options.transpose = prefix + (tonicRaw || "");
        let fallbackNote = showFallbackOriginal ? ' (fallback: original)' : '';
        if (octaveShift !== 0) {
          const octaveText = octaveShift > 0 ? " 8va↑ (" + String(octaveShift) + ")" : " 8va↓ (" + String(octaveShift) + ")";
          document.getElementById('statusKey').textContent = tonic + modeText + octaveText + fallbackNote;
        } else {
          document.getElementById('statusKey').textContent = tonic + modeText + fallbackNote;
        }
      } else {
        options.transpose = "";
        if (currentSemitones === 0 && octaveShift === 0) document.getElementById('statusKey').textContent = "original";
        else document.getElementById('statusKey').textContent = "transposed " + String(currentSemitones) + " st";
      }

      vrvToolkit.setOptions(options);
      try {
        const svg = vrvToolkit.renderData(preparedHum, {});
        document.getElementById('svg').innerHTML = svg;
        document.getElementById('scaleBadge').textContent = String(currentScale);
        document.getElementById('spacingBadge').textContent = currentSpacingLinear.toFixed(2);
        document.getElementById('maxBadge').textContent = String(maxDifficulty);
      } catch (e) {
        document.getElementById('svg').textContent = "Render error: " + (e && e.message ? e.message : String(e));
        console.error(e);
      }
    }

    /* -------------------- UI wiring -------------------- */
    function toggleEnharmonicPref(){ toggleEnharmonicCycle(); }
    function halfStepUp(){ currentSemitones += 1; renderWithTranspose(); }
    function halfStepDown(){ currentSemitones -= 1; renderWithTranspose(); }
    function octaveUp(){ octaveShift += 1; renderWithTranspose(); }
    function octaveDown(){ octaveShift -= 1; renderWithTranspose(); }
    function musicSizeChange(delta) { currentScale = clamp(currentScale + delta, 30, 200); renderWithTranspose(); }
    function spacingChange(delta) { currentSpacingLinear = clamp(currentSpacingLinear + delta, 0.20, 0.35); renderWithTranspose(); }
    function scaleSetFromSlider(v){ currentScale = clamp(Number(v), 30, 200); renderWithTranspose(); }
    function spacingSetFromSlider(v){ currentSpacingLinear = clamp(Number(v), 0.20, 0.35); renderWithTranspose(); }
    function resetScale(){ currentScale = 44; renderWithTranspose(); }
    function resetSpacing(){ currentSpacingLinear = 0.28; renderWithTranspose(); }

    document.getElementById('halfUpBtn').addEventListener('click', halfStepUp);
    document.getElementById('halfDownBtn').addEventListener('click', halfStepDown);
    document.getElementById('enharmonicBtn').addEventListener('click', toggleEnharmonicPref);
    document.getElementById('octUpBtn').addEventListener('click', octaveUp);
    document.getElementById('octDownBtn').addEventListener('click', octaveDown);

    document.getElementById('musicPlusBtn').addEventListener('click', () => musicSizeChange(+2));
    document.getElementById('musicMinusBtn').addEventListener('click', () => musicSizeChange(-2));
    document.getElementById('spacingPlusBtn').addEventListener('click', () => spacingChange(+0.01));
    document.getElementById('spacingMinusBtn').addEventListener('click', () => spacingChange(-0.01));
    document.getElementById('scaleResetBtn').addEventListener('click', resetScale);
    document.getElementById('spacingResetBtn').addEventListener('click', resetSpacing);
    document.getElementById('scaleSlider').addEventListener('input', (e)=>scaleSetFromSlider(e.target.value));
    document.getElementById('spacingSlider').addEventListener('input', (e)=>spacingSetFromSlider(e.target.value));

    // Conventions mode radio
    const convUseRb = document.getElementById('conv_use');
    const convActualRb = document.getElementById('conv_actual');
    if (convUseRb) convUseRb.addEventListener('change', (e)=>{ if (e.target.checked){ conventionsMode = 'use'; renderWithTranspose(); }});
    if (convActualRb) convActualRb.addEventListener('change', (e)=>{ if (e.target.checked){ conventionsMode = 'actual'; renderWithTranspose(); }});

    // Figured-bass placement radio
    const rbBelow = document.getElementById('figBelow');
    const rbAbove = document.getElementById('figAbove');
    if (rbBelow) rbBelow.addEventListener('change', (e)=>{ if (e.target.checked){ figuresAbove = false; renderWithTranspose(); }});
    if (rbAbove) rbAbove.addEventListener('change', (e)=>{ if (e.target.checked){ figuresAbove = true;  renderWithTranspose(); }});

    /* -------------------- Key range & Exclude UI -------------------- */
    const keyRangeButtons = new Map();
    const accidentalsSelected = new Set([0,1,2,3,4,5,6,7]); // default: all
    function addAccidentalRangeButtons(topId, bottomId){
      const top = document.getElementById(topId), bot = document.getElementById(bottomId);
      for (let n=0;n<=7;n++){
        const btn = document.createElement('button');
        btn.type='button';
        btn.className = 'range-btn' + (accidentalsSelected.has(n)?' active':'');
        btn.textContent = `${n}#/${n}♭`;
        btn.addEventListener('click', ()=>{
          if (accidentalsSelected.has(n)){ accidentalsSelected.delete(n); btn.classList.remove('active'); }
          else { accidentalsSelected.add(n); btn.classList.add('active'); }
        });
        (n<=3?top:bot).appendChild(btn);
        keyRangeButtons.set(n, btn);
      }
      document.getElementById('keysAllBtn').addEventListener('click', ()=>{
        for (let n=0;n<=7;n++){ accidentalsSelected.add(n); keyRangeButtons.get(n)?.classList.add('active'); }
      });
      document.getElementById('keysNoneBtn').addEventListener('click', ()=>{
        for (let n=0;n<=7;n++){ accidentalsSelected.delete(n); keyRangeButtons.get(n)?.classList.remove('active'); }
      });
    }

    const excludeTonics = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B","Cb"];
    function addExcludeCheckboxes(containerId, values){
      const row = document.getElementById(containerId);
      values.forEach(val=>{
        const id = `${containerId}_${String(val).replace(/[^A-Za-z0-9]/g,'_')}`;
        const label = document.createElement('label'); label.className = 'chk-label';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.id = id; cb.value = val; cb.checked = false;
        const span = document.createElement('span'); span.textContent = val.replace(/#/g,"♯").replace(/b/g,"♭");
        label.appendChild(cb); label.appendChild(span); row.appendChild(label);
      });
    }

    document.getElementById('exAllBtn').addEventListener('click', ()=>{ document.querySelectorAll('#exRow input[type="checkbox"]').forEach(el=>el.checked=true); });
    document.getElementById('exNoneBtn').addEventListener('click', ()=>{ document.querySelectorAll('#exRow input[type="checkbox"]').forEach(el=>el.checked=false); });

    function getExcludedTonicsSet() {
      const s = new Set();
      document.querySelectorAll('#exRow input[type="checkbox"]').forEach(cb=>{
        if (cb.checked) s.add(tonicNameNormalized(cb.value));
      });
      return s;
    }

    /* -------------------- Asc/Desc filter UI state -------------------- */
    let filterAscending = true;
    let filterDescending = true;
    const ascBtn = document.getElementById('filterAscBtn');
    const descBtn = document.getElementById('filterDescBtn');
    ascBtn.addEventListener('click', ()=>{ filterAscending = !filterAscending; ascBtn.classList.toggle('active', filterAscending); });
    descBtn.addEventListener('click', ()=>{ filterDescending = !filterDescending; descBtn.classList.toggle('active', filterDescending); });
    ascBtn.classList.add('active'); descBtn.classList.add('active');

    /* -------------------- Major/Minor filter UI state -------------------- */
    let filterMajor = true;
    let filterMinor = true;
    const majorBtn = document.getElementById('filterMajorBtn');
    const minorBtn = document.getElementById('filterMinorBtn');
    majorBtn.addEventListener('click', ()=>{ filterMajor = !filterMajor; majorBtn.classList.toggle('active', filterMajor); });
    minorBtn.addEventListener('click', ()=>{ filterMinor = !filterMinor; minorBtn.classList.toggle('active', filterMinor); });
    majorBtn.classList.add('active'); minorBtn.classList.add('active');

    /* -------------------- Max difficulty UI wiring -------------------- */
    const maxResetBtn = document.getElementById('maxResetBtn');
    const maxMinusBtn = document.getElementById('maxMinusBtn');
    const maxPlusBtn = document.getElementById('maxPlusBtn');
    const maxBadge = document.getElementById('maxBadge');
    const maxRange = document.getElementById('maxRange');

    function setMaxDifficulty(v) {
      maxDifficulty = clamp(Number(v), 1, 7);
      maxBadge.textContent = String(maxDifficulty);
      maxRange.value = String(maxDifficulty);
    }
    maxMinusBtn.addEventListener('click', ()=> setMaxDifficulty(maxDifficulty - 1));
    maxPlusBtn.addEventListener('click', ()=> setMaxDifficulty(maxDifficulty + 1));
    maxResetBtn.addEventListener('click', ()=> setMaxDifficulty(defaultMaxDifficulty));
    maxRange.addEventListener('input', (e)=> setMaxDifficulty(e.target.value));

    /* -------------------- candidate picking honoring accidental counts, excludes, Asc/Desc, Mode, difficulty -------------------- */
    async function pickRandomTuneAndTranspose() {
      const listResp = await fetch('tunes/list.json?_=' + Date.now(), { cache: 'no-cache' });
      if (!listResp || !listResp.ok) return null;
      const listJson = await listResp.json();
      const files = Array.isArray(listJson.files) ? listJson.files : [];
      if (!files.length) return null;
      const excludedSet = getExcludedTonicsSet();

      const candidates = [];
      for (const f of files) {
        try {
          const fr = await fetch('tunes/' + encodeURIComponent(f));
          if (!fr || !fr.ok) continue;
          const text = await fr.text();
          const meta = extractSecondSpineMeta(text || '');
          // direction filter
          const dir = (meta.dir || '').toLowerCase();
          if (!filterAscending && dir === 'ascending') continue;
          if (!filterDescending && dir === 'descending') continue;

          // difficulty filter (meta.number should be integer)
          const num = parseInt((meta.number || '').toString().replace(/[^\d]/g,''), 10);
          if (!isNaN(num)) {
            if (num > maxDifficulty) continue;
          } else {
            // if no metadata number present, treat as highest difficulty (so it's filtered when max < 7)
            if (maxDifficulty < 7) continue;
          }

          const k = parseKeyInterpretation(text || '');
          if (!k) continue;
          const idx = keyToIndex(k.letter, k.accidental);
          const isMajor = (k.letter === k.letter.toUpperCase());
          // mode filter for source tune (if user only wants Major or Minor sources)
          if (!filterMajor && isMajor) continue;
          if (!filterMinor && !isMajor) continue;

          candidates.push({ filename: f, text, original: { index: idx, isMajor, tonic: canonicalMajorForIndex(idx) }, meta });
        } catch (e) { /* ignore individual failures */ }
      }

      if (!candidates.length) return null;

      // pick a random candidate source file first
      const sourcePick = candidates[Math.floor(Math.random() * candidates.length)];

      // Build possibleTargets by iterating canonical major key signatures (0..11) and checking their accidental counts
      const accidentalSet = new Set(Array.from(accidentalsSelected));
      const excluded = getExcludedTonicsSet();
      const possibleTargets = [];

      for (let majorIdx = 0; majorIdx < 12; majorIdx++) {
        const majorCanon = canonicalMajorForIndex(majorIdx);           // canonical major tonic name for this signature
        const count = ACCIDENTAL_COUNT[majorCanon];                   // accidentals count 0..7
        if (count == null) continue;
        if (!accidentalSet.has(count)) continue;                      // must match user-selected count bucket

        // target index depends on whether we want to map to major or minor display:
        // - if the source tune is major, map to majorIdx (major keys)
        // - if the source tune is minor, map to relative minor (majorIdx -> minor tonic is majorIdx + 9)
        const targetIndex = sourcePick.original.isMajor ? majorIdx : (majorIdx + 9) % 12;
        const displayTonic = canonicalMajorForIndex(targetIndex);
        const normDisplay = tonicNameNormalized(displayTonic);

        // exclude check: if the normalized display tonic is excluded by user, skip
        if (excluded.has(normDisplay)) continue;

        // also respect Mode toggles for what to display (if user turned off majors/minors)
        const targetIsMajor = sourcePick.original.isMajor ? true : false;
        if (!filterMajor && targetIsMajor) continue;
        if (!filterMinor && !targetIsMajor) continue;

        possibleTargets.push({ tonic: displayTonic, idx: targetIndex });
      }

      // If nothing due to accidentalSet + excludes, allow a looser fallback list (still respect excludes and mode)
      if (!possibleTargets.length) {
        for (let idx = 0; idx < 12; idx++) {
          const t = canonicalMajorForIndex(idx);
          const norm = tonicNameNormalized(t);
          if (excluded.has(norm)) continue;
          const targetIsMajor = sourcePick.original.isMajor ? true : false;
          if (!filterMajor && targetIsMajor) continue;
          if (!filterMinor && !targetIsMajor) continue;
          possibleTargets.push({ tonic: t, idx });
        }
      }

      if (!possibleTargets.length) return null;

      const chosen = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
      const srcIdx = (typeof sourcePick.original.index === 'number') ? sourcePick.original.index : 0;
      // compute semitone shift to move source tonic to chosen.idx
      let semitonesRaw = ((chosen.idx - srcIdx) + 120) % 12;
      let sem = semitonesRaw;
      if (sem > 6) sem = sem - 12;

      return { filename: sourcePick.filename, text: sourcePick.text, original: sourcePick.original, chosenTarget: chosen, semitones: sem, meta: sourcePick.meta };
    }

    /* -------------------- initial setup & render -------------------- */
    addAccidentalRangeButtons("keysRangeRowTop","keysRangeRowBottom");
    addExcludeCheckboxes("exRow", excludeTonics);
    document.getElementById('titleValue').textContent = filename || '—';

    // set initial badges and defaults
    currentSpacingLinear = baseOptions.spacingLinear;
    maxDifficulty = 7;
    defaultMaxDifficulty = 7;
    document.getElementById('maxBadge').textContent = String(maxDifficulty);

    /* -------------------- Random button wiring (fixed and with fallback) -------------------- */
    const rb = document.getElementById('randomBtn');
    if (rb) rb.addEventListener('click', async()=>{
      rb.disabled = true;
      showFallbackOriginal = false;
      try {
        const res = await pickRandomTuneAndTranspose();
        if (res) {
          humData = res.text;
          const meta = extractSecondSpineMeta(humData);
          const parsedNum = parseInt((meta.number || '').toString().replace(/[^\d]/g,''), 10);
          if (!isNaN(parsedNum)) {
            defaultMaxDifficulty = clamp(parsedNum,1,7);
            if (maxDifficulty === 7) maxDifficulty = defaultMaxDifficulty;
            setMaxDifficulty(maxDifficulty);
          }
          const pillText = (meta.dir || meta.title || meta.number)
            ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
            : (res.filename || '—');
          document.getElementById('titleValue').textContent = pillText;

          originalKeyIndex = res.original.index;
          originalIsMajor = res.original.isMajor;
          originalAccidentalPref = '';
          currentSemitones = res.semitones;
          octaveShift = 0;
        } else {
          // No candidates matching filters — display a random file for visibility, but mark fallback
          const r = await loadRandomTuneToHumData();
          if (r) {
            humData = r.text;
            const meta = extractSecondSpineMeta(humData);
            const pillText = (meta.dir || meta.title || meta.number)
              ? `${meta.dir ? meta.dir + ' ' : ''}${meta.title ? meta.title : ''}${meta.number ? ' ' + meta.number : ''}`.trim()
              : (r.filename || '—');
            document.getElementById('titleValue').textContent = pillText;

            const k = parseKeyInterpretation(humData||'');
            if (k) {
              originalKeyIndex = keyToIndex(k.letter, k.accidental);
              originalIsMajor = (k.letter === k.letter.toUpperCase());
              originalAccidentalPref =
                (k.accidental === '#' || k.accidental === '♯') ? '#'
                : (k.accidental === 'b' || k.accidental === '♭' || k.accidental === '-') ? 'b'
                : '';
              enharmonicPreference = originalAccidentalPref || enharmonicPreference;
            }
            showFallbackOriginal = true;
            currentSemitones = 0;
            octaveShift = 0;
          }
        }
      } finally {
        rb.disabled = false;
        renderWithTranspose();
      }
    });

    const manageBtn = document.getElementById('manageCollectionBtn');
    if (manageBtn) {
      manageBtn.addEventListener('click', ()=>{
        alert('My Collection management placeholder — implement as needed.');
      });
    }

    renderWithTranspose();
    window.addEventListener('resize', ()=>setTimeout(()=>renderWithTranspose(),150));
  })();
  </script>
</body>
</html>
