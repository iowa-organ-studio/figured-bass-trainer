<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Boyvin Figured Bass Exercises</title>
<script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js"></script>
<script src="https://www.verovio.org/javascript/latest/verovio-toolkit-hum.js"></script>
<style>
:root{
  --bg:#f7f7f9;
  --card:#fff;
  --border:#e6e6ea;
  --ink:#111;
  --muted:#666;
  --gold:#FFCD00;
  --gold-ink:#2b2000;
  --butter:#FFEFAD;
  --grey:#e4e4e7;
  --accent-green:#1f7a4b;
}
html,body{height:100%}
body{
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;
  margin:12px;background:var(--bg);color:var(--ink)
}
.card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px}
header{display:flex;align-items:center;gap:10px;flex-wrap:wrap}

.small{font-size:.9rem;color:var(--muted)}
.row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.spacer{flex:1}

/* ======= Title pills ======= */
.title-badges{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.title-pill{
  padding:6px 10px;border-radius:10px;background:#fff;border:1px solid var(--border);
  font-size:.92rem;font-weight:600;white-space:nowrap
}
#keyPill{ display:inline-block; }
.title-pill small{ color:var(--muted); font-weight:500; margin-left:6px}

/* ======= Buttons ======= */
.btn{
  padding:4px 8px;border-radius:999px;border:1px solid var(--grey);
  background:var(--grey);color:#222;cursor:pointer;font-size:.82rem;line-height:1
}
.btn.selected{background:var(--butter);border-color:var(--gold);color:var(--gold-ink)}

/* Make the select all/none buttons black (not grey) */
#selectAllKeys, #selectNoneKeys, #includeSelectAll, #includeSelectNone { color: var(--ink); background: #fff; border-color: var(--border); font-weight:600; }

/* ======= Chips container line ======= */
.line{
  display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px
}
.group{
  display:flex;align-items:center;gap:8px;
  background:#fff;border:1px solid var(--border);border-radius:10px;padding:6px 8px
}
.group .small{font-size:.82rem;font-weight:700;color:#333}

/* ======= Row 1 ======= */
.new-bass-btn{
  padding:8px 12px;border-radius:999px;border:1px solid #e6b800;background:var(--gold);
  color:var(--gold-ink);font-weight:600;cursor:pointer
}

/* ======= Viewer ======= */
#viewer{ margin-top:8px; }

/* ======= Row 3: Key Range + Scale + Spacing (no outer big card) ======= */
.key-grid{
  display:flex;flex-wrap:nowrap;gap:6px;
}
.key-btn{
  background:var(--grey);border:1px solid var(--border);color:#222;
  padding:6px 8px;border-radius:10px;font-weight:500;cursor:pointer;
  min-width:36px;min-height:28px;box-shadow:0 1px 0 rgba(0,0,0,0.05) inset;
  font-size:.75rem;line-height:1.0
}
.key-btn.selected{background:var(--butter);border-color:var(--gold);color:var(--gold-ink)}
.small-pill{
  background:#fff;border:1px solid var(--border);padding:4px 7px;border-radius:8px;
  font-weight:600;font-size:.82rem;line-height:1
}
/* Hide the sliders visually (keep in DOM for existing JS) */
.slider{ display:none !important; }

/* ======= Row 4: Filters (no big outer card) ======= */
/* Hide labels that used to exist for dir/mode (removed in markup) */
.group[data-role="level"] .small{ display:none }

/* Accidentals radios styled to look like chips, mutually exclusive by native radio */
.radio-inline{display:flex;align-items:center;gap:6px}
.radio-inline input[type="radio"]{position:absolute;opacity:0;width:0;height:0}
.radio-inline label{
  padding:4px 8px;border-radius:999px;border:1px solid var(--grey);
  background:var(--grey);color:#222;font-size:.82rem;line-height:1;cursor:pointer;
  display:inline-flex;align-items:center;gap:6px;
}
.radio-inline label.selected{
  background:var(--butter);border-color:var(--gold);color:var(--gold-ink)
}

/* Level buttons (12) */
.level-grid{ display:flex; gap:6px; flex-wrap:wrap; max-width:520px; }
.level-btn{
  padding:6px 8px;border-radius:8px;border:1px solid var(--border);
  background:#fff;color:var(--ink);cursor:pointer;font-size:.82rem;font-weight:600;
  min-width:34px; text-align:center;
}
.level-btn.toggled, .level-btn.selected{ background:var(--butter); border-color:var(--gold); color:var(--gold-ink) }

/* ======= Include spelled-tonics grid (replaces previous pc-grid) ======= */
.include-grid{display:flex;flex-wrap:wrap;gap:6px;max-width:720px}
.include-btn{
  padding:6px 8px;border-radius:8px;border:1px solid var(--border);
  background:#fff;color:var(--ink);cursor:pointer;font-size:.82rem;font-weight:600;
}
.include-btn.toggled{ background:var(--butter); border-color:var(--gold); color:var(--gold-ink) }

/* ======= Transpose/Octave/Enharmonic — keep in DOM, hide visually ======= */
.controls-row{ display:none !important; }

/* ======= Humdrum collapse helper ======= */
.humdrum-toggle {
  display:inline-flex;align-items:center;gap:8px;background:#fff;border:1px solid var(--border);
  color:#333;border-radius:10px;padding:6px 10px;font-size:.92rem;font-weight:600;cursor:pointer;margin-top:8px
}
.humdrum-toggle:hover{ background:#fdfdfd }
.humdrum-chevron{ font-weight:800;color:#555 }
.humdrum-original-label{ display:none !important }

/* Boyvin signature badge: narrow horizontal image placed to the right of #keyPill */
.boyvin-signature {
  display: inline-block;
  margin-left: 10px;              /* space from key pill */
  vertical-align: middle;
  line-height: 0;                 /* remove inline-gap */
}
.boyvin-signature img {
  display: block;
  max-height: 40px;               /* tune this to taste (px) */
  width: auto;
  height: auto;
  object-fit: contain;
  pointer-events: none;
  user-select: none;
  opacity: 0.98;
}


/* ======= Logo ======= */
#logoAfterFilters img {
  max-width: 66%;
  height: auto;
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</style>
</head>
<body>

<div class="card">
  <!-- ===== Row 1: New Bass Line, Title, Key ===== -->
  <header>
    <button id="randomFiltered" class="new-bass-btn" type="button">New Bass Line</button>
    <div class="title-badges" id="titlePills" aria-hidden="false" style="margin-left:6px">
      <div class="title-pill" id="titlePill">No title <small id="titleSub"></small></div>
      <div class="title-pill" id="keyPill"><span id="keyPillValue">original</span></div>
    </div>
    <div class="spacer"></div>
  </header>

  <!-- ===== Row 2: Music viewer ===== -->
  <div id="viewer" class="card" style="margin-top:8px">
    <div id="svg">Waiting for Verovio…</div>
    <div id="modeTagline" class="small" style="margin-top:8px">
      Created for the University of Iowa Organ Studio
      <span id="historicalStatus" style="margin-left:12px;color:var(--muted)">Historical=TRUE</span>
    </div>
  </div>

  <!-- ===== Row 3: Key Range + Scale + Spacing (NO big card) ===== -->
  <div class="line" id="row3">
    <!-- Key Range -->
    <div class="group" data-role="key-range">
      <div class="small">Key Range</div>
      <div class="key-grid" id="keyGrid">
        <button class="key-btn" data-count="0">0♯/0♭</button>
        <button class="key-btn" data-count="1">1♯/1♭</button>
        <button class="key-btn" data-count="2">2♯/2♭</button>
        <button class="key-btn" data-count="3">3♯/3♭</button>
        <button class="key-btn" data-count="4">4♯/4♭</button>
        <button class="key-btn" data-count="5">5♯/5♭</button>
        <button class="key-btn" data-count="6">6♯/6♭</button>
        <button class="key-btn" data-count="7">7♯/7♭</button>
      </div>
      <div style="display:flex;gap:6px;margin-left:6px">
        <button id="selectAllKeys" class="btn">all</button>
        <button id="selectNoneKeys" class="btn">none</button>
      </div>
    </div>

    <!-- Scale -->
    <div class="group" data-role="scale">
      <div class="small">Scale</div>
      <button class="small-pill" id="scaleReset">reset</button>
      <button class="btn" id="scaleMinus">−</button>
      <button class="btn" id="scalePlus">+</button>
      <div class="small-pill" id="scaleValue">50</div>
      <!-- Keep slider in DOM for JS; hidden with CSS -->
      <div class="slider" aria-hidden="true"><input id="scaleSlider" type="range" min="10" max="120" value="50"></div>
    </div>

    <!-- Spacing -->
    <div class="group" data-role="spacing">
      <div class="small">Spacing</div>
      <button class="small-pill" id="spacingReset">reset</button>
      <button class="btn" id="spacingMinus">−</button>
      <button class="btn" id="spacingPlus">+</button>
      <div class="small-pill" id="spacingValue">0.32</div>
      <!-- Keep slider in DOM for JS; hidden with CSS -->
      <div class="slider" aria-hidden="true"><input id="spacingSlider" type="range" min="10" max="80" value="32"></div>
    </div>
  </div>

  <!-- ===== (Hidden) Transpose/Octave UI kept for JS ======= -->
  <div class="controls-row" style="margin-top:8px">
    <div class="card">
      <div style="font-weight:700">Transpose</div>
      <div style="display:flex;gap:6px">
        <button class="tp-btn" id="tpMinus">−</button>
        <button class="tp-btn" id="tpPlus">+</button>
        <button class="tp-btn" id="tpToggle">♯/♭</button>
      </div>
      <div style="height:6px"></div>
      <div style="font-weight:700">Octave</div>
      <div style="display:flex;gap:6px">
        <button class="tp-btn" id="octMinus">−</button>
        <button class="tp-btn" id="octPlus">+</button>
      </div>
    </div>
  </div>

  <!-- ===== Row 4: Filters (NO big outer card) ======= -->
  <div class="line" id="row4">
    <!-- Left area: Level (12) -->
    <div class="group" data-role="level" style="flex-direction:column;align-items:flex-start">
      <div class="small">Lvl:</div>
      <div id="diffRow" class="level-grid">
        <!-- 12 level buttons -->
        <button class="level-btn btn selected" data-filter="diff" data-value="1">1</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="2">2</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="3">3</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="4">4</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="5">5</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="6">6</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="7">7</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="8">8</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="9">9</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="10">10</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="11">11</button>
        <button class="level-btn btn selected" data-filter="diff" data-value="12">12</button>
      </div>
    </div>

    <div class="group" data-role="accidentals">
      <div class="small" style="min-width:88px">Accidentals:</div>
      <div class="radio-inline" id="accRadioInline">
        <label id="labelHistoric"><input type="radio" name="accMode" value="historic" checked> Historic</label>
        <label id="labelModern"><input type="radio" name="accMode" value="modern"> Modern</label>
      </div>
    </div>

    <!-- Clear filters and Only Complete on same horizontal row (clear -> checkbox) -->
    <div class="group" data-role="clear-and-complete" style="display:flex;align-items:center;gap:12px">
      <div style="display:flex;gap:8px;align-items:center">
        <button id="clearFilters" class="btn">Clear filters</button>
      </div>
      <label class="small" style="display:flex;align-items:center;gap:8px">
        <input type="checkbox" id="onlyCompleteCheckbox" /> Only Complete Exercises
      </label>
    </div>

    <div class="spacer"></div>
  </div>

  <!-- ===== Row 5: Include spelled-tonics (NO big outer card) ===== -->
  <div class="line" id="row5">
    <div class="group" data-role="include">
      <div class="small" style="min-width:64px">Include</div>
      <div style="display:flex;gap:6px">
        <button id="includeSelectAll" class="btn" type="button">all</button>
        <button id="includeSelectNone" class="btn" type="button">none</button>
      </div>
      <div class="include-grid" id="includeGrid" aria-label="Spelled tonics to include (select to restrict)"></div>
    </div>
  </div>

  <!-- ===== Humdrum panel ===== -->
  <label class="small" style="margin-top:8px;display:block">Displayed humdrum / .krn (absolute original shown below):</label>
  <div id="humPanel" class="card" style="margin-top:8px;white-space:pre-wrap;font-family:monospace">(no file loaded)</div>

  <!-- ===== Trace panel (kept for JS, hidden) ===== -->
  <!-- To re-show, remove display:none on this container -->
  <div class="card" style="margin-top:8px; display:none">
    <div class="row">
      <div class="small">Trace:</div>
      <label><input type="checkbox" id="traceToggle"> Trace ON</label>
      <button id="clearTrace" class="btn">Clear trace</button>
      <button id="downloadTrace" class="btn">Download trace</button>
      <div class="spacer"></div>
      <div class="small" id="status">Status: initializing…</div>
    </div>
    <label class="small" style="margin-top:6px;display:block">Trace output (copy &amp; paste here):</label>
    <div id="tracePanel" class="card" style="margin-top:6px;white-space:pre-wrap;font-family:monospace">(trace disabled)</div>
  </div>
</div>

<!-- Logo directly after filters -->
<div id="logoAfterFilters" aria-label="University of Iowa Organ Studio logo">
  <img src="Organ-Studio-LockupStacked-RGB.svg" alt="University of Iowa School of Music">
</div>

<script>
/* ========================================================================== 
   App adapted per user request (fixed rendering clamp + checkbox placement).
   - Removed DIR and MODE buttons.
   - Level buttons expanded to 12.
   - Removed Matching status display.
   - Added "Only Complete Exercises" checkbox (default unchecked).
   - Only Complete & Clear filters are on same row (clear -> checkbox).
   - Safety: clamp scale and spacing values before calling Verovio to avoid
     divide-by-zero errors ("Render failed: divide by 0").
   ========================================================================== */

(async function () {
// -------------------- CONSTANTS --------------------
const BASE_PITCH = { 'C':0,'D':2,'E':4,'F':5,'G':7,'A':9,'B':11 };
const ACC_OFF = { '--': -2, '-': -1, 'n': 0, '#': +1, '##': +2 };
const ACC_GLYPHS = ['--','-','n','#','##'];
const MAJOR_BY_COUNT = {0:['C'],1:['G','F'],2:['D','Bb'],3:['A','Eb'],4:['E','Ab'],5:['B','Db'],6:['F#','Gb'],7:['C#','Cb']};
const MINOR_BY_COUNT = {0:['a'],1:['e','d'],2:['b','g'],3:['f#','c'],4:['c#','f'],5:['g#','bb'],6:['d#','eb'],7:['a#','ab']};
const KEY_TOKEN_RE = /^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/

// -------------------- DOM refs --------------------
const svgHost = document.getElementById('svg');
const humPanel = document.getElementById('humPanel');
const status = document.getElementById('status');

const diffRow = document.getElementById('diffRow');

const randomBtn = document.getElementById('randomFiltered');
const clearBtn = document.getElementById('clearFilters');

const titlePill = document.getElementById('titlePill');
const keyPillValue= document.getElementById('keyPillValue');

const traceToggle = document.getElementById('traceToggle');
const tracePanel = document.getElementById('tracePanel');
const clearTraceBtn = document.getElementById('clearTrace');
const downloadTraceBtn = document.getElementById('downloadTrace');

const modeTagline = document.getElementById('modeTagline');
const historicalStatus = document.getElementById('historicalStatus');

// Accidentals (Historic/Modern)
const accRadios = Array.from(document.querySelectorAll('input[name="accMode"]'));
let ACC_MODE = 'historic'; // 'historic' | 'modern'

// Key range state/UI
const keyButtons = Array.from(document.querySelectorAll('.key-btn'));
const selectAllKeysBtn = document.getElementById('selectAllKeys');
const selectNoneKeysBtn = document.getElementById('selectNoneKeys');
let enabledCounts = new Set([0,1,2,3,4,5,6,7]);

// Include spelled-tonics grid
const includeGridEl = document.getElementById('includeGrid');
const includeSelectAllBtn = document.getElementById('includeSelectAll');
const includeSelectNoneBtn = document.getElementById('includeSelectNone');
let allowedTonicBases = new Set(); // elements like "F#", "B-", "C" where flats use '-' glyph

// Only Complete checkbox
const onlyCompleteCheckbox = document.getElementById('onlyCompleteCheckbox');

// Scale / Spacing (UI-only)
const scaleSlider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');
const spacingSlider = document.getElementById('spacingSlider');
const spacingValue = document.getElementById('spacingValue');
const scaleReset = document.getElementById('scaleReset');
const spacingReset= document.getElementById('spacingReset');
const scaleMinus = document.getElementById('scaleMinus');
const scalePlus = document.getElementById('scalePlus');
const spacingMinus= document.getElementById('spacingMinus');
const spacingPlus = document.getElementById('spacingPlus');

// Transpose / Octave
const tpMinus = document.getElementById('tpMinus');
const tpPlus = document.getElementById('tpPlus');
const tpToggle= document.getElementById('tpToggle');
const octMinus= document.getElementById('octMinus');
const octPlus = document.getElementById('octPlus');

// --- HUMDRUM: default collapsed with chevron toggle (visual-only) ---
(function initHumdrumCollapsed() {
  const humPanelEl = document.getElementById('humPanel');
  if (!humPanelEl) return;

  const humLabel = Array.from(document.querySelectorAll('label.small')).find(l =>
    /displayed humdrum|humdrum/i.test((l.textContent || '').trim())
  );
  if (humLabel) humLabel.classList.add('humdrum-original-label');

  const toggle = document.createElement('button');
  toggle.type = 'button';
  toggle.className = 'humdrum-toggle';
  toggle.setAttribute('aria-expanded', 'false');
  toggle.setAttribute('aria-controls', 'humPanel');

  const chev = document.createElement('span');
  chev.className = 'humdrum-chevron';
  chev.textContent = '►'; // closed

  const txt = document.createElement('span');
  txt.textContent = 'Humdrum panel -- click to open';

  toggle.appendChild(chev);
  toggle.appendChild(txt);

  humPanelEl.parentNode.insertBefore(toggle, humPanelEl);
  humPanelEl.style.display = 'none';

  toggle.addEventListener('click', () => {
    const isOpen = humPanelEl.style.display !== 'none';
    if (isOpen) {
      humPanelEl.style.display = 'none';
      toggle.setAttribute('aria-expanded', 'false');
      chev.textContent = '►';
      txt.textContent = 'Humdrum panel -- click to open';
    } else {
      humPanelEl.style.display = 'block';
      toggle.setAttribute('aria-expanded', 'true');
      chev.textContent = '▼';
      txt.textContent = 'Humdrum panel -- click to close';
    }
  });
})();

// -------------------- Filter state (internal) --------------------
// Now only 'diff' (levels) is a filter set. Dir and mode removed.
const selected = { diff: new Set() };

// make sure catalog exists before any UI code calls currentMatches()
let catalog = [];

// --- DEFAULT SELECTED: Level 1–12
(function initDefaultFilterSelections(){
  // Level 1–12 buttons visually selected by default (markup already includes selected class)
  document.querySelectorAll('#diffRow .btn').forEach(btn => {
    btn.classList.add('selected');
  });

  // Initialize the internal selected set to match the visual defaults:
  Array.from(document.querySelectorAll('#diffRow .btn')).forEach(b => {
    const v = b.dataset.value;
    if (v) selected.diff.add(v);
  });

  // Update counts initially (function does nothing to DOM now, but preserves logic)
  updateMatchCount();
})();

// -------------------- Utils --------------------
function setStatus(txt, isErr){
  if (status) {
    status.textContent = 'Status: ' + txt;
    status.style.color = isErr ? 'crimson' : '';
  }
}
function escapeHtml(str){
  return String(str || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}
function nextLetter(letter){
  return 'CDEFGAB'[('CDEFGAB'.indexOf(letter.toUpperCase()) + 1) % 7];
}
function letterStepsUp(fromLetter, steps){ // steps >= 0
  const order = 'CDEFGAB';
  const i = order.indexOf(fromLetter.toUpperCase());
  return order[(i + (steps % 7) + 7) % 7];
}

// Normalize tonic to Humdrum glyphs ('-', '--', '#', '##', 'n')
function normalizeTonicForHumdrum(s) {
  if (!s) return s;
  const raw = String(s).trim();
  const m = raw.match(/^([A-Ga-g])([#\u266f-]{0,2})?$/);
  if (!m) return raw;
  const letter = m[1];
  let acc = m[2] || '';
  acc = acc
    .replace(/\u266f/g, '#')
    .replace(/\u266d/g, '-')
    .replace(/bb/g, '--')
    .replace(/b/g, '-');
  return letter + acc;
}

// Parse tonic string "A", "Ab", "C#", returns {letter, acc, mode}
function parseTonicString(s){
  if (!s) return null;
  const m = String(s).trim().match(/^([A-Ga-g])([#\u266f-]{0,2})$/);
  if (!m) return null;
  let letter = m[1].toUpperCase();
  let acc = (m[2] || '') || 'n';
  acc = acc.replace(/\u266f/g, '#');
  if (acc === '') acc = 'n';
  return { letter, acc, mode: (m[1] === m[1].toLowerCase() ? 'minor' : 'major') };
}

function spelledToSemitone(letter, glyph){
  const base = BASE_PITCH[letter.toUpperCase()];
  const off = (ACC_OFF[glyph] !== undefined) ? ACC_OFF[glyph] : 0;
  return ((base + off) % 12 + 12) % 12;
}
function semitoneToAccidentalForLetter(letter, targetSemitone){
  for (const g of ACC_GLYPHS){
    const v = ((BASE_PITCH[letter.toUpperCase()] + ACC_OFF[g])%12+12)%12;
    if (v === ((targetSemitone%12)+12)%12) return g;
  }
  return null;
}

// Build key signature scale (letters fixed, accidentals from signature)
function buildScale(tonicStr, mode){
  const parsed = parseTonicString(tonicStr);
  if (!parsed) throw new Error('Bad tonic: ' + tonicStr);
  const pattern = (mode === 'minor') ? [2,1,2,2,1,2,2] : [2,2,1,2,2,2,1];
  const tonicSem = spelledToSemitone(parsed.letter, parsed.acc);
  let letters = [];
  let L = parsed.letter;
  for (let i=0;i<7;i++){
    letters.push(L);
    L = nextLetter(L);
  }
  const sems = [tonicSem];
  for (let i=0;i<6;i++) sems.push((sems[sems.length-1] + pattern[i])%12);
  const scale = [];
  for (let i=0;i<7;i++){
    const letter = letters[i];
    const sem = (sems[i]+12)%12;
    const acc = semitoneToAccidentalForLetter(letter, sem);
    if (!acc) throw new Error(`Cannot spell degree ${i+1} (${letter}) in key ${tonicStr}`);
    scale.push({ letter, acc, semitone: sem });
  }
  return scale;
}

// --------- compute spelled interval from original key to target key ----------
const PERFECT_CLASSES = new Set([1,4,5]);
const MAJOR_BASE = {2:2,3:4,6:9,7:11}; // semitones for Major intervals
const PERFECT_BASE = {1:0,4:5,5:7};

function diatonicDistanceNum(fromLetter, toLetter){
  const order = 'CDEFGAB';
  const a = order.indexOf(fromLetter.toUpperCase());
  const b = order.indexOf(toLetter.toUpperCase());
  const steps = (b - a + 7) % 7; // 0..6
  return steps + 1; // 1..7
}

function computeKeyToKeyInterval(origTonicStr, targetTonicStr){
  const o = parseTonicString(normalizeTonicForHumdrum(origTonicStr));
  const t = parseTonicString(normalizeTonicForHumdrum(targetTonicStr));
  if (!o || !t) throw new Error('Bad tonic(s) for interval');

  const num = diatonicDistanceNum(o.letter, t.letter); // 1..7 upward within octave
  const oSem = spelledToSemitone(o.letter, o.acc);
  const tSem = spelledToSemitone(t.letter, t.acc);
  let semDelta = ((tSem - oSem) % 12 + 12) % 12; // 0..11 (upward class)

  let base = PERFECT_CLASSES.has(num) ? PERFECT_BASE[num] : MAJOR_BASE[num]; // P or M baseline
  // Convert to -2..+2 difference
  let diff = semDelta - base;
  if (diff > 6) diff -= 12; // normalize

  let quality = 'P';
  if (PERFECT_CLASSES.has(num)){
    if (diff === 0) quality = 'P';
    else if (diff === +1) quality = 'A';
    else if (diff === -1) quality = 'd';
    else if (diff === +2) quality = 'AA';
    else if (diff === -2) quality = 'dd';
    else throw new Error(`Unsupported quality for perfect class: diff=${diff}`);
  } else {
    if (diff === 0) quality = 'M';
    else if (diff === -1) quality = 'm';
    else if (diff === +1) quality = 'A';
    else if (diff === -2) quality = 'd';
    else if (diff === +2) quality = 'AA';
    else if (diff === -3) quality = 'dd';
    else throw new Error(`Unsupported quality for major/minor class: diff=${diff}`);
  }
  const totalSemitones = base + diff;
  return { number: num, quality, semitones: ((totalSemitones % 12) + 12) % 12 };
}

// transpose ANY spelled pitch by a spelled interval (letter-preserving) ----------
function transposeSpelledPitchByInterval(originalLetter, originalAcc, interval){
  // Step 1: letter motion
  const targetLetter = letterStepsUp(originalLetter, interval.number - 1);

  // Step 2: target semitone = original semitone + interval.semitones
  const origSem = spelledToSemitone(originalLetter, originalAcc);
  const targSem = ((origSem + interval.semitones) % 12 + 12) % 12;

  // Step 3: choose the accidental for the *fixed target letter* that matches targSem
  const acc = semitoneToAccidentalForLetter(targetLetter, targSem);
  if (!acc) return null; // cannot express with --,-,n,#,##

  return { letter: targetLetter, acc, semitone: targSem };
}

// Diatonic spelling for a numeral above (works for chromatic bass) -------------
function diatonicSpelling(tonicStr, mode, bassSpelled, numeral){
  // Compute the diatonic *letter* N above bass
  let letter = bassSpelled.letter;
  for (let i=1;i<=numeral-1;i++) letter = nextLetter(letter);

  // Key signature defines the accidental for that letter (baseline diatonic)
  const scale = buildScale(tonicStr, mode);
  const entry = scale.find(s => s.letter === letter);
  if (entry) return { letter: entry.letter, acc: entry.acc, semitone: entry.semitone };

  // Fallback (rare): derive semitone by key pattern
  const pattern = (mode === 'minor') ? [2,1,2,2,1,2,2] : [2,2,1,2,2,2,1];
  const bassSem = spelledToSemitone(bassSpelled.letter, bassSpelled.acc);
  let sum = 0;
  for (let i=0;i<numeral-1;i++) sum += pattern[i%7];
  const expSem = ((bassSem + sum)%12+12)%12;
  const g = semitoneToAccidentalForLetter(letter, expSem);
  if (g) return { letter, acc: g, semitone: spelledToSemitone(letter, g) };
  throw new Error(`Unable to diatonically spell numeral ${numeral} above ${bassSpelled.letter}${bassSpelled.acc} in ${tonicStr}`);
}

// Verovio toolkit
let vrv;
const baseOptions = { scale:50, pageWidth:1200, adjustPageHeight:true, spacingLinear:0.32, spacingNonLinear:0.46 };

// -------------------- Verovio init --------------------
async function waitForVerovioGlobal(timeout = 10000) {
  return new Promise((resolve, reject) => {
    const start = performance.now();
    (function poll() {
      if (window.verovio && (window.verovio.toolkit || window.verovio.module)) return resolve();
      if (performance.now() - start > timeout) return reject(new Error('verovio global not available'));
      setTimeout(poll, 40);
    })();
  });
}
async function createToolkitRobust() {
  if (typeof window.verovio === 'undefined') throw new Error('verovio not loaded');
  if (typeof window.verovio.toolkit === 'function') {
    try { return new verovio.toolkit(); } catch(e){}
  }
  const mod = window.verovio && window.verovio.module;
  if (mod && typeof mod.onRuntimeInitialized === 'function') {
    return new Promise((resolve, reject) => {
      const old = mod.onRuntimeInitialized;
      mod.onRuntimeInitialized = function() {
        try {
          const tk = new verovio.toolkit();
          resolve(tk);
        } catch (err) {
          reject(err);
        }
        if (typeof old === 'function') try { old(); } catch(e){}
      };
      if (mod._initialized) {
        try { const tk = new verovio.toolkit(); resolve(tk); } catch (err) { reject(err); }
      }
    });
  }
  await new Promise(r => setTimeout(r, 300));
  if (typeof window.verovio.toolkit === 'function') return new verovio.toolkit();
  throw new Error('Unable to initialize verovio toolkit');
}

try {
  setStatus('waiting for verovio global...');
  await waitForVerovioGlobal();
} catch (e) {
  setStatus('Verovio not found: ' + e.message, true);
  svgHost.textContent = 'Verovio not available';
}
try {
  setStatus('creating verovio toolkit...');
  vrv = await createToolkitRobust();
  if (vrv) vrv.setOptions(baseOptions);
} catch (e) {
  setStatus('Failed to create toolkit: ' + (e.message || e), true);
  svgHost.textContent = 'Toolkit init failed — see console';
}
setStatus('toolkit ready');

// -------------------- Trace --------------------
let TRACE_ON = false;
let traceBuf = [];
function renderTrace(){
  tracePanel.textContent = TRACE_ON ? traceBuf.join('\n') : '(trace disabled)';
}
function traceClear(){ traceBuf = []; renderTrace(); }
function traceLog(msg){
  if (!TRACE_ON) return;
  traceBuf.push(`[${new Date().toISOString()}] ${msg}`);
  if (traceBuf.length > 3000) traceBuf.shift();
  renderTrace();
}
function traceDownload(){
  const blob = new Blob([traceBuf.join('\n')], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'krn-transpose-trace.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
if (traceToggle) traceToggle.addEventListener('change', (e)=>{
  TRACE_ON = e.target.checked;
  renderTrace();
});
if (clearTraceBtn) clearTraceBtn.addEventListener('click', traceClear);
if (downloadTraceBtn) downloadTraceBtn.addEventListener('click', traceDownload);

// -------------------- Courtesy / suppression / modern override --------------------
function suppressThirdFourthSpinesAfterKey(krnText){
  const lines = krnText.split(/\r?\n/);
  let suppress = false;
  return lines.map(line => {
    if (!line.includes('\t')) {
      if (!suppress && KEY_TOKEN_RE.test(line.trim())) suppress = true;
      return line;
    }
    const fields = line.split('\t');
    if (!suppress) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        suppress = true;
        return line;
      }
      return line;
    }
    for (let i = 2; i <= 3 && i < fields.length; i++){
      const tok = (fields[i]||'').trim();
      if (tok !== '*-') fields[i] = '.';
    }
    return fields.join('\t');
  }).join('\n');
}

function applyModernOverride(krnText){
  const lines = krnText.split(/\r?\n/);
  let afterKey = false;
  return lines.map(line => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      return line;
    }
    const fields = line.split('\t');
    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        return line;
      }
      return line;
    }
    if (fields.length >= 3) {
      const s3 = (fields[2] ?? '').trim();
      if (s3 && s3 !== '.' && !s3.startsWith('*') && !s3.startsWith('=') && s3 !== '*-') {
        fields[1] = s3; // spine-3 → spine-2
      }
    }
    return fields.join('\t');
  }).join('\n');
}

// Courtesy from spine-4 (q / Nq) + conflict detection
function applyCourtesyFromSpine4(krnText){
  const lines = krnText.split(/\r?\n/);
  const out = [];
  let afterKey = false;
  let lastBass = null;
  const conflicts = [];
  const firstKeyMatch = krnText.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origKey = firstKeyMatch ? (firstKeyMatch[1] + (firstKeyMatch[2]||'')) : null;
  const origMode = firstKeyMatch ? (firstKeyMatch[1] === firstKeyMatch[1].toUpperCase() ? 'major':'minor') : 'major';
  lines.forEach((line, idx) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      out.push(line);
      return;
    }
    const fields = line.split('\t');
    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        out.push(line);
        return;
      }
      out.push(line);
      return;
    }
    // Track bass (spine-1)
    const f0 = (fields[0]||'').trim();
    const isData = (tok) => tok && tok !== '.' && !tok.startsWith('*') && !tok.startsWith('=');
    if (isData(f0)) {
      const m = f0.match(/([A-Ga-g])([#\u266f-]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }
    if (fields.length >= 4 && origKey && lastBass) {
      const s3 = (fields[2] ?? '').trim();
      const s4 = (fields[3] ?? '').trim();
      const s3Has = isData(s3);
      const s4Has = isData(s4);
      if (s3Has && s4Has) {
        conflicts.push({ line: idx+1, s3, s4 });
        out.push(fields.join('\t'));
        return;
      }
      if (s4Has) {
        const tokens = s4.split(/\s+/);
        const mapped = tokens.map(tok => {
          if (tok === 'q') {
            const dia = diatonicSpelling(origKey, origMode, lastBass, 3);
            return dia.acc; // accidental for diatonic third
          }
          const mq = tok.match(/^(\d+)q$/);
          if (mq) {
            const N = parseInt(mq[1], 10);
            const dia = diatonicSpelling(origKey, origMode, lastBass, N);
            return String(N) + dia.acc;
          }
          return tok;
        });
        fields[1] = mapped.join(' ');
      }
    }
    out.push(fields.join('\t'));
  });
  return { text: out.join('\n'), conflicts };
}

// ------------- Resolve qInSpine2 -------------
function resolveQInSpine2(krnText, targetTonic, targetMode){
  if (!targetTonic) return krnText;

  const lines = krnText.split(/\r?\n/);
  const out = [];
  let afterKey = false;
  let lastBass = null;

  // Original key
  const firstKeyMatch = krnText.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origKey = firstKeyMatch
    ? normalizeTonicForHumdrum(firstKeyMatch[1] + (firstKeyMatch[2]||''))
    : null;

  // Spelled key→key interval (no semitone-delta guessing)
  let spelledInterval = null;
  try {
    if (origKey && targetTonic) {
      spelledInterval = computeKeyToKeyInterval(origKey, targetTonic);
    }
  } catch(e){
    spelledInterval = null;
  }

  const isData = (tok) => tok && tok !== '.' && !tok.startsWith('*') && !tok.startsWith('=') && tok !== '*-';

  lines.forEach((line) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      out.push(line);
      return;
    }
    const fields = line.split('\t');

    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        out.push(line);
        return;
      }
      out.push(line);
      return;
    }

    // Track last bass (original spelled bass on this row)
    const f0 = (fields[0]||'').trim();
    if (isData(f0)) {
      const stripped = String(f0).replace(/^[0-9]+[\.]*/,'').replace(/[^A-Ga-g#\u266f\-b]*$/,'');
      const m = stripped.match(/([A-Ga-g])([#\u266f\-b]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'').replace(/bb/g,'--').replace(/b/g,'-').replace(/\u266f/g,'#') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }

    // Resolve q / Nq in spine-2 using *transposed spelled bass*
    if (fields.length >= 2) {
      const s2 = (fields[1]||'').trim();
      if (isData(s2)) {
        const tokens = s2.split(/\s+/);
        const mapped = tokens.map(tok => {
          if (tok === 'q' || /^(\d+)q$/.test(tok)) {
            if (!lastBass || !spelledInterval) return tok;
            const newBass = transposeSpelledPitchByInterval(lastBass.letter, lastBass.acc, spelledInterval);
            if (!newBass) return tok;
            const N = (tok === 'q') ? 3 : parseInt(tok.match(/^(\d+)q$/)[1], 10);
            const dia = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic).trim()), targetMode, newBass, N);
            return (tok === 'q') ? (dia.acc || 'n') : (String(N) + (dia.acc || 'n'));
          }
          return tok;
        });
        fields[1] = mapped.join(' ');
      }
    }

    out.push(fields.join('\t'));
  });

  return out.join('\n');
}

// -------------------- Figure-aware transform (spines 1 & 2) --------------------
function transformFiguresForTonicWithTrace(originalKrn, targetTonic, targetMode){
  traceLog(`TRANSPOSE START => targetTonic=${targetTonic} targetMode=${targetMode}`);

  const origKeyMatch = originalKrn.match(/^\*([A-Ga-g])([#\u266f-]{0,2})\s*:/m);
  const origTonicStr = origKeyMatch
    ? normalizeTonicForHumdrum(origKeyMatch[1] + (origKeyMatch[2]||'')) 
    : null;

  if (!origTonicStr) {
    traceLog('ERROR: original key token not found; abort');
    return originalKrn;
  }

  const origParsed = parseTonicString(origTonicStr);
  const targetParsed = parseTonicString(normalizeTonicForHumdrum(String(targetTonic || '').trim()));

  if (!origParsed || !targetParsed) {
    traceLog('ERROR: parse tonic failed');
    return originalKrn;
  }

  // Spelled interval between keys (letter-preserving)
  let spelledInterval = null;
  try {
    spelledInterval = computeKeyToKeyInterval(origTonicStr, targetTonic);
  } catch (e) {
    traceLog('ERROR: key->key interval failed: ' + e.message);
    return originalKrn;
  }

  const lines = originalKrn.split(/\r?\n/);
  let afterKey = false;
  let lastBass = null; // original spelled bass
  const outLines = [];

  lines.forEach((line, lineno) => {
    if (!line.includes('\t')) {
      if (!afterKey && KEY_TOKEN_RE.test(line.trim())) afterKey = true;
      outLines.push(line);
      return;
    }
    const fields = line.split('\t');

    if (!afterKey) {
      if (fields.some(f => KEY_TOKEN_RE.test((f||'').trim()))) {
        afterKey = true;
        outLines.push(line);
        return;
      }
      outLines.push(line);
      return;
    }

    // Bass from spine-1 (original spelled bass)
    const f0 = (fields[0]||'').trim();
    if (f0 && f0 !== '.' && !f0.startsWith('*') && !f0.startsWith('=')) {
      const m = f0.match(/([A-Ga-g])([#\u266f-]{0,2})$/);
      if (m) {
        const letter = m[1].toUpperCase();
        const accraw = (m[2]||'') || 'n';
        lastBass = { letter, acc: accraw, semitone: spelledToSemitone(letter, accraw) };
      }
    }

    // Target spelled bass via *spelled* interval (always try to compute)
    let newBassSpelled = null;
    if (lastBass && spelledInterval) {
      newBassSpelled = transposeSpelledPitchByInterval(lastBass.letter, lastBass.acc, spelledInterval);
      if (!newBassSpelled) {
        traceLog(`ERROR: cannot spell new bass for ${lastBass.letter}${lastBass.acc} by interval ${spelledInterval.number}${spelledInterval.quality}; leaving row unchanged`);
      }
    }

    // Process spine-2 only
    if (fields.length >= 2) {
      const originalCell = fields[1] || '';
      const tokens = originalCell.trim() === '' ? [] : originalCell.trim().split(/\s+/);

      const newTokens = tokens.map(tok => {
        // Keep-as-is tokens: \d+#\|, numeral ending with / or \, and literal "5-" only in historic mode
        if (/^\d+#\|$/.test(tok) || /^\d+[\/\\]$/.test(tok) || (ACC_MODE === 'historic' && /^5-$/.test(tok))) {
          return tok;
        }

        // Accidental-only (standalone) — refers to diatonic third
        if (/^(--|##|#|-|n)$/.test(tok)) {
          const numeral = 3;
          if (!lastBass || !newBassSpelled) {
            traceLog(`WARN: standalone accidental ${tok} but bass unknown or cannot spell new bass; leaving token as-is`);
            return tok;
          }
          try {
            const origDiat = diatonicSpelling(origTonicStr, origParsed.mode, lastBass, numeral);
            const origDiatSem = spelledToSemitone(origDiat.letter, origDiat.acc);
            const producedSem = spelledToSemitone(origDiat.letter, tok);

            // STASIS: produced equals diatonic
            if (producedSem === origDiatSem) {
              const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
              return tgtDiat.acc;
            }

            let dirRaw = (producedSem - origDiatSem + 12) % 12;
            let dir;
            if (dirRaw === 0) dir = 0;
            else if (dirRaw === 1) dir = +1;
            else if (dirRaw === 11) dir = -1;
            else dir = (dirRaw <= 6) ? dirRaw : dirRaw - 12;
            if (Math.abs(dir) > 2) {
              traceLog(`ERROR: standalone accidental ${tok} produced dir=${dir} outside allowed range; leaving token unchanged`);
              return tok;
            }

            const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
            const finalSem = ((tgtDiat.semitone + dir)%12+12)%12;
            const finalAcc = semitoneToAccidentalForLetter(tgtDiat.letter, finalSem);
            if (!finalAcc) {
              traceLog(`ERROR: cannot safely spell altered diatonic ${numeral} above ${newBassSpelled.letter}${newBassSpelled.acc} in ${targetTonic}; leaving token ${tok} unchanged`);
              return tok;
            }
            return finalAcc;
          } catch (e) {
            traceLog(`ERROR (standalone accidental): ${e.message}; leaving ${tok} unchanged`);
            return tok;
          }
        }

        // Numeral with optional accidental
        const m2 = tok.match(/^(\d+)(--|##|#|-|n)?$/);
        if (!m2) return tok;

        const numeral = parseInt(m2[1], 10);
        const accPart = m2[2] || '';

        if (!lastBass || !newBassSpelled) {
          traceLog(`WARN: numeral ${tok} but no bass/new-bass-known; leaving token as-is`);
          return tok;
        }
        if (!accPart) return tok; // unaltered, port as-is

        try {
          const origDiat = diatonicSpelling(origTonicStr, origParsed.mode, lastBass, numeral);
          const origDiatSem = spelledToSemitone(origDiat.letter, origDiat.acc);
          const producedSem = spelledToSemitone(origDiat.letter, accPart);

          // STASIS
          if (producedSem === origDiatSem) {
            const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
            return String(numeral) + tgtDiat.acc;
          }

          let dirRaw = (producedSem - origDiatSem + 12) % 12;
          let dir;
          if (dirRaw === 0) dir = 0;
          else if (dirRaw === 1) dir = +1;
          else if (dirRaw === 11) dir = -1;
          else dir = (dirRaw <= 6) ? dirRaw : dirRaw - 12;

          if (dir === 0) return tok;
          if (Math.abs(dir) > 2) {
            traceLog(`ERROR: alteration for ${tok} yields dir=${dir} outside allowed range; leaving token unchanged`);
            return tok;
          }

          const tgtDiat = diatonicSpelling(normalizeTonicForHumdrum(String(targetTonic || '').trim()), targetMode, newBassSpelled, numeral);
          const finalSem = ((tgtDiat.semitone + dir)%12+12)%12;
          const finalAcc = semitoneToAccidentalForLetter(tgtDiat.letter, finalSem);
          if (!finalAcc) {
            traceLog(`ERROR: cannot safely spell transformed numeral ${numeral} above ${tgtDiat.letter} in ${targetTonic}; leaving ${tok} unchanged`);
            return tok;
          }
          return String(numeral) + finalAcc;
        } catch (e) {
          traceLog(`ERROR (numeral transform): ${e.message}; leaving ${tok} unchanged`);
          return tok;
        }
      });

      fields[1] = newTokens.join(' ');
    }

    // Suppress spines 3 & 4
    for (let i = 2; i <= 3 && i < fields.length; i++){
      const tok = (fields[i]||'').trim();
      if (tok !== '*-') fields[i] = '.';
    }

    outLines.push(fields.join('\t'));
  });

  traceLog('TRANSPOSE END');
  return outLines.join('\n');
}

// -------------------- Catalog / filters / UI --------------------
function capitalize(s){ return String(s || '').replace(/^\w/, c => c.toUpperCase()); }
// -------------------- Replace this function in your script --------------------
function updatePillsFromCatalogEntry(entry){
  // If no entry, reset to default
  if (!entry) {
    titlePill.innerHTML = 'No title <small id="titleSub"></small>';
    return;
  }

  // Prefer full raw title if present, otherwise fallback to "Rule of the Octave" + diff
  const title = (entry.title && String(entry.title).trim()) ? String(entry.title).trim() : '';
  const rawNumber = (entry.rawNumber && String(entry.rawNumber).trim()) ? String(entry.rawNumber).trim() : '';

  // Build display: prefer "title rawNumber" if either exists; otherwise fallback
  let display = '';
  if (title && rawNumber) display = `${title} ${rawNumber}`;
  else if (title) display = title;
  else if (rawNumber) display = rawNumber;
  else {
    // Original fallback behavior: keep an intelligible label
    const lvl = entry?.diff != null ? String(entry.diff) : '';
    const core = 'Rule of the Octave';
    display = lvl ? `${core} ${lvl}` : core;
  }

  // Put the combined text into the pill; keep a small sub-slot empty for future use
  titlePill.innerHTML = escapeHtml(display) + ' <small id="titleSub"></small>';
}

function formatKeyName(tonic, mode){
  if (!tonic) return 'original';
  const m = String(tonic).trim().match(/^([A-Ga-g])(.+)?$/);
  if (!m) return tonic + ' ' + (mode === 'minor' ? 'minor' : 'major');
  let letter = m[1], acc = m[2] || '';
  acc = acc.replace(/bb/g, '♭♭').replace(/b/g, '♭').replace(/#/g, '♯').replace(/--/g,'♭♭').replace(/-/g,'♭');
  const root = (mode === 'minor') ? letter.toLowerCase() : letter.toUpperCase();
  return root + acc + ' ' + (mode === 'minor' ? 'minor' : 'major');
}
function updateKeyPill(tonic, mode){
  keyPillValue.textContent = formatKeyName(tonic, mode);
  if (!tonic) document.getElementById('keyPill').style.display = 'none';
  else document.getElementById('keyPill').style.display = '';
}

let currentKrn = '';
let currentEntry = null;
let lastTargetTonic = '';
let lastTargetMode = '';
let lastOriginalKey = '';
let lastOriginalMode = '';
let lastRenderTranspose = ''; // what was sent to verovio transpose (tonic or numeric)
let transposePreferFlats = false;
let currentRenderSemitoneShift = 0;

// -------------------- Fetch helpers --------------------
async function fetchList(){
  try {
    const r = await fetch('tunes.json?_=' + Date.now(), { cache:'no-cache' });
    if (!r.ok) return [];
    const arr = await r.json();
    const list = Array.isArray(arr) ? arr : (Array.isArray(arr.files) ? arr.files : []);
    return (list || []).map(x => String(x).replace(/^\/+/, ''));
  } catch(e){
    return [];
  }
}
async function fetchText(path){
  const p = path.startsWith('tunes/') ? path : 'tunes/' + path;
  const r = await fetch(p + '?_=' + Date.now(), { cache:'no-cache' });
  if (!r.ok) throw new Error('fetch failed: ' + p);
  const t = await r.text();
  return { path: p, text: t };
}

// metaFromHeader: now captures rawNumber string (full token after "!! Number")
// 'diff' is the numeric first digit if present (used for level)
function metaFromHeader(krn){
  const lines = krn.split(/\r?\n/).slice(0, 120);
  let dir = null, diff = null, title = null, mode = null, rawNumber = null;
  for (const ln of lines){
    const s = (ln||'').trim();
    if (!s || !s.startsWith('!!')) continue;
    const titleMatch = s.match(/^!!\s*(?:Title|T)\s+(.*)$/i);
    if (titleMatch && titleMatch[1] && !title){
      title = titleMatch[1].trim();
      continue;
    }
    const numMatch = s.match(/^!!\s*Number\s+(.+)$/i);
    if (numMatch && numMatch[1]){
      rawNumber = numMatch[1].trim();
      // diff is first digit found (if any)
      const firstDigit = rawNumber.match(/\d/);
      if (firstDigit) diff = parseInt(firstDigit[0], 10);
      continue;
    }
    const dirLine = s.match(/^!!\s*Dir\b(.*)$/i);
    if (dirLine){
      const rest = dirLine[1];
      if (/ascending/i.test(rest)) dir = 'ascending';
      if (/descending/i.test(rest)) dir = 'descending';
      if (/major/i.test(rest)) mode = 'major';
      if (/minor/i.test(rest)) mode = 'minor';
      continue;
    }
  }
  if (!mode) {
    const m = krn.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m);
    if (m) mode = (m[1] === m[1].toUpperCase()) ? 'major' : 'minor';
  }
  return { dir, mode, diff, title, rawNumber };
}

async function buildCatalog(paths, concurrency=4){
  catalog = [];
  let i = 0;
  const results = [];
  async function worker(){
    while (i < paths.length){
      const idx = i++;
      const raw = paths[idx];
      if (!/\.(krn|hum|txt)$/i.test(raw)) continue;
      try {
        const { path, text } = await fetchText(raw);
        const meta = metaFromHeader(text);
        results.push({ path, dir: meta.dir, mode: meta.mode, diff: meta.diff, title: meta.title, rawNumber: meta.rawNumber, text });
      } catch(e){ /* skip */ }
    }
  }
  await Promise.all(Array.from({length:concurrency}, worker));
  catalog = results;
  updateMatchCount();
}

function pickRandom(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

// matchesFilters now checks selected.diff and onlyComplete checkbox
function matchesFilters(item){
  // Level filter
  if (selected.diff.size){
    const d = String(item.diff ?? '');
    if (!selected.diff.has(d)) return false;
  }
  // Only Complete Exercises checkbox: require rawNumber to be purely digits
  if (onlyCompleteCheckbox && onlyCompleteCheckbox.checked) {
    const rn = String(item.rawNumber || '');
    if (!/^\d+$/.test(rn)) return false;
  }
  return true;
}

function currentMatches(){ return catalog.filter(matchesFilters); }
// updateMatchCount intentionally does not modify any removed DOM matching elements.
// It is kept to preserve call-sites without causing errors.
function updateMatchCount(){
  // no-op for UI (matching display removed per request)
}

// -------------------- Key button helpers (fixed) --------------------
function refreshKeyButtonsUI(){
  keyButtons.forEach(btn => {
    const c = Number(btn.dataset.count);
    if (enabledCounts.has(c)) btn.classList.add('selected');
    else btn.classList.remove('selected');
  });
}
refreshKeyButtonsUI();
keyButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const c = Number(btn.dataset.count);
    if (enabledCounts.has(c)) {
      enabledCounts.delete(c);
    } else {
      enabledCounts.add(c);
    }
    refreshKeyButtonsUI();
    updateMatchCount();
  });
});
selectAllKeysBtn.addEventListener('click', () => {
  for (let i=0;i<=7;i++) enabledCounts.add(i);
  refreshKeyButtonsUI();
  updateMatchCount();
  // also select all spelled-tonics for convenience
  selectAllIncludeTonics();
});
selectNoneKeysBtn.addEventListener('click', () => {
  enabledCounts.clear();
  refreshKeyButtonsUI();
  updateMatchCount();
  // also clear include spelled-tonics
  clearAllIncludeTonics();
});

// -------------------- Build allowed tonics (original) --------------------
function buildAllowedTonicsForMode(mode){
  const byCount = (mode === 'minor') ? MINOR_BY_COUNT : MAJOR_BY_COUNT;
  const allowed = [];
  for (const cStr of Object.keys(byCount)){
    const c = Number(cStr);
    if (!enabledCounts.has(c)) continue;
    for (const tonic of byCount[c] || []) allowed.push(tonic);
  }
  return allowed;
}

// -------------------- INCLUDE grid wiring (spelled-tonics) --------------------
function uniqueTonicBasesFromMaps(){
  const set = new Set();
  for (const arr of Object.values(MAJOR_BY_COUNT)) for (const t of arr) {
    const n = normalizeTonicForHumdrum(t);
    if (!n) continue;
    const p = parseTonicString(n);
    if (!p) continue;
    const base = p.letter + (p.acc === 'n' ? '' : p.acc);
    set.add(base);
  }
  for (const arr of Object.values(MINOR_BY_COUNT)) for (const t of arr) {
    const n = normalizeTonicForHumdrum(t);
    if (!n) continue;
    const p = parseTonicString(n);
    if (!p) continue;
    const base = p.letter + (p.acc === 'n' ? '' : p.acc);
    set.add(base);
  }
  return Array.from(set).sort((a,b)=>{
    const order='CDEFGAB';
    const ia = order.indexOf(a[0]), ib = order.indexOf(b[0]);
    if (ia !== ib) return ia-ib;
    if (a.length !== b.length) return a.length - b.length;
    return a.localeCompare(b);
  });
}

function renderIncludeButtons(){
  const list = uniqueTonicBasesFromMaps();
  includeGridEl.innerHTML = '';
  list.forEach(base => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'include-btn';
    const display = base.replace(/--/g,'♭♭').replace(/-/g,'♭').replace(/#/g,'♯');
    btn.textContent = display;
    btn.dataset.base = base;
    btn.addEventListener('click', () => {
      const b = btn.dataset.base;
      if (allowedTonicBases.has(b)) {
        allowedTonicBases.delete(b);
        btn.classList.remove('toggled');
      } else {
        allowedTonicBases.add(b);
        btn.classList.add('toggled');
      }
    });
    includeGridEl.appendChild(btn);
  });
}
renderIncludeButtons();

function selectAllIncludeTonics(){
  allowedTonicBases.clear();
  const btns = Array.from(includeGridEl.querySelectorAll('.include-btn'));
  btns.forEach(btn => {
    const b = btn.dataset.base;
    allowedTonicBases.add(b);
    btn.classList.add('toggled');
  });
}
function clearAllIncludeTonics(){
  allowedTonicBases.clear();
  const btns = Array.from(includeGridEl.querySelectorAll('.include-btn'));
  btns.forEach(btn => btn.classList.remove('toggled'));
}

// Wire the include all/none buttons
if (includeSelectAllBtn) {
  includeSelectAllBtn.addEventListener('click', () => {
    selectAllIncludeTonics();
  });
}
if (includeSelectNoneBtn) {
  includeSelectNoneBtn.addEventListener('click', () => {
    clearAllIncludeTonics();
  });
}

// -------------------- Effective allowed tonics (updated) --------------------
function getEffectiveAllowedTonicsForMode(mode){
  // If the user selected spelled tonics, filter allowed tonics by these bases.
  const allowedByCount = buildAllowedTonicsForMode(mode);
  if (allowedTonicBases.size === 0) return allowedByCount;

  const out = [];
  // Prepare allowed base specs: {letter, accOrEmpty}
  const allowedSpecs = Array.from(allowedTonicBases).map(b => {
    const letter = b[0].toUpperCase();
    const acc = b.length > 1 ? b.slice(1) : '';
    return {letter, acc};
  });

  for (const t of allowedByCount){
    const n = normalizeTonicForHumdrum(t);
    const p = parseTonicString(n);
    if (!p) continue;
    const candLetter = p.letter; // uppercase
    const candAcc = p.acc === 'n' ? '' : p.acc; // '' | '#' | '-'
    // If any allowedSpec matches this candidate:
    for (const spec of allowedSpecs){
      if (candLetter !== spec.letter) continue;
      const specAcc = spec.acc; // '' | '#' | '-'
      if (specAcc === '') {
        if (candAcc === '') { out.push(t); break; }
      } else {
        if (candAcc === specAcc) { out.push(t); break; }
      }
    }
  }

  return out;
}

// -------------------- Rendering --------------------
function getCurrentScaleSpacing(){
  const scale = (scaleSlider && scaleSlider.value) ? Number(scaleSlider.value) : baseOptions.scale;
  // compute spacingLinear from slider (value/100). If missing, use baseOptions.
  const spacingLinear = (spacingSlider && spacingSlider.value) ? Number(spacingSlider.value)/100 : baseOptions.spacingLinear;
  return { scale, spacingLinear };
}
function tonicToVerovioAscii(tonic) {
  if (!tonic) return '';
  return String(tonic)
    .replace(/--/g, 'bb')
    .replace(/-/g, 'b')
    .replace(/\u266d/g, 'b')
    .replace(/\u266f/g, '#');
}
function renderWithVerovio(krnText, tonicForRender){
  try {
    const { scale, spacingLinear } = getCurrentScaleSpacing();

    // Determine a safe container width for pageWidth.
    // svgHost.clientWidth may be 0 if the element is not yet laid out.
    // Use a conservative fallback and enforce Verovio's minimum (100).
    let containerWidth = 0;
    try { containerWidth = Math.round(svgHost.clientWidth || 0); } catch(e){ containerWidth = 0; }
    if (!containerWidth || containerWidth < 100) {
      // Use a reasonable fallback that won't trigger Verovio bounds error.
      // 900 is what you used previously; 1200 is also safe. Choose 900 to keep similar layout.
      containerWidth = 900;
    }
    // Now apply options ensuring pageWidth is within allowed range.
    const verovioOptions = {
      ...baseOptions,
      pageWidth: containerWidth,
      scale: Number(scale),
      spacingLinear: Number(spacingLinear),
      transpose: (currentRenderSemitoneShift && !isNaN(Number(currentRenderSemitoneShift))) ? String(Number(currentRenderSemitoneShift)) : (tonicForRender ? tonicToVerovioAscii(String(tonicForRender)) : '')
    };

    // Track what we're sending to verovio (useful for trace/debug)
    lastRenderTranspose = verovioOptions.transpose || '';

    if (vrv) {
      vrv.setOptions(verovioOptions);
      const svg = vrv.renderData(krnText || '', {});
      svgHost.innerHTML = svg;
    } else {
      svgHost.textContent = '(verovio not initialized) — preview disabled';
    }
  } catch (e) {
    svgHost.textContent = 'Render failed: ' + (e?.message || e);
    traceLog('renderWithVerovio error: ' + (e?.message || e));
  }
}


// -------------------- Pipeline --------------------
function runPipelineForEntry(entry, tonic, m){
  const originalAbsolute = entry.text;

  // Modern override
  let prepared = entry.text;
  if (ACC_MODE === 'modern') {
    prepared = applyModernOverride(prepared);
    modeTagline.innerHTML = 'Created for the University of Iowa Organ Studio';
  } else {
    modeTagline.innerHTML = 'Created for the University of Iowa Organ Studio';
  }
  historicalStatus.textContent = `Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}`;

  // Courtesy
  const { text: withCourtesy, conflicts } = applyCourtesyFromSpine4(prepared);
  if (conflicts.length){
    const msg = `ERROR: figures present in both spine-3 and spine-4 on ${conflicts.length} row(s) — e.g., line ${conflicts[0].line}.`;
    setStatus(msg, true);
    traceLog(msg);
  } else {
    setStatus(`Loaded: ${entry.path} — mode=${m}${tonic?', target='+tonic:''}`);
  }

  // Resolve q/Nq now that s3→s2 may have occurred
  const withResolvedQ = resolveQInSpine2(withCourtesy, tonic, m);

  // Suppress spines 3 & 4 (text to Verovio)
  const suppressed = suppressThirdFourthSpinesAfterKey(withResolvedQ);
  const krnSentToVerovio = suppressed;

  // Figure-aware transform using spelled interval + chromatic-bass support
  const transformed = transformFiguresForTonicWithTrace(
    krnSentToVerovio,
    String(tonic || '').trim(),
    m
  );
  currentKrn = transformed;

  // Humdrum panel
  humPanel.textContent = '';
  humPanel.textContent += '## 1) ORIGINAL .krn (absolute source)\n\n';
  humPanel.textContent += originalAbsolute + '\n\n';
  humPanel.textContent += '## 2) .krn sent to Verovio (after modern override + courtesy + q-resolve; then suppressed)\n\n';
  humPanel.textContent += krnSentToVerovio + '\n\n';
  humPanel.textContent += `## TARGET KEY: ${formatKeyName(tonic, m)}\n\n`;
  humPanel.textContent += '## 3) Transpose output (after figure-aware transform)\n\n';
  humPanel.textContent += currentKrn + '\n\n';
  humPanel.textContent += `## 4) Historical mode status: Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}\n`;

  // Remember keys so toggles can act
  lastTargetTonic = tonic;
  lastTargetMode = m;

  // Reset numeric render shift (octave) when we start a new pipeline run
  currentRenderSemitoneShift = 0;

  // Update badge and render
  updateKeyPill(tonic, m);
  renderWithVerovio(currentKrn, tonic);
}

// -------------------- Sample / Random --------------------
const sample = `**kern\t**fb\t**text\t**text
!!\t\tactual acc.\tforce diatonic accidental
!! Dir\tDescending Minor
!! Title\tRule of the Octave
!! Number\t4
*clefF4\t*\t*\t*
*k[]\t*k[]\t*k[]\t*k:
*a:\t*a:\t*a:\t*a:
=1\t=1\t.\t.
4D\t.\t.\t.
4d[\t.\t.\t.
4d]\t2\t.\t.
4c#\t.\t.\t.
*-\t*-\t*-\t*-`;

// -------------------- Enharmonic toggle sets --------------------
const ENH_MAJOR_PAIRS = [['C#','Db'], ['F#','Gb']];
const ENH_MINOR_PAIRS = [['Eb','D#'], ['Ab','G#'], ['A#','Bb']];

function findEnhPairContaining(name, mode){
  if (!name) return null;
  const norm = normalizeTonicForHumdrum(name);
  const pairs = (mode === 'minor') ? ENH_MINOR_PAIRS : ENH_MAJOR_PAIRS;
  for (const pair of pairs){
    for (const p of pair){
      if (normalizeTonicForHumdrum(p) === norm) return pair;
    }
  }
  return null;
}

// -------------------- Semitone/tonic helpers for tp+/- --------------------
function semitoneToTonicName(targetSemitone, mode, preferFlats){
  const byCount = (mode === 'minor') ? MINOR_BY_COUNT : MAJOR_BY_COUNT;
  const candidates = [];
  for (const arr of Object.values(byCount)){
    for (const t of arr) candidates.push(t);
  }
  const matches = candidates.filter(t => {
    const n = normalizeTonicForHumdrum(t);
    const p = parseTonicString(n);
    if (!p) return false;
    return spelledToSemitone(p.letter, p.acc) === ((targetSemitone%12)+12)%12;
  });
  if (!matches.length) return null;
  if (matches.length === 1) return matches[0];
  const flats = matches.filter(x => /b|--|-/.test(x));
  const sharps = matches.filter(x => /#/.test(x));
  if (preferFlats && flats.length) return flats[0];
  if (!preferFlats && sharps.length) return sharps[0];
  return matches[0];
}

function pickSpelledTonicBySemitoneStep(currentSpelledTonic, mode, step){
  const baseParsed = parseTonicString(normalizeTonicForHumdrum(currentSpelledTonic));
  if (!baseParsed) return null;
  const baseSem = spelledToSemitone(baseParsed.letter, baseParsed.acc);
  const newSem = ((baseSem + step) % 12 + 12) % 12;
  const candidatesAllowed = buildAllowedTonicsForMode(mode);
  for (const cand of candidatesAllowed){
    const p = parseTonicString(normalizeTonicForHumdrum(cand));
    if (!p) continue;
    if (spelledToSemitone(p.letter, p.acc) === newSem) return normalizeTonicForHumdrum(cand);
  }
  const standard = semitoneToTonicName(newSem, mode, transposePreferFlats);
  if (standard) return normalizeTonicForHumdrum(standard);
  if (candidatesAllowed && candidatesAllowed.length){
    const normList = candidatesAllowed.map(x => normalizeTonicForHumdrum(x));
    let idx = normList.indexOf(normalizeTonicForHumdrum(currentSpelledTonic));
    if (idx < 0) idx = 0;
    const next = normList[(idx + (step>0?1:-1) + normList.length) % normList.length];
    return normalizeTonicForHumdrum(next);
  }
  return null;
}

// -------------------- Transpose control wiring --------------------
function setTargetTonic(tonic){
  if (!currentEntry) { traceLog('setTargetTonic: no current entry'); return; }
  const t = normalizeTonicForHumdrum(tonic);
  lastTargetTonic = t;
  lastTargetMode = lastTargetMode || currentEntry.mode || 'major';
  currentRenderSemitoneShift = 0;
  runPipelineForEntry(currentEntry, t, lastTargetMode);
}

if (tpPlus) tpPlus.addEventListener('click', () => {
  traceLog('tpPlus pressed (semitone up)');
  if (!lastTargetTonic || !lastTargetMode) { traceLog('tpPlus: no current spelled tonic; nothing to do'); return; }
  const next = pickSpelledTonicBySemitoneStep(lastTargetTonic, lastTargetMode, +1);
  if (next) { traceLog(`tpPlus -> chosen spelled tonic ${next}`); setTargetTonic(next); } else { traceLog('tpPlus: failed to find next spelled tonic - no change'); }
});
if (tpMinus) tpMinus.addEventListener('click', () => {
  traceLog('tpMinus pressed (semitone down)');
  if (!lastTargetTonic || !lastTargetMode) { traceLog('tpMinus: no current spelled tonic; nothing to do'); return; }
  const next = pickSpelledTonicBySemitoneStep(lastTargetTonic, lastTargetMode, -1);
  if (next) { traceLog(`tpMinus -> chosen spelled tonic ${next}`); setTargetTonic(next); } else { traceLog('tpMinus: failed to find next spelled tonic - no change'); }
});

if (tpToggle) tpToggle.addEventListener('click', () => {
  traceLog('tpToggle clicked');
  if (!lastTargetTonic || !lastTargetMode) {
    transposePreferFlats = !transposePreferFlats;
    tpToggle.classList.toggle('active', transposePreferFlats);
    traceLog('tpToggle: no spelled tonic loaded; toggled preferFlats=' + transposePreferFlats);
    return;
  }
  const pair = findEnhPairContaining(lastTargetTonic, lastTargetMode);
  if (!pair) {
    transposePreferFlats = !transposePreferFlats;
    tpToggle.classList.toggle('active', transposePreferFlats);
    traceLog('tpToggle: no pair for ' + lastTargetTonic + '; preferFlats=' + transposePreferFlats);
    updateKeyPill(lastTargetTonic, lastTargetMode);
    return;
  }
  const norm = normalizeTonicForHumdrum(lastTargetTonic);
  const other = normalizeTonicForHumdrum(pair[0]) === norm ? pair[1] : pair[0];
  traceLog(`tpToggle: switching ${norm} -> ${other}`);
  setTargetTonic(other);
  transposePreferFlats = /b|--|-/.test(other);
  tpToggle.classList.toggle('active', transposePreferFlats);
});

// -------------------- Octave buttons (render-only numeric transpose) --------------------
function applyRenderSemitoneShift(delta){
  // accumulate numeric render shifts (12 per octave)
  currentRenderSemitoneShift = (currentRenderSemitoneShift || 0) + delta;
  traceLog(`applyRenderSemitoneShift => ${currentRenderSemitoneShift}`);
  // Re-render with same pipeline-output KRn, but numeric transpose to verovio.
  renderWithVerovio(currentKrn || sample, lastTargetTonic || '');
  // Keep key pill showing the spelled target key (do not change it)
  updateKeyPill(lastTargetTonic || '', lastTargetMode || '');
}
if (octPlus) octPlus.addEventListener('click', () => { traceLog('octPlus clicked'); applyRenderSemitoneShift(+12); });
if (octMinus) octMinus.addEventListener('click', () => { traceLog('octMinus clicked'); applyRenderSemitoneShift(-12); });

// -------------------- Accidentals toggle re-run + label visuals --------------------
const labelHistoric = document.getElementById('labelHistoric');
const labelModern = document.getElementById('labelModern');
function updateAccLabelVisuals(){
  const checked = document.querySelector('input[name="accMode"]:checked');
  if (checked && checked.value === 'modern') {
    labelModern.classList.add('selected');
    labelHistoric.classList.remove('selected');
  } else {
    labelHistoric.classList.add('selected');
    labelModern.classList.remove('selected');
  }
}
accRadios.forEach(r => {
  r.addEventListener('change', () => {
    if (!r.checked) return;
    ACC_MODE = r.value === 'modern' ? 'modern' : 'historic';
    updateAccLabelVisuals();
    traceLog(`Accidentals mode changed => ${ACC_MODE}`);
    if (currentEntry && lastTargetTonic && lastTargetMode) {
      runPipelineForEntry(currentEntry, lastTargetTonic, lastTargetMode);
    } else {
      modeTagline.innerHTML = (ACC_MODE === 'modern')
        ? 'Created for the University of Iowa Organ Studio'
        : 'Created for the University of Iowa Organ Studio';
      historicalStatus.textContent = `Historical=${ACC_MODE==='historic' ? 'TRUE' : 'FALSE'}`;
    }
  });
});
updateAccLabelVisuals(); // initialize visual

// -------------------- Filter button wiring --------------------
// Utility to toggle a value in a Set and update UI/counts
function toggleFilterValue(filterName, value, btnEl) {
  const set = selected[filterName];
  if (!set) return;
  if (set.has(value)) {
    set.delete(value);
    btnEl.classList.remove('selected');
  } else {
    set.add(value);
    btnEl.classList.add('selected');
  }
  updateMatchCount();
}

// Attach listeners to Diff (level) buttons
Array.from(document.querySelectorAll('#diffRow .btn')).forEach(btn => {
  btn.addEventListener('click', () => {
    const v = btn.dataset.value;
    if (!v) return;
    toggleFilterValue('diff', v, btn);
  });
});

// Clear filters button: clear internal diff set and visual selected classes
if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    selected.diff.clear();
    document.querySelectorAll('#diffRow .btn').forEach(b => b.classList.remove('selected'));
    updateMatchCount();
  });
}

// Wire Only Complete checkbox change to update counts (UI)
if (onlyCompleteCheckbox){
  onlyCompleteCheckbox.addEventListener('change', () => {
    updateMatchCount();
  });
}

// -------------------- Sample / Random wiring (UPDATED to respect include spelled-tonics) ----
randomBtn.addEventListener('click', async () => {
  const pick = catalog.length ? pickRandom(currentMatches()) : { path:'sample', text: sample, dir:'descending', mode:'major', diff:1, title:'Sample' };
  currentEntry = pick;
  const m = pick.mode || (pick.text.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m)?.[1] === pick.text.match(/^\*([A-Ga-g])([#\u266f-]?)\s*:/m)?.[1]?.toUpperCase() ? 'major' : 'minor') || 'major';

  // Use effective allowed tonics (if include toned selected, they filter the candidates)
  const allowedTonics = getEffectiveAllowedTonicsForMode(m);
  traceLog(`Allowed tonics for mode=${m}: ${JSON.stringify(allowedTonics)}`);

 if (!allowedTonics.length){
  const msg = 'No allowed keys selected for this mode. Enable one or more key-range buttons (0..7) or choose Include keys.';
  setStatus(msg, true);
  traceLog('ERROR: ' + msg);
  updatePillsFromCatalogEntry(pick);
  updateKeyPill('', m);
  humPanel.textContent = '##original\n' + suppressThirdFourthSpinesAfterKey(pick.text) + '\n\n##transposed to [none]\n';
  return;
}

  const tonic = normalizeTonicForHumdrum(pickRandom(allowedTonics));
  lastTargetTonic = tonic;
  lastTargetMode = m;

  updatePillsFromCatalogEntry(pick);
  updateKeyPill(tonic || '', m);
  runPipelineForEntry(pick, tonic, m);
});

// -------------------- Scale / Spacing wiring --------------------
function updateScaleValueDisplay(){
  if (scaleValue && scaleSlider) scaleValue.textContent = String(Number(scaleSlider.value));
}
function updateSpacingValueDisplay(){
  if (spacingValue && spacingSlider) spacingValue.textContent = (Number(spacingSlider.value)/100).toFixed(2);
}
if (scaleSlider){
  scaleSlider.addEventListener('input', () => {
    updateScaleValueDisplay();
    if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic);
    else renderWithVerovio(sample, '');
  });
  updateScaleValueDisplay();
}
if (spacingSlider){
  spacingSlider.addEventListener('input', () => {
    updateSpacingValueDisplay();
    if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic);
    else renderWithVerovio(sample, '');
  });
  updateSpacingValueDisplay();
}
if (scaleMinus) scaleMinus.addEventListener('click', ()=>{ scaleSlider.value = Math.max(10, Number(scaleSlider.value)-1); updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (scalePlus) scalePlus.addEventListener('click', ()=>{ scaleSlider.value = Math.min(120, Number(scaleSlider.value)+1); updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (scaleReset) scaleReset.addEventListener('click', ()=>{ scaleSlider.value = 50; updateScaleValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });

if (spacingMinus) spacingMinus.addEventListener('click', ()=>{ spacingSlider.value = Math.max(10, Number(spacingSlider.value)-1); updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (spacingPlus) spacingPlus.addEventListener('click', ()=>{ spacingSlider.value = Math.min(80, Number(spacingSlider.value)+1); updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });
if (spacingReset) spacingReset.addEventListener('click', ()=>{ spacingSlider.value = 32; updateSpacingValueDisplay(); if (currentKrn) renderWithVerovio(currentKrn, lastTargetTonic); else renderWithVerovio(sample, ''); });

// -------------------- Misc UI placeholders --------------------
if (tpMinus) tpMinus.addEventListener('click', ()=> { /* handled above */ });
if (tpPlus) tpPlus.addEventListener('click', ()=> { /* handled above */ });
if (tpToggle) tpToggle.addEventListener('click', ()=> { /* handled above */ });

// -------------------- Init: catalog or sample --------------------
const paths = await (async () => {
  try { return await fetchList(); } catch(e){ return []; }
})();
if (paths.length){
  setStatus('Indexing tunes.json…');
  await buildCatalog(paths, 4);
  setStatus('Index complete — choose filters & key range, then click “New Bass Line”.');
} else {
  setStatus('No tunes.json found — using sample.');
}

// By default include all spelled tonics (user asked default = all lit up)
selectAllIncludeTonics();

// Also make sure key-range default selected matches earlier behavior (all)
for (let i=0;i<=7;i++) enabledCounts.add(i);
refreshKeyButtonsUI();
updateMatchCount();

if (!currentKrn) {
  currentEntry = { path:'sample', text: sample, dir:'descending', mode:'major', diff:1, title:'Sample' };
  const prepared = suppressThirdFourthSpinesAfterKey(sample);
  humPanel.textContent = '##original\n' + prepared + '\n\n##transposed to [none]\n';
  renderWithVerovio(sample, '');
  setStatus('ready — toggle TRACE and click "New Bass Line"');
}

// Drop-in: insert Boyvin signature immediately to the right of the key pill
(function insertBoyvinSignature() {
  const keyPill = document.getElementById('keyPill');
  if (!keyPill) return;

  // Create wrapper
  const wrap = document.createElement('div');
  wrap.id = 'boyvinSig';
  wrap.className = 'boyvin-signature';
  // Use root path file name as requested
  const img = document.createElement('img');
  img.src = 'boyvinsignature.png';
  img.alt = "Boyvin signature";
  wrap.appendChild(img);

  // Insert after keyPill inside title-badges (so it's to the right)
  keyPill.parentNode.insertBefore(wrap, keyPill.nextSibling);

  // Keep visibility in sync with keyPill (if key pill is hidden, hide signature)
  function syncVisibility() {
    // If keyPill is display:none or not visible, hide signature
    const kpStyle = window.getComputedStyle(keyPill);
    if (kpStyle && kpStyle.display === 'none') wrap.style.display = 'none';
    else wrap.style.display = 'inline-block';
  }
  syncVisibility();

  // Observe style/class changes on keyPill and re-sync
  const mo = new MutationObserver(syncVisibility);
  mo.observe(keyPill, { attributes: true, attributeFilter: ['style', 'class'] });

  // And also sync on window resize (in case layout toggles change visibility)
  window.addEventListener('resize', syncVisibility);
})();


})();
</script>
</body>
</html>
